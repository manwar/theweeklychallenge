<!DOCTYPE html>
<html class="no-js" lang="en-us">
<head>
    <!-- Basic Page Needs -->

    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta property="og:title"       content="The Weekly Challenge - Perl & Raku"/>
    <meta property="og:type"        content="website"/>
    <meta property="og:url"         content="https://perlweeklychallenge.org/"/>
    <meta property="og:image"       content="https://perlweeklychallenge.org/images/about/about.jpg"/>
    <meta property="og:description" content="You do not have to be an expert."/>
    <meta name="twitter:card"       content="summary" />
    <meta name="twitter:image"      content="https://perlweeklychallenge.org/images/about/about.jpg"/>

    <meta http-equiv="Content-Type" content="text/html; charset=utf-8">

    <meta name="description" content="Laurent Rosenfeld Weekly Review: Challenge - #008.">
    <meta name="author" content="Perl Weekly Challenge Team">
    <meta name="generator" content="Hugo 0.66.0-DEV" />

    <!-- Mobile Specific Metas -->
    <meta name="format-detection" content="telephone=no">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>Laurent Rosenfeld Weekly Review: Challenge - 008</title>
    <link rel="icon" href="https://perlweeklychallenge.org/images/favicon.ico">

    
    <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.0/css/bootstrap.min.css"/>

    <!-- Twitter Bootstrs CSS -->
    <link rel="stylesheet" href="https://perlweeklychallenge.org/plugins/bootstrap/bootstrap.min.css">
    <!-- Ionicons Fonts Css -->
    <link rel="stylesheet" href="https://perlweeklychallenge.org/plugins/ionicons/ionicons.min.css">
    <!-- animate css -->
    <link rel="stylesheet" href="https://perlweeklychallenge.org/plugins/animate-css/animate.css">
    <!-- Hero area slider css-->
    <link rel="stylesheet" href="https://perlweeklychallenge.org/plugins/slider/slider.css">
    <!-- slick slider -->
    <link rel="stylesheet" href="https://perlweeklychallenge.org/plugins/slick/slick.css">
    <!-- Fancybox -->
    <link rel="stylesheet" href="https://perlweeklychallenge.org/plugins/facncybox/jquery.fancybox.css">
    <!-- hover -->
    <link rel="stylesheet" href="https://perlweeklychallenge.org/plugins/hover/hover-min.css">
    <!-- template main css file -->
    
    <link rel="stylesheet" href="https://perlweeklychallenge.org/css/style.min.css" integrity="" media="screen">
    <link rel="stylesheet" href="https://perlweeklychallenge.org/css/main.css">
</head>

<body>

<section class="top-bar animated-header">
    <div class="container">
        <div class="row">
            <div class="col-lg-12">
                <nav class="navbar navbar-expand-lg navbar-light bg-light">
                    <a class="navbar-brand" href="https://perlweeklychallenge.org/">
                        <img src="https://perlweeklychallenge.org/images/logo.svg" alt="logo">
                    </a>
                    <button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navgation" aria-controls="navigation"
                        aria-expanded="false" aria-label="Toggle navigation">
                        <span class="navbar-toggler-icon"></span>
                    </button>

                    <div class="collapse navbar-collapse" id="navigation">
                        <ul class="navbar-nav ml-auto">
                            <li class="nav-item">
                                <a class="nav-link" href="https://perlweeklychallenge.org/">Home</a>
                            </li>
                            
                            <li class="nav-item">
                                <a class="nav-link" href="https://perlweeklychallenge.org/about">About</a>
                            </li>
                            
                            <li class="nav-item">
                                <a class="nav-link" href="https://perlweeklychallenge.org/chart">Chart</a>
                            </li>
                            
                            <li class="nav-item">
                                <a class="nav-link" href="https://perlweeklychallenge.org/champions">Champions</a>
                            </li>
                            
                            <li class="nav-item">
                                <a class="nav-link" href="https://perlweeklychallenge.org/team">Team</a>
                            </li>
                            
                            <li class="nav-item">
                                <a class="nav-link" href="https://perlweeklychallenge.org/challenges">Challenges</a>
                            </li>
                            
                            <li class="nav-item">
                                <a class="nav-link" href="https://perlweeklychallenge.org/p5-reviews">Perl/Review</a>
                            </li>
                            
                            <li class="nav-item">
                                <a class="nav-link" href="https://perlweeklychallenge.org/p6-reviews">Raku/Review</a>
                            </li>
                            
                            <li class="nav-item">
                                <a class="nav-link" href="https://perlweeklychallenge.org/recaps">Recaps</a>
                            </li>
                            
                            <li class="nav-item">
                                <a class="nav-link" href="https://perlweeklychallenge.org/blogs">Blogs</a>
                            </li>
                            
                            <li class="nav-item">
                                <a class="nav-link" href="https://perlweeklychallenge.org/faq">FAQ</a>
                            </li>
                            
                            <li class="nav-item">
                                <a class="nav-link" href="https://perlweeklychallenge.org/contact">Contact</a>
                            </li>
                            
                        </ul>
                    </div>
                </nav>
            </div>
        </div>
    </div>
</section>


<section class="global-page-header">
    <div class="container">
        <div class="row">
            <div class="col-md-12">
                <div class="block">
                    <h2>Laurent Rosenfeld Weekly Review: Challenge - 008</h2>
                    <div class="portfolio-meta">
                        <span>Friday, Feb 1, 2019</span>|
                        <span> Tags:
                            Raku
                        </span>
                    </div>
                </div>
            </div>
        </div>
    </div>
</section>

<section class="single-post">
    <div class="container">
        <div class="row">
            <div class="col-md-12">
                
                <div style="text-align: center" class="post-img">
                    <img class="img-fluid" alt="" src="https://perlweeklychallenge.org/images/blog/p6-review-challenge-008.jpg">
                </div>
                
                <div style="text-align: justify" class="post-content">
                    <hr>
<h1 id="raku-solutions-weekly-review">Raku Solutions Weekly Review</h1>
<hr>
<h2 id="task-1-perfect-numbers">Task #1: Perfect Numbers</h2>
<p>This is derived from my <a href="http://blogs.perl.org/users/laurent_r/2019/05/perl-weekly-challenge-8-perfect-numbers-and-centered-output.html">blog post</a> made in answer to the <a href="https://perlweeklychallenge.org/blog/perl-weekly-challenge-008/">Week 8 of the Perl Weekly Challenge</a> organized by  <a href="http://blogs.perl.org/users/mohammad_s_anwar/">Mohammad S. Anwar</a> as well as answers made by others to the same challenge.</p>
<p>The challenge reads as follows:</p>
<p><em>Write a script that computes the first five perfect numbers. A perfect number is an integer that is the sum of its positive proper divisors (all divisors except itself). Please check <a href="https://en.wikipedia.org/wiki/Perfect_number">Wiki</a> for more information. This challenge was proposed by Laurent Rosenfeld.</em></p>
<p>Since Mohammad Anwar revealed that I suggested this challenge, let me add a few things about it. The idea of this challenge comes from a very long recollection: the requirement is almost the same as a programming assignment I had during the first year (actually the first few months) of my CS study back in 1991, except for the fact that we were asked to write a program (in Pascal at the time) to find the perfect numbers below 10,000 (i.e. 4 perfect numbers). If a student can do it in the very first months of his or her CS curriculum, then it would certainly be too easy for a challenge aimed at experienced CS professionals. This the reason why my suggestion was to find the first 5 perfect numbers (instead of 4) as this makes a real difference: as we will see, finding the fifth perfect number is significantly more difficult that finding the first 4 ones.</p>
<p>Let me also be clear on something before we start: 1 is <em>not</em> a perfect number, because the definition says the sum of <em>all its divisors except itself</em>. The sum of all divisors except itself of 1 is 0; thus, 1 is not a perfect number. The first perfect number is 6 ( = 1 + 2 + 3).</p>
<h2 id="my-solutions">My Solutions</h2>
<h3 id="brute-force-approach">Brute Force Approach</h3>
<p>Let&rsquo;s try brute force approach to grasp the problem. I&rsquo;ll start with my assignment of 1991, i.e. finding the perfect numbers below 10,000:</p>
<pre><code class="language-Perl6" data-lang="Perl6">use v6;

sub divisors (Int $num) {
    return 1, | grep { $num %% $_ }, 2 .. (1 + ($num / 2).Int);
}

for 2..10000 -&gt; $num {
    my @divisors = divisors $num;
    say &quot;$num: &quot;, @divisors if $num == [+] @divisors;
}
</code></pre><p>Easy, nothing complicated. I made a separate <code>divisors</code> subroutine because we may later want to reuse it. If we run that program, we get the following output:</p>
<pre><code>6: [1 2 3]
28: [1 2 4 7 14]
496: [1 2 4 8 16 31 62 124 248]
8128: [1 2 4 8 16 32 64 127 254 508 1016 2032 4064]
</code></pre>
<p>The <code>divisors</code> subroutine is so short that we could inline it in the main code:</p>
<pre><code class="language-Perl6" data-lang="Perl6">use v6;

for 2..10000 -&gt; $num {
    my @divisors = 1, | grep { $num %% $_ }, 2 .. (1 + ($num / 2).Int);
    say &quot;$num: &quot;, @divisors if $num == [+] @divisors;
}
</code></pre><p>Well, if we just want the perfect numbers without willing to print the list of divisors, we could even get rid of the <code>@divisors</code> temporary array and make it short enough for a one-liner:</p>
<pre><code>$ perl6 -e 'for 2..10000 -&gt; $num { $num.say if $num == [+] (1, | grep { $num %% $_ }, 2 .. (1 + ($num / 2).Int))};'
</code></pre>
<p>So, the code is very short, but I regret to say that both these versions are quite slow: they take bout 25 seconds to run (about ten times more than the Perl 5 equivalent program).</p>
<p>If we want to find the fifth perfect number, we need to increase the range. So, perhaps we could try with numbers up to 100,000, maybe we&rsquo;ll find the next perfect number. Well, that does not work. Not only we would not find any new perfect number with this new limit (because, as we will find out later, the next perfect number is much larger than that), but with 10 times more numbers to study, the program would take about 100 times more time to execute, i.e. more than 40 minutes.</p>
<p>This program really does not scale well. The problem stems from the fact that we have two nested loops (even if it&rsquo;s a bit hidden by the fact that one of the loops is a <code>grep</code> in the subroutine and the other calling that subroutine). Note that I very well knew that something like this was going to happen, but nonetheless made the test to get actual timings to illustrate the problem. We are not going to continue in this direction and try with a limit of one million, as this would take about two months to run (with no guarantee to find the next perfect number).</p>
<h3 id="a-better-algorithm-to-speed-up-things-triangular-numbers">A Better Algorithm to Speed up Things: Triangular Numbers</h3>
<p>When we were given this assignment back in 1991, not only was the hardware much slower than today, but the Web did not exist (well, it had just been created but was still an internal tool of the CERN, it went public only in 1993) and there certainly wasn&rsquo;t something like Wikipedia (which was created in 2001) to find additional information about perfect numbers. Our professor had been quite wise to ask only for the first four perfect numbers.</p>
<p>Looking at the Wikipedia page on perfect numbers, we can find a lot on interesting information on perfect numbers. First, all known perfect numbers are even (but it is not known whether there are odd perfect numbers, it can only be said that none has been found so far). Assuming that we are looking only for even numbers will cut the duration by half, but that&rsquo;s far from sufficient to solve the performance problem.</p>
<p>The article provides an additional piece of information: all even perfect numbers are <a href="https://en.wikipedia.org/wiki/Triangular_number">triangular numbers</a>. This is a list of triangular numbers:</p>
<pre><code>0, 1, 3, 6, 10, 15, 21, 28, 36, 45, 55, 66, 78, 91, 105, ..., 1225, 1275, 1326, 1378,
</code></pre>
<p>You start with 0. Add 1 to it to get the next one (1). Add 2 to second one to get the third one (3). Add 3 to the third one (6). And so on. This is interesting because there becoming increasingly sparse and we&rsquo;ll need to check the divisors of much fewer numbers.</p>
<pre><code class="language-Perl6" data-lang="Perl6">use v6;

sub divisors (Int $num) {
    return 1, | grep { $num %% $_ }, 2 .. (1 + ($num / 2).Int);
}
my $triangular-num = 1;
for 2..200 -&gt; $num {
    $triangular-num += $num;
    my $sum-div = [+] divisors $triangular-num;
    say &quot; $triangular-num : @divisors[]&quot; if $sum-div == $triangular-num;
    last if $triangular-num &gt; 10000;
}
say now -  INIT now;
</code></pre><p>Now, finding the first four perfect numbers takes about a third of a second:</p>
<pre><code>$ perl6 triangular_perfect.p6
6
28
496
8128
0.3385362
</code></pre>
<h3 id="using-lazy-infinite-sequences">Using Lazy Infinite Sequences</h3>
<p>One of the difficulties in the code above is to determine the required range for <code>$num</code>. The math is not too difficult to compute that the upper bound should be close the square root of twice the ceiling for perfect numbers (i.e. about 141 for a ceiling of 10,000), but I used an upper bound of 200 to be on the safe side of things. The best would be not to have to compute that upper bound. Here come to the rescue lazy infinite lists. For example, we can generate an infinite list <code>@nums</code> of consecutive integers for <code>$num</code>, and Perl 6 will compute them as and when needed until it reaches the limit for <code>$triangular-num</code>:</p>
<pre><code class="language-Perl6" data-lang="Perl6">use v6;

sub divisors (Int $num) {
    return 1, | grep { $num %% $_ }, 2 .. (1 + ($num / 2).Int);
}
my $triangular-num = 1;
my @nums = 2 ... *;   # Infinite sequence
for @nums -&gt; $num {
    $triangular-num += $num;
    my $sum-div = [+] divisors $triangular-num;
    say $triangular-num if $sum-div == $triangular-num;
    last if $triangular-num &gt; 10000;
}
say now -  INIT now;
</code></pre><p>It is more concise and probably more idiomatic to generate directly an infinite sequence of triangular numbers:</p>
<pre><code class="language-Perl6" data-lang="Perl6">use v6;

sub divisors (Int $num) {
    return 1, | grep { $num %% $_ }, 2 .. (1 + ($num / 2).Int);
}
my $num = 1;
my @triangular-numbers = 1,  * + ++$num ... *;
for @triangular-numbers -&gt; $triangular-num {
    last if $triangular-num &gt; 10000;
    say $triangular-num if $triangular-num == [+] divisors $triangular-num;
}
say now -  INIT now;
</code></pre><p>The key code line here is where the <code>@triangular-numbers</code> is defined. It is an infinite sequence using an explicit generator: each value is created by adding the previous value and a number, <code>$num</code>, which is itself incremented at each step through the process.</p>
<p>Rather than building an infinite list, we could also build a list of the triangular numbers less than 10,000 (thereby making the <code>last</code> statement in the loop unnecessary) by adding a code block saying where the sequence should stop:</p>
<pre><code class="language-Perl6" data-lang="Perl6">use v6;

sub divisors (Int $num) {
    return 1, | grep { $num %% $_ }, 2 .. (1 + ($num / 2).Int);
}
my $num = 1;
my @triangular-numbers = 1,  * + ++$num ...^ * &gt; 10000 ;
.say if $_ == [+] divisors $_ for @triangular-numbers;
say now - INIT now;
</code></pre><p>This program displays the same four perfect numbers:</p>
<pre><code>$ perl6 triangular_perfect.p6
1
6
28
496
8128
0.2695492
</code></pre>
<p>You might object that the requirement was to display the first five perfect numbers, and we haven&rsquo;t done that yet. Yes, indeed. Even if our program now runs pretty fast, we know from having coded the same algorithm in Perl 5 that this won&rsquo;t be fast enough for the fifth perfect number: it would take more than seven hours.</p>
<p>So, we need yet a better algorithm.</p>
<h3 id="mersenne-numbers">Mersenne Numbers</h3>
<p>The Mersenne number are powers of 2 minus one. More precisely, for every integer number <em>n</em>, the corresponding Mersenne number is the number <code>(2 ** n) -1</code>. Their name is associated with Marin Mersenne, a French monk and scholar living in the seventeenth century. These numbers had been studied long before, notably in antiquity by Greek mathematician Euclid of Alexandria, but Mersenne studied them in detail in the context of primality of large numbers, and he may have demonstrated that a Mersenne number <code>(2 ** n) -1</code> can be prime only if <em>n</em> is also prime. The opposite is not true: for example, 11 is prime, but <code>(2 ** 11) -1</code> is not prime. Mersenne prime numbers are still very important today in the search of very large prime numbers: as of 2018, the seven largest known prime numbers are Mersenne primes.</p>
<p>Euclid discovered and demonstrated an interesting property about the Mersenne primes (although they were obviously not called like that at the time) and perfect numbers: if a Mersenne number <code>(2 ** p) -1</code> is prime (which requires <em>p</em> to be also prime), then the number <code>((2 ** p) -1) * 2 ** (p - 1)</code> is a perfect number. In the eighteenth century, Swiss mathematician Leonhard Euler proved conversely that every even perfect number has this form. This is sometimes known as the <a href="https://en.wikipedia.org/wiki/Euclid%E2%80%93Euler_theorem">Euclid Euler theorem</a>.</p>
<p>This can give us a much faster way to identify perfect numbers: compute Mersenne numbers <code>(2 ** p) -1</code> with <em>p</em> prime, check if such Mersenne number is itself prime, and if it is, that we know that <code>((2 ** p) -1) * (2 ** (p - 1))</code> is a perfect number.</p>
<p>When we wrote our Perl 5 program using Mersenne numbers for answering the Perl 5 part of the challenge, we spent quite a bit of energy trying to make an efficient <code>is_prime</code> subroutine.  We don&rsquo;t need that in Perl 6, since it has a built-in function, <code>is-prime</code>, which uses the very fast Miller-Rabin algorithm to find out whether a number is prime. To tell the truth, the Miller-Rabin algorithm is a probabilistic test, which may in theory report that a composite number is prime, but the probability of occurrence of such an event is so abysmally low that we can just dismiss it for practical purposes.</p>
<p>The other advantage of P6 is its built-in ability to do integer calculations with arbitrary precision.</p>
<p>This a Perl 6 program displaying the first 12 perfect numbers in about half a tenth of a second:</p>
<pre><code class="language-Perl6" data-lang="Perl6">use v6;

for grep { is-prime $_ }, 0..300 -&gt; $prime {
    my $mersenne =  2 ** $prime - 1;
    say $mersenne * 2 ** ($prime - 1) if is-prime $mersenne;
}
say &quot;time taken &quot;, now - INIT now;
</code></pre><p>This displays the following:</p>
<pre><code>$ perl6 mersenne_perfect.p6
6
28
496
8128
33550336
8589869056
137438691328
2305843008139952128
2658455991569831744654692615953842176
191561942608236107294793378084303638130997321548169216
13164036458569648337239753460458722910223472318386943117783728128
14474011154664524427946373126085988481573677491474835889066354349131199152128
time taken: 0.0533907
</code></pre>
<p>The last number displayed has 77 digits, and calculating these 12 perfect numbers took less than 0.06 second.</p>
<p>Computing the first 15 perfect numbers took 0.64 second on my old rather inefficient laptop, and the fifteenth perfect number (built with prime number 1279) has 770 digits.</p>
<h2 id="alternate-solutions">Alternate Solutions</h2>
<p><a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-008/arne-sommer/perl6/ch-1.p6">Arne Sommer</a> implemented a <code>proper-divisors</code> multi subroutine and a <code>is-perfect</code> subroutine. His program then creates a lazy <code>gather</code> infinite loop to create a sequence of perfect numbers, and finally prints out the first five perfect numbers. So basically the same brute force approach I used at the beginning. While this program works well for the first <em>four</em> perfect numbers, I don&rsquo;t believe that it is able to find the <em>fifth</em> perfect number in a reasonable time.</p>
<p><a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-008/ruben-westerberg/perl6/ch-1.p6">Ruben Westerberg</a> also wrote a brute force algorithm similar to my first program above. Ruben&rsquo;s program can find the first <em>four</em> perfect numbers relatively rapidly, but I don&rsquo;t believe that it is able to find the <em>fifth</em> perfect number in a reasonable time.</p>
<p><a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-008/uzluisf/perl6/ch-1.p6">uzluisf</a> used a <code>pos-proper-divisors</code> subroutine and a <code>is-perfect</code> multi subroutine and then loops over successive integers So, again a brute force attempt. As for the two implementations just above, uzluisf&rsquo;s program easily finds the first <em>four</em> perfect numbers, but is certainly not able to find the <em>fifth</em> one in a reasonable time.</p>
<p><a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-008/fjwhittle/perl6/ch-1.p6">Francis J. Whittle</a> created a lazy infinite sequence of prime Mersenne numbers and derived from it an infinite lazy sequence of perfect numbers:</p>
<pre><code class="language-Perl6" data-lang="Perl6"># Mersenne prime generator.
my \M := (^∞)
           .grep(*.is-prime)
           .map(-&gt; $n { 2 ** $n - 1})
           .grep(*.is-prime);

# Derive perfect number from Mersenne primes.
my \P := M.map: -&gt; $q { $q * ($q + 1) div 2 };

# Compute and present the first 5, one per line.
P[^5]».put
</code></pre><p><a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-008/jaldhar-h-vyas/perl6/ch-1.p6">Jaldhar H. Vyas</a> used the Mersenne numbers as a source for perfect candidates and then checked manually the divisors to find out whether the candidate is really perfect:</p>
<pre><code class="language-Perl6" data-lang="Perl6">sub perfectCandidate(Int $p) {
    my $q = 2 ** $p - 1;          # Mersenne number
    return $q * ($q + 1) div 2;   # perfect candidate
}
sub isPerfect(Int $number) {
    my $total = 0;
    for 1 .. $number -&gt; $i {
        if $number %% $i {
            $total += $i;
        }
    }

    return ($total / 2  == $number);
}
</code></pre><p>Checking for primality of the Mersenne numbers (using the <code>is-prime</code> built-in function) would make the program significantly faster than checking if the candidate is perfect, but Jaldar&rsquo;s program does find the first five perfect number in a reasonable time.</p>
<p><a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-008/joelle-maslak/perl6/ch-1.p6">Joelle Maslak</a> did essentially the same thing as Jaldhar: her program uses a lazy <code>gather</code> to generate a lazy infinite sequence of perfect candidates from the Mersenne numbers and then sums the factors of the candidates to determine whether the candidate is actually perfect:</p>
<pre><code class="language-Perl6" data-lang="Perl6">my @vals = lazy gather {
    loop {
        state $p = 1;
        $p++;

        my $possible = (2**($p-1))*((2**$p)-1);
        take $possible if ([+] factors($possible)[0..*-2]) == $possible;
    }
}
</code></pre><p>And I can only make the same comment as for Jaldhar: checking for primality of the intermediate Mersenne numbers would have made this program much faster. Joelle&rsquo;s program has this warning:</p>
<pre><code class="language-Perl6" data-lang="Perl6">if $max &gt; 7 {
    say &quot;More than 7 perfect numbers may take too long to calculate&quot;;
}
</code></pre><p>Indeed. Checking primality of the Mersenne number (as in James Smith&rsquo;s program just below, Ozzy&rsquo;s program immediately thereafter, or my last program above) makes it possible to compute the first 20 perfect number in about ten seconds. This being said, Joelle&rsquo;s program does find the first five perfect number in a reasonable time.</p>
<p><a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-008/james-smith/perl6/ch-1.p6">James Smith</a> used the Mersenne numbers and a lazy <code>gather</code> block to generate a lazy infinite sequence of perfect numbers. James&rsquo;s implementation is very concise and very fast:</p>
<pre><code class="language-Perl6" data-lang="Perl6">my @perfect = lazy gather {
  my $q = 1;
  take $q*($q+1)/2 if (++($q+&lt;=1)).is-prime while 1;
}
say @perfect[$_] for 0..19;
</code></pre><p><a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-008/ozzy/perl6/ch-1.p6">Ozzy</a> also used the Mersenne numbers and a primality check in a quite concise program:</p>
<pre><code class="language-Perl6" data-lang="Perl6">for 1..17 -&gt; $p {
    my $b = (2**$p -1);
    say &quot;$p : { 2**($p-1) * $b }&quot; if $b.is-prime;

}
</code></pre><p><a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-008/simon-proctor/perl6/ch-1.p6">Simon Proctor</a> also used the Mersenne numbers. He implemented a <code>is-mersine</code> multi subroutine and a <code>perfect-from-prime</code> subroutine</p>
<pre><code class="language-Perl6" data-lang="Perl6">sub perfect-from-prime( Int $p where { $p.is-prime &amp;&amp; is-mersine( $p ) } ) is pure {
    return (2**($p-1)) * ((2**$p) -1 );
}
multi sub is-mersine( Int $ ) is pure { False; }
multi sub is-mersine( Int $p where ((2**$p)-1).is-prime ) is pure { True; }
</code></pre><p>Simon&rsquo;s main code then makes a lazy infinite list of perfect numbers and picks the first five:</p>
<pre><code class="language-Perl6" data-lang="Perl6">.say for (0..*).grep( *.is-prime ).grep( { is-mersine( $_ ) } ).map( { perfect-from-prime($_) } )[^$x];
</code></pre><h2 id="see-also">SEE ALSO</h2>
<p>Three blog posts this time:</p>
<ul>
<li>
<p>Arne Sommer: <a href="https://perl6.eu/perfect-indentation.html">https://perl6.eu/perfect-indentation.html</a>.</p>
</li>
<li>
<p>Francis J. Whittle: <a href="https://rage.powered.ninja/2019/05/15/squaring-perfect-centre.html">https://rage.powered.ninja/2019/05/15/squaring-perfect-centre.html</a>.</p>
</li>
<li>
<p>Simon Proctor: <a href="http://www.khanate.co.uk/blog/2019/05/14/perl-weekly-challenge-part-8/">http://www.khanate.co.uk/blog/2019/05/14/perl-weekly-challenge-part-8/</a>.</p>
</li>
</ul>
<h2 id="wrapping-up">Wrapping up</h2>
<p>Please let me know if I forgot any of the challengers or if you think my explanation of your code misses something important.</p>
<p>If you want to participate to the Perl Weekly Challenge, please connect to <a href="https://perlweeklychallenge.org/">this site</a>.</p>

                </div>
            </div>
        </div>
    </div>
</section>


<!-- Call To Action Section Start -->
<section id="call-to-action">
    <div class="container">
        <div class="row">
            <div class="col-md-12">
                <div class="block">
                    <h2 class="title wow fadeInDown" data-wow-delay=".3s" data-wow-duration="500ms">SO WHAT DO YOU THINK ?</h2>
                    <p class="wow fadeInDown" data-wow-delay=".5s" data-wow-duration="500ms">If you have any suggestions or ideas then please do share with us.</p>
                    <a href="/contact" class="btn btn-default btn-contact wow fadeInDown" data-wow-delay=".7s" data-wow-duration="500ms">Contact with me</a>
                </div>
            </div>

        </div>
    </div>
</section>
<!-- Call To Action Section End -->



<!-- Footer Section Start -->
<footer id="footer">
    <div class="container">
        <div class="row content-justify-between">
            <div class="col-md-8 col-12 text-center text-lg-left text-md-left">
                <p class="copyright">Copyright:
                    <span>
                        <script>document.write(new Date().getFullYear())</script>
                    </span> PerlWeeklyChallenge. Theme Design and Developed by
                    <a href="http://www.Themefisher.com" target="_blank">Themefisher</a>.
                </p>
            </div>
            <div class="col-md-4 col-12">
                <!-- Social Media -->
                <ul class="social text-center text-md-right text-lg-right">
                    <li>
                        <a href="https://twitter.com/PerlWChallenge" class="twitter" target="_blank" title="Follow us">
                            <i class="ion-social-twitter"></i>
                        </a>
                    </li>
                    <li>
                        <a href="/rss.xml" class="rss" target="_blank" title="RSS Feed">
                            <i class="ion-social-rss"></i>
                        </a>
                    </li>
                    <li>
                        <a href="https://www.nomtimes.co.uk/site/shop.do?cref=PerlBooks" title="Free Perl Books" target="_blank">
                            <img src="/images/NomTimes.jpg" style="width:22px; height: 18px;" alt=""/>
                        </a>
                    </li>
                </ul>
            </div>
        </div>
    </div>
</footer>
<!-- footer section end -->

<!-- jquery -->
<script src="https://perlweeklychallenge.org/plugins/jQurey/jquery.min.js"></script>
<!-- Form Validation -->
<script src="https://perlweeklychallenge.org/plugins/form-validation/jquery.form.js"></script>
<script src="https://perlweeklychallenge.org/plugins/form-validation/jquery.validate.min.js"></script>
<!-- slick slider -->
<script src="https://perlweeklychallenge.org/plugins/slick/slick.min.js"></script>
<!-- bootstrap js -->
<script src="https://perlweeklychallenge.org/plugins/bootstrap/bootstrap.min.js"></script>
<!-- chart js -->
<script src="https://perlweeklychallenge.org/plugins/chart/highstock.js"></script>
<script src="https://perlweeklychallenge.org/plugins/chart/drilldown.js"></script>
<script src="https://perlweeklychallenge.org/plugins/chart/data.js"></script>
<script src="https://perlweeklychallenge.org/plugins/chart/chart.js"></script>
<!-- wow js -->
<script src="https://perlweeklychallenge.org/plugins/wow-js/wow.min.js"></script>
<!-- slider js -->
<script src="https://perlweeklychallenge.org/plugins/slider/slider.js"></script>
<!-- Fancybox -->
<script src="https://perlweeklychallenge.org/plugins/facncybox/jquery.fancybox.js"></script>
<!-- template main js -->

<script src="https://perlweeklychallenge.org/js/script.min.js"></script>
<!-- google analitycs -->
<script>
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
    (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
    m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
    ga('create', 'UA-136524905-1', 'auto');
    ga('send', 'pageview');
</script>
</body>

</html>

