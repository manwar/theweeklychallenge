<!DOCTYPE html>
<html class="no-js" lang="en-us">
<head>
    <!-- Basic Page Needs -->

    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta property="og:title"       content="The Weekly Challenge - Perl & Raku"/>
    <meta property="og:type"        content="website"/>
    <meta property="og:url"         content="https://perlweeklychallenge.org/"/>
    <meta property="og:image"       content="https://perlweeklychallenge.org/images/about/about.jpg"/>
    <meta property="og:description" content="You do not have to be an expert."/>
    <meta name="twitter:card"       content="summary" />
    <meta name="twitter:image"      content="https://perlweeklychallenge.org/images/about/about.jpg"/>

    <meta http-equiv="Content-Type" content="text/html; charset=utf-8">

    <meta name="description" content="Advent Calendar - December 1, 2019.">
    <meta name="author" content="Perl Weekly Challenge Team">
    <meta name="generator" content="Hugo 0.67.0-DEV" />

    <!-- Mobile Specific Metas -->
    <meta name="format-detection" content="telephone=no">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>Advent Calendar - December 1, 2019</title>
    <link rel="icon" href="https://perlweeklychallenge.org/images/favicon.ico">

    
    <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.0/css/bootstrap.min.css"/>

    <!-- Twitter Bootstrs CSS -->
    <link rel="stylesheet" href="https://perlweeklychallenge.org/plugins/bootstrap/bootstrap.min.css">
    <!-- Ionicons Fonts Css -->
    <link rel="stylesheet" href="https://perlweeklychallenge.org/plugins/ionicons/ionicons.min.css">
    <!-- animate css -->
    <link rel="stylesheet" href="https://perlweeklychallenge.org/plugins/animate-css/animate.css">
    <!-- Hero area slider css-->
    <link rel="stylesheet" href="https://perlweeklychallenge.org/plugins/slider/slider.css">
    <!-- slick slider -->
    <link rel="stylesheet" href="https://perlweeklychallenge.org/plugins/slick/slick.css">
    <!-- Fancybox -->
    <link rel="stylesheet" href="https://perlweeklychallenge.org/plugins/facncybox/jquery.fancybox.css">
    <!-- hover -->
    <link rel="stylesheet" href="https://perlweeklychallenge.org/plugins/hover/hover-min.css">
    <!-- Google fonts -->
    <link href='https://fonts.googleapis.com/css?family=Source Code Pro' rel='stylesheet'>
    <!-- template main css file -->
    
    <link rel="stylesheet" href="https://perlweeklychallenge.org/css/style.min.css" integrity="" media="screen">
    <link rel="stylesheet" href="https://perlweeklychallenge.org/css/main.css">
</head>

<body>

<section class="top-bar animated-header">
    <div class="container">
        <div class="row">
            <div class="col-lg-12">
                <nav class="navbar navbar-expand-lg navbar-light bg-light">
                    <a class="navbar-brand" href="https://perlweeklychallenge.org/">
                        <img src="https://perlweeklychallenge.org/images/logo.svg" alt="logo">
                    </a>
                    <button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navgation" aria-controls="navigation"
                        aria-expanded="false" aria-label="Toggle navigation">
                        <span class="navbar-toggler-icon"></span>
                    </button>

                    <div class="collapse navbar-collapse" id="navigation">
                        <ul class="navbar-nav ml-auto">
                            <li class="nav-item">
                                <a class="nav-link" href="https://perlweeklychallenge.org/">Home</a>
                            </li>
                            
                            <li class="nav-item">
                                <a class="nav-link" href="https://perlweeklychallenge.org/about">About</a>
                            </li>
                            
                            <li class="nav-item">
                                <a class="nav-link" href="https://perlweeklychallenge.org/chart">Chart</a>
                            </li>
                            
                            <li class="nav-item">
                                <a class="nav-link" href="https://perlweeklychallenge.org/champions">Champions</a>
                            </li>
                            
                            <li class="nav-item">
                                <a class="nav-link" href="https://perlweeklychallenge.org/team">Team</a>
                            </li>
                            
                            <li class="nav-item">
                                <a class="nav-link" href="https://perlweeklychallenge.org/challenges">Challenges</a>
                            </li>
                            
                            <li class="nav-item">
                                <a class="nav-link" href="https://perlweeklychallenge.org/p5-reviews">Perl/Review</a>
                            </li>
                            
                            <li class="nav-item">
                                <a class="nav-link" href="https://perlweeklychallenge.org/p6-reviews">Raku/Review</a>
                            </li>
                            
                            <li class="nav-item">
                                <a class="nav-link" href="https://perlweeklychallenge.org/recaps">Recaps</a>
                            </li>
                            
                            <li class="nav-item">
                                <a class="nav-link" href="https://perlweeklychallenge.org/blogs">Blogs</a>
                            </li>
                            
                            <li class="nav-item">
                                <a class="nav-link" href="https://perlweeklychallenge.org/faq">FAQ</a>
                            </li>
                            
                            <li class="nav-item">
                                <a class="nav-link" href="https://perlweeklychallenge.org/contact">Contact</a>
                            </li>
                            
                        </ul>
                    </div>
                </nav>
            </div>
        </div>
    </div>
</section>


<section class="global-page-header">
    <div class="container">
        <div class="row">
            <div class="col-md-12">
                <div class="block">
                    <h2>Advent Calendar - December 1, 2019</h2>
                    <div class="portfolio-meta">
                        <span>Sunday, Dec 1, 2019</span>|
                        <span> Tags:
                            Perl, Raku
                        </span>
                    </div>
                </div>
            </div>
        </div>
    </div>
</section>

<section class="single-post">
    <div class="container">
        <div class="row">
            <div class="col-md-12">
                
                <div style="text-align: center" class="post-img">
                    <img class="img-fluid" alt="" src="https://perlweeklychallenge.org/images/blog/2019-12-01.jpg">
                </div>
                
                <div style="text-align: justify" class="post-content">
                    <p><a href="/blog/advent-calendar-2019"><strong>Advent Calendar 2019</strong></a></p>
<hr>
<p>The gift is presented by <a href="https://perlweeklychallenge.org/blog/meet-the-champion-013"><strong>Laurent Rosenfeld</strong></a>. Today he is talking about his solutions to <strong>Task #2: Word Ladder** of </strong>&ldquo;The Weekly Challenge - 007&rdquo;**<a href="/blog/perl-weekly-challenge-007"></a>.</p>
<blockquote>
<p>Given two input words and a file that contains an ordered word list, implement a routine that finds the shortest ladder between the two input words. For example, for the words cold and warm, the routine might return:
(&ldquo;cold&rdquo;, &ldquo;cord&rdquo;, &ldquo;core&rdquo;, &ldquo;care&rdquo;, &ldquo;card&rdquo;, &ldquo;ward&rdquo;, &ldquo;warm&rdquo;)</p>
</blockquote>
<h3 id="given">Given:</h3>
<ol>
<li>
<p>All words in the list have the same length.</p>
</li>
<li>
<p>All words contain only lowercase alphabetical characters.</p>
</li>
<li>
<p>There are no duplicates in the word list.</p>
</li>
<li>
<p>The input words aren&rsquo;t empty and aren&rsquo;t equal but they have the same length as any word in the word list.</p>
</li>
</ol>
<h3 id="requirement">Requirement:</h3>
<ol>
<li>
<p>The routine must return a list of the words in the ladder if it exists. Otherwise, it returns an empty list.</p>
</li>
<li>
<p>If any of the input words is the wrong length (i.e., its length is different to a random from the word list) or isnâ€™t in the word list, return an empty list.</p>
</li>
</ol>
<hr>
<hr>
<p>According to this <a href="https://en.wikipedia.org/wiki/Word_ladder">Wikipedia page</a>, word ladder puzzles were invented by the famous writer and mathematician <strong>Lewis Carroll</strong> in <strong>1877</strong>, at a time when there was obviously no computer.</p>
<p>To comply with <strong>Given: #1</strong>, I&rsquo;ll break up my <a href="https://github.com/LaurentRosenfeld/thinkperl6/blob/master/Supplementary/words.txt">words.txt</a> list into files with <strong>2-letters</strong> words, <strong>3-letters</strong> words, and so on, although this is really not necessary: it would be trivial to filter out the words with a different letter count when reading the <strong>words.txt</strong> file.</p>
<p>My <strong>words.txt</strong> input file only contains words with only lowercase alphabetical <strong>ASCII</strong> characters.</p>
<p>I&rsquo;ll slightly depart from <strong>Given: #4</strong> and <strong>Requirement: #1</strong>, if the input words are equal, I&rsquo;ll simply return that word as being the ladder. And I&rsquo;ll abort the program if the input words have different lengths.</p>
<p>Just as for some previous challenges, I will use a <strong>words.txt</strong> file containing <strong>113,809</strong> lower-case English words usually accepted for crossword puzzles and other word games. The words.txt file can be found on my Github repository. The original list was contributed to the public domain by <strong>Internet activist Grady Ward</strong> in the context of the <strong>Moby Project</strong>. This word list is also mirrored at <strong>Project Gutenberg</strong>.</p>
<p>For the purpose of testing the programs below, the <strong>words.txt</strong> file is located in my current directory. Obviously, when we will be reading the list, we will need to keep only the words having the same length as the two input words.</p>
<p>This task is much more complicated than the other task of this week challenge (and than most previous challenges). In fact, my first reaction when reading the problem was, <strong>&ldquo;Gosh, I&rsquo;ve got no idea how I&rsquo;m going to solve that&rdquo;</strong>. In such case, it is often a good idea to try to break up the problem into smaller ones.</p>
<p>The first thing that we must be able to do is to figure out whether one word can be transformed into another with just one letter change. It would probably be also very useful to know whether this can be done with two letter changes, three letter changes, etc. For this, we may want to use a well-known CS string metric named the Levenshtein distance or Levenshtein edit distance, which is the smallest number of single-character edits (insertions, deletions or substitutions) required to change one word into the other. In the case of this challenge, however, we probably don&rsquo;t need to consider insertions and deletions, but are interested only in substitutions.</p>
<p>Once we have a routine to compute the <strong>Levenshtein distance</strong>, we might try to use brute force with backtracking to test all possibilities, or an optimized version thereof able to remove non optimal paths relatively early in the process, or a branch and bound algorithm, or implement some form of <strong>Dijstra&rsquo;s algorithm</strong> for shortest paths.</p>
<h3 id="perl-solution">Perl Solution</h3>
<h5 id="computing-the-edit-distance-in-perl">Computing the Edit Distance In Perl</h5>
<p>There are a number of <strong>CPAN</strong> modules to compute the Levenshtein distance on the CPAN, such as Text::Levenshtein and some variants. However, we will not use any of them for several reasons. One is that using a ready-made library for solving such a challenge is kind of cheating; I especially don&rsquo;t wish to use a non-core module. The second reason is that, as we have seen above, the general Levenshtein distance is the smallest number of single-character edits (insertions, deletions or substitutions) required to change one word into the other, where as, since our input words have the same length, we&rsquo;re interested with only the smallest number of substitutions. The last reason is that, because of the second reason just stated, computing the full Levenshtein distance would be overkill: we really need to compute only the number of letter differences for each given position in the input words. Because of that, I&rsquo;ll use the term edit distance, rather than Levenshtein distance.</p>
<p>Once we&rsquo;ve clarified in our head what we need, it is quite simple to write our <strong>sub edit_distance()</strong> and some code to test it:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-perl" data-lang="perl"><span style="color:#66d9ef">use</span> strict;
<span style="color:#66d9ef">use</span> warnings;
<span style="color:#66d9ef">use</span> feature <span style="color:#e6db74">qw/say/</span>;

<span style="color:#66d9ef">sub</span> <span style="color:#a6e22e">edit_distance</span> {
    <span style="color:#66d9ef">my</span> ($word1, $word2) <span style="color:#f92672">=</span> @_;
    die <span style="color:#e6db74">&#34;Words $word1 and $word2 have different lengths\n&#34;</span> <span style="color:#66d9ef">unless</span> length $word1 <span style="color:#f92672">==</span> length $word2;
    <span style="color:#66d9ef">my</span> @w1 <span style="color:#f92672">=</span> split <span style="color:#e6db74">//</span>, $word1;
    <span style="color:#66d9ef">my</span> @w2 <span style="color:#f92672">=</span> split <span style="color:#e6db74">//</span>, $word2;
    <span style="color:#66d9ef">my</span> $dist <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
    <span style="color:#66d9ef">for</span> <span style="color:#66d9ef">my</span> $i (<span style="color:#ae81ff">0</span><span style="color:#f92672">..</span>$#w1) {
        $dist<span style="color:#f92672">++</span> <span style="color:#66d9ef">if</span> $w1[$i] <span style="color:#f92672">ne</span> $w2[$i];
    }
    <span style="color:#66d9ef">return</span> $dist;
}

<span style="color:#66d9ef">for</span> <span style="color:#66d9ef">my</span> $word_pair_ref ([<span style="color:#e6db74">&#34;cold&#34;</span>, <span style="color:#e6db74">&#34;cord&#34;</span>], [<span style="color:#e6db74">&#34;cord&#34;</span>, <span style="color:#e6db74">&#34;core&#34;</span>], [<span style="color:#e6db74">&#34;cord&#34;</span>, <span style="color:#e6db74">&#34;cord&#34;</span>],
                       [<span style="color:#e6db74">&#34;cold&#34;</span>, <span style="color:#e6db74">&#34;warm&#34;</span>], [<span style="color:#e6db74">&#34;kitten&#34;</span>, <span style="color:#e6db74">&#34;sittin&#34;</span>], [<span style="color:#e6db74">&#34;kitten&#34;</span>, <span style="color:#e6db74">&#34;sitting&#34;</span>]) {
    <span style="color:#66d9ef">my</span> ($w1, $w2) <span style="color:#f92672">=</span> @$word_pair_ref;
    say <span style="color:#e6db74">&#34;Distance between $w1 and $w2 is: \t&#34;</span>, edit_distance ($w1, $w2);
}
</code></pre></div><p>This script displays the expected output:</p>
<pre><code>Distance between cold and cord is:      1
Distance between cord and core is:      1
Distance between cord and cord is:      0
Distance between cold and warm is:      4
Distance between kitten and sittin is:  2
Words kitten and sitting have different lengths
</code></pre>
<p>So, we have a working <strong>sub edit_distance()</strong>, a ladder subroutine might look in part like this:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-perl" data-lang="perl"><span style="color:#66d9ef">sub</span> <span style="color:#a6e22e">ladder</span> {
    <span style="color:#66d9ef">my</span> $word1, $word2) <span style="color:#f92672">=</span> @_;
    <span style="color:#66d9ef">return</span> ($word1) <span style="color:#66d9ef">if</span> edit_distance($word1, $word2) <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>;
    <span style="color:#66d9ef">return</span> ($word1, $word2) <span style="color:#66d9ef">if</span> edit_distance($word1, $word2) <span style="color:#f92672">==</span> <span style="color:#ae81ff">1</span>;
    <span style="color:#75715e"># ...</span>
}
</code></pre></div><p>The problem, of course, is to write the code that will replace the ellipsis. Eventually, the real code will not really look like that, but it could.</p>
<h3 id="finding-the-ladders-in-perl">Finding the Ladders in Perl</h3>
<p>Let&rsquo;s try an improved brute force algorithm. For this, we will first analyze our input file and prepare data structures that are likely to make brute force relatively fast.</p>
<h3 id="preparing-the-data">Preparing the Data</h3>
<p>To start with, we will use our <strong>words.txt</strong> file to create files of words having 2, 3, 4, &hellip; 9, 10 letters. This can be done with simple one-liners such as:</p>
<pre><code>$ perl -nE 'chomp; say if length == 10' words.txt &gt;  words10.txt
</code></pre>
<p>We&rsquo;re not really interested with longer words, because it will become increasingly difficult and unlikely to find complete ladders between such longer words.</p>
<p>Our <strong>9 files</strong> have the following word counts:</p>
<pre><code>113809  113809 1016714 words.txt
9199    9199   101189  words10.txt
85      85     255     words2.txt
908     908    3632    words3.txt
3686    3686   18430   words4.txt
8258    8258   49548   words5.txt
14374   14374  100618  words6.txt
21727   21727  173816  words7.txt
26447   26447  238023  words8.txt
16658   16658  166580  words9.txt
220447  220447 1932357 total
</code></pre>
<p>The next thing we want to do is to build hashes which, for each word in the input file, lists all words that are a single-letter-change away from that given word. This implies nested loops on large data collections; this can take a very long time to run, so we want to cache the result in order to avoid having to recompute it every time. That&rsquo;s what the first 40 code or so lines in the program below do. We use the Storable core module to store the generated hash in a file. Note that it would be very easy to store our %words hash of arrays in a plain text file and to retrieve it on demand (for example, one line per hash key, with the key and the list of words on eash such line), and that&rsquo;s what we&rsquo;ll do below in P6, but Storable does it well and fast for us. The basic idea is as follows: we get two words as parameters to the program; if the words have the same length, say 5, we look for a data store file named word_store_5 on the disk. If the file is there, we just retrieve the data and load the hash from it (which takes a split second); if not, we generate the hash and store it. This way, these long computations can be done only once for each word length.</p>
<p>The <strong>%words</strong> hash of arrays is in effect a graph of the single-letter-edit connections between words.</p>
<p>Some words are what I call <em><strong>orphans</strong></em> in the code, i.e. these are not connected to any other word through a single character edit. When legendary computer scientist <strong>Donald Knuth</strong> studied the problem several decades ago, he found that the word <em><strong>aloof</strong></em> was one such word. So he named <em><strong>aloof</strong></em> all of these words not connected to any other. In the code below, these words are stored in <em><strong>aloof</strong></em> files, despite the fact that my word list has in fact the word <em><strong>kloof</strong></em> (whatever it means) which is one character edit away from <em><strong>aloof</strong></em>. We remove these words from our hash, since they cannot participate in any path between two words.</p>
<p>The table below summarizes word counts and run times for this part of the process.</p>
<pre><code>| File        | Words   | Run time   | Aloof words |
| ----------- | ------- | ---------- | ----------- |
| words2.txt  |  85     | 0m0.102s   | 0           |
| words3.txt  |  908    | 0m2.519s   | 6           |
| words4.txt  |  3686   | 0m38.162s  | 68          |
| words5.txt  |  8258   | 4m46.641s  | 711         |
| words6.txt  |  14374  | 16m29.848s | 3093        |
| words7.txt  |  21727  | 39m5.278s  | 7348        |
| words8.txt  |  26447  | 71m47.795s | 12516       |
| words9.txt  |  16658  | 28m6.781s  | 10096       |
| words10.txt |  8258   | 7m51.305s  | 6494        |
</code></pre>
<p>When words have <strong>9 characters</strong> or <strong>more</strong>, significantly more than half of them are <em><strong>aloof</strong></em> words. It probably becomes relatively difficult to find pairs of words that are connected with a ladder.</p>
<p>As you can see, this process takes quite a lot of time when there are many words in the input file (more than <strong>71 minutes</strong> for words having <strong>8 characters</strong>), it is good to store the data produced to avoid recomputing it. Note that is might be quicker not to do that and to go directly for the ladders if we were to determine a path between only two words, but I ran the program probably a couple of hundred times for the purpose of testing and finding information about our word lists, so I&rsquo;m happy that I first took the time to prepare the data for faster processing later. When the word store already exists, it takes about <strong>0.1</strong> to <strong>0.3</strong> second to reconstruct the hash from the store.</p>
<h3 id="finding-the-word-ladders">Finding the Word Ladders</h3>
<p>This is my Perl code for finding word ladders:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-perl" data-lang="perl"><span style="color:#66d9ef">use</span> strict;
<span style="color:#66d9ef">use</span> warnings;
<span style="color:#66d9ef">use</span> feature <span style="color:#e6db74">qw/say/</span>;
<span style="color:#66d9ef">use</span> Storable;
<span style="color:#66d9ef">use</span> Data::Dumper;

die <span style="color:#e6db74">&#34;Please pass two words as parameters&#34;</span> <span style="color:#66d9ef">unless</span> @ARGV <span style="color:#f92672">==</span> <span style="color:#ae81ff">2</span>;
<span style="color:#66d9ef">my</span> ($word1, $word2)<span style="color:#f92672">=</span> @ARGV;
<span style="color:#66d9ef">my</span> $length <span style="color:#f92672">=</span> length $word1;
die <span style="color:#e6db74">&#34;The two words must have the same length\n&#34;</span> <span style="color:#66d9ef">if</span> $length <span style="color:#f92672">!=</span> length $word2;

<span style="color:#66d9ef">my</span> $store_file <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;word_store_$length&#34;</span>;
<span style="color:#66d9ef">my</span> ($store_ref, %words);
<span style="color:#66d9ef">if</span> (<span style="color:#f92672">-</span>e $store_file) {
    <span style="color:#66d9ef">my</span> $store_ref <span style="color:#f92672">=</span> retrieve($store_file);
    %words <span style="color:#f92672">=</span> %$store_ref;
} <span style="color:#66d9ef">else</span> {
    <span style="color:#66d9ef">my</span> $file <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;words$length.txt&#34;</span>;
    open <span style="color:#66d9ef">my</span> $IN, <span style="color:#e6db74">&#39;&lt;&#39;</span>, $file <span style="color:#f92672">or</span> die <span style="color:#e6db74">&#34;Cannot open $file$!&#34;</span>;
    <span style="color:#66d9ef">while</span> (<span style="color:#66d9ef">my</span> $word <span style="color:#f92672">=</span> <span style="color:#e6db74">&lt;$IN&gt;</span>) {
        chomp $word;
        $words{$word} <span style="color:#f92672">=</span> <span style="color:#f92672">[]</span>;
        <span style="color:#66d9ef">for</span> <span style="color:#66d9ef">my</span> $key (keys %words) {
            <span style="color:#66d9ef">if</span> (edit_distance($key, $word) <span style="color:#f92672">==</span> <span style="color:#ae81ff">1</span>) {
                push @{$words{$key}}, $word;
                push @{$words{$word}}, $key;
            }
        }
    }
    close $IN;
    <span style="color:#66d9ef">my</span> $orphans <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;aloof_$length.txt&#34;</span>;
    open <span style="color:#66d9ef">my</span> $OUT, <span style="color:#e6db74">&#34;&gt;&#34;</span>, $orphans <span style="color:#f92672">or</span> die <span style="color:#e6db74">&#34;Cannot open file $orphans$!&#34;</span>;
    <span style="color:#66d9ef">for</span> <span style="color:#66d9ef">my</span> $key (keys %words){
        <span style="color:#66d9ef">if</span> (scalar @{$words{$key}} <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>) {
            say $OUT <span style="color:#e6db74">&#34;$key&#34;</span>;
            delete $words{$key};
        }
    }
    close $OUT;
    store <span style="color:#f92672">\</span>%words, $store_file;
}

<span style="color:#66d9ef">my</span> $max <span style="color:#f92672">=</span> $le   ngth <span style="color:#f92672">*</span> <span style="color:#ae81ff">2</span>;

<span style="color:#66d9ef">sub</span> <span style="color:#a6e22e">edit_distance</span> {
    <span style="color:#66d9ef">my</span> ($word1, $word2) <span style="color:#f92672">=</span> @_;
    <span style="color:#75715e"># die &#34;Words $word1 and $word2 ...&#34; -&gt; No longer needed as this is checked before</span>
    <span style="color:#66d9ef">my</span> @w1 <span style="color:#f92672">=</span> split <span style="color:#e6db74">//</span>, $word1;
    <span style="color:#66d9ef">my</span> @w2 <span style="color:#f92672">=</span> split <span style="color:#e6db74">//</span>, $word2;
    <span style="color:#66d9ef">my</span> $dist <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
    <span style="color:#66d9ef">for</span> <span style="color:#66d9ef">my</span> $i (<span style="color:#ae81ff">0</span><span style="color:#f92672">..</span>$#w1) {
        $dist<span style="color:#f92672">++</span> <span style="color:#66d9ef">if</span> $w1[$i] <span style="color:#f92672">ne</span> $w2[$i];
    }
    <span style="color:#66d9ef">return</span> $dist;
}

<span style="color:#66d9ef">sub</span> <span style="color:#a6e22e">ladder</span> {
    <span style="color:#66d9ef">my</span> ($word1, $word2, $tmp_result) <span style="color:#f92672">=</span> @_;
    <span style="color:#66d9ef">return</span> $tmp_result <span style="color:#66d9ef">if</span> $word1 <span style="color:#f92672">eq</span> $word2;
    <span style="color:#66d9ef">return</span> <span style="color:#f92672">[]</span> <span style="color:#66d9ef">if</span> scalar @$tmp_result <span style="color:#f92672">&gt;=</span> $max;
    <span style="color:#66d9ef">my</span> @temp_solutions;
    <span style="color:#66d9ef">for</span> <span style="color:#66d9ef">my</span> $word (@{$words{$word1}}) {
        <span style="color:#66d9ef">next</span> <span style="color:#66d9ef">if</span> $word <span style="color:#f92672">eq</span> $word1;
        <span style="color:#66d9ef">next</span> <span style="color:#66d9ef">if</span> grep { $_ <span style="color:#f92672">eq</span> $word } @$tmp_result; <span style="color:#75715e"># not really needed but a bit faster</span>
        push @temp_solutions, [@$tmp_result, $word] <span style="color:#f92672">and</span> <span style="color:#66d9ef">last</span> <span style="color:#66d9ef">if</span> $word <span style="color:#f92672">eq</span> $word2;
        <span style="color:#66d9ef">my</span> $new_tmp <span style="color:#f92672">=</span> ladder($word, $word2, [@$tmp_result, $word]);
        <span style="color:#66d9ef">next</span> <span style="color:#66d9ef">if</span> scalar @$new_tmp <span style="color:#f92672">==</span> scalar @$tmp_result;
        <span style="color:#66d9ef">next</span> <span style="color:#66d9ef">unless</span> scalar @$new_tmp;
        push @temp_solutions, $new_tmp;
    }
    <span style="color:#66d9ef">return</span> <span style="color:#f92672">[]</span> <span style="color:#66d9ef">unless</span> @temp_solutions;
    <span style="color:#66d9ef">my</span> $best_sol <span style="color:#f92672">=</span> (sort { scalar @$a <span style="color:#e6db74">&lt;=&gt;</span> scalar @$b } @temp_solutions)[<span style="color:#ae81ff">0</span>];
    $max <span style="color:#f92672">=</span> scalar @$best_sol <span style="color:#66d9ef">if</span> scalar @$best_sol <span style="color:#f92672">&lt;</span> $max;
    <span style="color:#66d9ef">return</span> $best_sol;
}

<span style="color:#66d9ef">for</span> ($word1, $word2) {
    die <span style="color:#e6db74">&#34;Word $_ not found\n&#34;</span> <span style="color:#66d9ef">unless</span> exists $words{$_};
}
<span style="color:#66d9ef">my</span> $ladder <span style="color:#f92672">=</span> ladder $word1, $word2, [$word1];

<span style="color:#66d9ef">if</span> (@$ladder) {
    say join <span style="color:#e6db74">&#34;-&gt;&#34;</span>, @$ladder;
} <span style="color:#66d9ef">else</span> {
    say <span style="color:#e6db74">&#34;No ladder found for $word1 and $word2&#34;</span>
}
</code></pre></div><p>The bulk of the work is done in the <strong>sub ladder()</strong>, which calls itself recursively for all words connected to the <em><strong>$word1</strong></em> input word. The <em><strong>$max</strong></em> variable, which controls how deep we go into the recursive research, may not be needed for the correctness of the algorithm (provided we find another way to stop recursion), but it enables the program to run tens to hundreds of times faster, depending on the input words.</p>
<p>This is an example run:</p>
<pre><code>$ time perl ladder2.pl warm cold
warm-&gt;ward-&gt;card-&gt;cord-&gt;cold

real    0m2.959s
user    0m2.859s
sys     0m0.077s
</code></pre>
<p>Printing out intermediate results shows that there are other shortest ladders between these two words, for example:</p>
<pre><code>warm worm word wold cold
warm worm word cord cold
warm worm corm cord cold
warm ward card cord cold
</code></pre>
<p>There is one caveat: it should be noted that I have initialized the <strong>$max</strong> variable to twice the length of the input words. In a way, this is a bug because there are certainly some (probably very rare) pairs of <strong>four-letters</strong> words for which the shortest ladder contains more than <strong>8 words</strong>, but I have kept it this way as a trade-off because the program runs so dramatically faster with a relatively low value for <strong>$max</strong>. If we needed to make sure that we don&rsquo;t miss any shortest ladder, we could run it the way it is now (so that it is fairly fast most of the time) and, when no ladder is found, run it again with a much larger initial value of <strong>$max</strong>. According to this site, the longest shortest ladder (with words of <strong>six letters</strong>) has <strong>50 steps</strong>.</p>
<p>As a conclusion to the Perl implementation of word ladders, I should say that, although it seems to work properly (subject to the caveat just above), I&rsquo;m not really fully satisfied with this solution: I think it should be possible to make something simpler (and perhaps faster), but I don&rsquo;t have the time at the moment to investigate further.</p>
<h3 id="word-ladders-in-raku">Word Ladders in Raku</h3>
<p>Let&rsquo;s try to adapt the <strong>Perl</strong> script to <strong>Raku</strong>.</p>
<h3 id="serializing-the-word-hash-of-arrays">Serializing the Word Hash of Arrays</h3>
<p>There doesn&rsquo;t seem to be a Storable module in <strong>Raku</strong>, but I did not worry about that, since I thought that the gist routine would provide a serialized image of the <em><strong>%words</strong></em> hash which could then be EVALed to retrieve the hash. This seems to work fine with a small hash. But that does not work with our big <em><strong>%words</strong></em> hash of arrays, because it turns out that, apparently, gist truncates its output to a few thousands characters.</p>
<p>It would probably be possible to serialize the <em><strong>%words</strong></em> hash with some <strong>JSON</strong> or <strong>YAML</strong> module, but there doesn&rsquo;t seem to be any core module for that.</p>
<p>As noted in the <strong>Perl</strong> section of this task, there is nothing complicated in writing our own plain text serializer for a simple hash of arrays. For example, we can write a plain text file with one line for each hash item, with the key at the beginning of the line and then a list of the values. Let&rsquo;s do it in a little toy module, which could look like something like this:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-perl6" data-lang="perl6">unit <span style="color:#66d9ef">package</span> Store;

<span style="color:#66d9ef">sub</span> <span style="color:#a6e22e">store</span> (%hash, $file) is export {
    <span style="color:#75715e"># stores a hash or array as lines containing key et values</span>
    <span style="color:#75715e"># such as: key | val1 val2 val3</span>
    <span style="color:#66d9ef">my</span> $out;
    <span style="color:#66d9ef">for</span> %hash<span style="color:#f92672">.</span>kv <span style="color:#f92672">-&gt;</span> $key, $val {
        $out <span style="color:#f92672">~=</span> <span style="color:#e6db74">&#34;$key | $val \n&#34;</span>;
    }
    spurt $file, $out;
}

<span style="color:#66d9ef">sub</span> <span style="color:#a6e22e">retrieve</span> (%hash, $file) is export {
    <span style="color:#75715e"># populates a hash of arrays with stored data</span>
    <span style="color:#66d9ef">for</span> $file<span style="color:#f92672">.</span>IO<span style="color:#f92672">.</span>lines <span style="color:#f92672">-&gt;</span> $line {
        <span style="color:#66d9ef">my</span> ($key, $val) <span style="color:#f92672">=</span> split <span style="color:#e6db74">/\s?\|\s?/</span>, $line;
        %hash{$key} <span style="color:#f92672">=</span> $val<span style="color:#f92672">.</span>words;
    }
}
</code></pre></div><p>As an example, the first few lines of the <a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-007/laurent-rosenfeld/perl6/word_store_4"><strong>word_store_4</strong></a> file look like this:</p>
<pre><code>yawl | bawl pawl wawl yawn yawp yaws yowl
pled | fled bled pied plea peed gled pleb plod sled
pita | dita pima pica pika pina pith pits pity vita
keir | heir weir
quag | quad quai quay
frug | frig frog frag drug
</code></pre>
<h3 id="the-ladder-script-in-raku">The Ladder Script in Raku</h3>
<p>Now that we have solved the problem of storing and retrieving the hash of arrays, adapting the <strong>Perl</strong> script into <strong>Raku</strong> is fairly easy:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-perl6" data-lang="perl6"><span style="color:#66d9ef">use</span> v6;
<span style="color:#66d9ef">use</span> Store;

die <span style="color:#e6db74">&#34;Please pass two words as parameters&#34;</span> <span style="color:#66d9ef">unless</span> @<span style="color:#960050;background-color:#1e0010">*</span>ARGS <span style="color:#f92672">==</span> <span style="color:#ae81ff">2</span>;
<span style="color:#66d9ef">my</span> ($word1, $word2)<span style="color:#f92672">=</span> @<span style="color:#960050;background-color:#1e0010">*</span>ARGS;
<span style="color:#66d9ef">my</span> $length <span style="color:#f92672">=</span> $word1<span style="color:#f92672">.</span>chars;
die <span style="color:#e6db74">&#34;The two words must have the same length\n&#34;</span> <span style="color:#66d9ef">if</span> $length <span style="color:#f92672">!=</span> $word2<span style="color:#f92672">.</span>chars;

<span style="color:#66d9ef">my</span> $max <span style="color:#f92672">=</span> <span style="color:#ae81ff">2</span> <span style="color:#f92672">*</span> $length;
<span style="color:#66d9ef">my</span> $store<span style="color:#f92672">-</span>file <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;word_store_$length&#34;</span>;
<span style="color:#66d9ef">my</span> ($stored, %words);
<span style="color:#66d9ef">if</span> ($store<span style="color:#f92672">-</span>file<span style="color:#f92672">.</span>IO<span style="color:#f92672">.</span>e) {
    retrieve %words, $store<span style="color:#f92672">-</span>file;
} <span style="color:#66d9ef">else</span> {
    <span style="color:#66d9ef">for</span> <span style="color:#e6db74">&#34;words$length.txt&#34;</span><span style="color:#f92672">.</span>IO<span style="color:#f92672">.</span>lines <span style="color:#f92672">-&gt;</span> $word {
        %words{$word} <span style="color:#f92672">=</span> <span style="color:#f92672">[]</span>;
        <span style="color:#66d9ef">for</span> keys %words <span style="color:#f92672">-&gt;</span> $key {
            <span style="color:#66d9ef">if</span> (edit<span style="color:#f92672">-</span>distance($key, $word) <span style="color:#f92672">==</span> <span style="color:#ae81ff">1</span>) {
                push @<span style="color:#960050;background-color:#1e0010">(%</span>words{$key}), $word;
                push @<span style="color:#960050;background-color:#1e0010">(%</span>words{$word}), $key;
            }
        }
    }
    %words <span style="color:#f92672">=</span> grep { $_<span style="color:#f92672">.</span>value<span style="color:#f92672">.</span>elems <span style="color:#f92672">&gt;</span> <span style="color:#ae81ff">0</span> }, %words<span style="color:#f92672">.</span>pairs;
    store %words, $store<span style="color:#f92672">-</span>file;
}

<span style="color:#66d9ef">sub</span> <span style="color:#a6e22e">edit</span>-distance (Str $word1, Str $word2) {
    <span style="color:#66d9ef">my</span> @w1 <span style="color:#f92672">=</span> $word1<span style="color:#f92672">.</span>comb;
    <span style="color:#66d9ef">my</span> @w2 <span style="color:#f92672">=</span> $word2<span style="color:#f92672">.</span>comb;
    <span style="color:#66d9ef">my</span> $dist <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
    $dist<span style="color:#f92672">++</span> <span style="color:#66d9ef">if</span> @w1[$_] <span style="color:#f92672">ne</span> @w2[$_] <span style="color:#66d9ef">for</span> (<span style="color:#ae81ff">0</span><span style="color:#f92672">..</span>@w1<span style="color:#f92672">.</span>end) ;
    <span style="color:#66d9ef">return</span> $dist;
}

<span style="color:#66d9ef">sub</span> <span style="color:#a6e22e">ladder</span> (Str $word1, Str $word2, $tmp-result) {
    <span style="color:#66d9ef">return</span> $tmp<span style="color:#f92672">-</span>result <span style="color:#66d9ef">if</span> ($word1 <span style="color:#f92672">eq</span> $word2);
    <span style="color:#66d9ef">return</span> <span style="color:#f92672">[]</span> <span style="color:#66d9ef">if</span> @$tmp<span style="color:#f92672">-</span>result<span style="color:#f92672">.</span>elems <span style="color:#f92672">&gt;=</span> $max;
    <span style="color:#66d9ef">my</span> @temp<span style="color:#f92672">-</span>solutions;
    <span style="color:#66d9ef">for</span> @<span style="color:#960050;background-color:#1e0010">(%</span>words{$word1}) <span style="color:#f92672">-&gt;</span> $word {
        <span style="color:#66d9ef">next</span> <span style="color:#66d9ef">if</span> $word <span style="color:#f92672">eq</span> $word1;
        <span style="color:#66d9ef">next</span> <span style="color:#66d9ef">if</span> grep { $_ <span style="color:#f92672">eq</span> $word }, @$tmp<span style="color:#f92672">-</span>result;
        push @temp<span style="color:#f92672">-</span>solutions, [<span style="color:#f92672">|</span>@$tmp<span style="color:#f92672">-</span>result, $word] <span style="color:#f92672">and</span> <span style="color:#66d9ef">last</span> <span style="color:#66d9ef">if</span> $word <span style="color:#f92672">eq</span> $word2;
        <span style="color:#66d9ef">my</span> $new_tmp <span style="color:#f92672">=</span> ladder($word, $word2, [<span style="color:#f92672">|</span>@$tmp<span style="color:#f92672">-</span>result, $word]);
        <span style="color:#66d9ef">next</span> <span style="color:#66d9ef">if</span> @$new_tmp<span style="color:#f92672">.</span>elems <span style="color:#f92672">==</span> @$tmp<span style="color:#f92672">-</span>result<span style="color:#f92672">.</span>elems;
        <span style="color:#66d9ef">next</span> <span style="color:#66d9ef">unless</span> @$new_tmp<span style="color:#f92672">.</span>elems;
        push @temp<span style="color:#f92672">-</span>solutions, $new_tmp;
    }
    <span style="color:#66d9ef">return</span> <span style="color:#f92672">[]</span> <span style="color:#66d9ef">if</span> @temp<span style="color:#f92672">-</span>solutions<span style="color:#f92672">.</span>elems <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>;
    <span style="color:#66d9ef">my</span> $best_sol <span style="color:#f92672">=</span> (sort { $_<span style="color:#f92672">.</span>elems }, @temp<span style="color:#f92672">-</span>solutions)[<span style="color:#ae81ff">0</span>];
    $max <span style="color:#f92672">=</span> @$best_sol<span style="color:#f92672">.</span>elems <span style="color:#66d9ef">if</span> @$best_sol<span style="color:#f92672">.</span>elems <span style="color:#f92672">&lt;</span> $max;
    <span style="color:#66d9ef">return</span> $best_sol;
}

<span style="color:#66d9ef">for</span> ($word1, $word2) {
    die <span style="color:#e6db74">&#34;Word $_ not found\n&#34;</span> <span style="color:#66d9ef">unless</span>  %words{$_} :exists;
}
<span style="color:#66d9ef">my</span> $ladder <span style="color:#f92672">=</span> ladder $word1, $word2, [$word1];

<span style="color:#66d9ef">if</span> (@$ladder) {
    say join <span style="color:#e6db74">&#34;-&gt;&#34;</span>, @$ladder;
} <span style="color:#66d9ef">else</span> {
    say <span style="color:#e6db74">&#34;No ladder found for $word1 and $word2&#34;</span>
}
</code></pre></div><p>Running the script with the words <strong>&ldquo;warm&rdquo;</strong> and <strong>&ldquo;cold&rdquo;</strong> produces the following output:</p>
<pre><code>$ perl6  ladder.p6 warm cold
warm-&gt;worm-&gt;word-&gt;cord-&gt;cold

$ perl6  ladder.p6 cold warm
cold-&gt;wold-&gt;word-&gt;worm-&gt;warm
</code></pre>
<hr>
<hr>
<p>If you have any suggestion then please do share with us <a href="mailto:perlweeklychallenge@yahoo.com">perlweeklychallenge@yahoo.com</a>.</p>
<p><a href="/blog/advent-calendar-2019"><strong>Advent Calendar 2019</strong></a></p>

                </div>
            </div>
        </div>
    </div>
</section>


<!-- Call To Action Section Start -->
<section id="call-to-action">
    <div class="container">
        <div class="row">
            <div class="col-md-12">
                <div class="block">
                    <h2 class="title wow fadeInDown" data-wow-delay=".3s" data-wow-duration="500ms">SO WHAT DO YOU THINK ?</h2>
                    <p class="wow fadeInDown" data-wow-delay=".5s" data-wow-duration="500ms">If you have any suggestions or ideas then please do share with us.</p>
                    <a href="/contact" class="btn btn-default btn-contact wow fadeInDown" data-wow-delay=".7s" data-wow-duration="500ms">Contact with me</a>
                </div>
            </div>

        </div>
    </div>
</section>
<!-- Call To Action Section End -->



<!-- Footer Section Start -->
<footer id="footer">
    <div class="container">
        <div class="row content-justify-between">
            <div class="col-md-8 col-12 text-center text-lg-left text-md-left">
                <p class="copyright">Copyright:
                    <span>
                        <script>document.write(new Date().getFullYear())</script>
                    </span> PerlWeeklyChallenge. Theme Design and Developed by
                    <a href="http://www.Themefisher.com" target="_blank">Themefisher</a>.
                </p>
            </div>
            <div class="col-md-4 col-12">
                <!-- Social Media -->
                <ul class="social text-center text-md-right text-lg-right">
                    <li>
                        <a href="https://twitter.com/PerlWChallenge" class="twitter" target="_blank" title="Follow us">
                            <i class="ion-social-twitter"></i>
                        </a>
                    </li>
                    <li>
                        <a href="/rss.xml" class="rss" target="_blank" title="RSS Feed">
                            <i class="ion-social-rss"></i>
                        </a>
                    </li>
                    <li>
                        <a href="https://www.nomtimes.co.uk/site/shop.do?cref=PerlBooks" title="Free Perl Books" target="_blank">
                            <img src="/images/NomTimes.jpg" style="width:22px; height: 18px;" alt=""/>
                        </a>
                    </li>
                </ul>
            </div>
        </div>
    </div>
</footer>
<!-- footer section end -->

<!-- jquery -->
<script src="https://perlweeklychallenge.org/plugins/jQurey/jquery.min.js"></script>
<!-- Form Validation -->
<script src="https://perlweeklychallenge.org/plugins/form-validation/jquery.form.js"></script>
<script src="https://perlweeklychallenge.org/plugins/form-validation/jquery.validate.min.js"></script>
<!-- slick slider -->
<script src="https://perlweeklychallenge.org/plugins/slick/slick.min.js"></script>
<!-- bootstrap js -->
<script src="https://perlweeklychallenge.org/plugins/bootstrap/bootstrap.min.js"></script>
<!-- chart js -->
<script src="https://perlweeklychallenge.org/plugins/chart/highstock.js"></script>
<script src="https://perlweeklychallenge.org/plugins/chart/drilldown.js"></script>
<script src="https://perlweeklychallenge.org/plugins/chart/data.js"></script>
<script src="https://perlweeklychallenge.org/plugins/chart/chart.js"></script>
<!-- wow js -->
<script src="https://perlweeklychallenge.org/plugins/wow-js/wow.min.js"></script>
<!-- slider js -->
<script src="https://perlweeklychallenge.org/plugins/slider/slider.js"></script>
<!-- Fancybox -->
<script src="https://perlweeklychallenge.org/plugins/facncybox/jquery.fancybox.js"></script>
<!-- template main js -->

<script src="https://perlweeklychallenge.org/js/script.min.js"></script>
<!-- google analitycs -->
<script>
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
    (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
    m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
    ga('create', 'UA-136524905-1', 'auto');
    ga('send', 'pageview');
</script>
</body>

</html>

