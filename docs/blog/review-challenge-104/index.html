<!DOCTYPE html>
<html class="no-js" lang="en-us">
<head>
    <!-- Basic Page Needs -->

    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta property="og:title"       content="The Weekly Challenge - Perl & Raku"/>
    <meta property="og:type"        content="website"/>
    <meta property="og:url"         content="https://theweeklychallenge.org/"/>
    <meta property="og:image"       content="https://theweeklychallenge.org/images/about/about.jpg"/>
    <meta property="og:description" content="You do not have to be an expert."/>
    <meta name="twitter:card"       content="summary" />
    <meta name="twitter:image"      content="https://theweeklychallenge.org/images/about/about.jpg"/>

    <meta http-equiv="Content-Type" content="text/html; charset=utf-8">

    <meta name="description" content="Colin Crain › Perl Weekly Review #104">
    <meta name="author" content="The Weekly Challenge Team">
    <meta name="generator" content="Hugo 0.67.0-DEV" />

    <!-- Mobile Specific Metas -->
    <meta name="format-detection" content="telephone=no">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>Colin Crain › Perl Weekly Review #104</title>
    <link rel="icon" href="https://theweeklychallenge.org/images/favicon.ico">

    
    <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.0/css/bootstrap.min.css"/>

    <!-- Twitter Bootstrs CSS -->
    <link rel="stylesheet" href="https://theweeklychallenge.org/plugins/bootstrap/bootstrap.min.css">
    <!-- Ionicons Fonts Css -->
    <link rel="stylesheet" href="https://theweeklychallenge.org/plugins/ionicons/ionicons.min.css">
    <!-- animate css -->
    <link rel="stylesheet" href="https://theweeklychallenge.org/plugins/animate-css/animate.css">
    <!-- Hero area slider css-->
    <link rel="stylesheet" href="https://theweeklychallenge.org/plugins/slider/slider.css">
    <!-- slick slider -->
    <link rel="stylesheet" href="https://theweeklychallenge.org/plugins/slick/slick.css">
    <!-- Fancybox -->
    <link rel="stylesheet" href="https://theweeklychallenge.org/plugins/facncybox/jquery.fancybox.css">
    <!-- hover -->
    <link rel="stylesheet" href="https://theweeklychallenge.org/plugins/hover/hover-min.css">
    <!-- Google fonts -->
    <link href='https://fonts.googleapis.com/css?family=Source Code Pro' rel='stylesheet'>
    <!-- template main css file -->
    
    <link rel="stylesheet" href="https://theweeklychallenge.org/css/style.min.css" integrity="" media="screen">
    <link rel="stylesheet" href="https://theweeklychallenge.org/css/main.css">

    <style>
        #goTopButton {
            display: none;          
            position: fixed;        
            bottom: 20px;           
            right: 30px;            
            z-index: 99;            
            border: none;           
            outline: none;          
            background-color: red;  
            color: white;           
            cursor: pointer;        
            padding: 15px;          
            border-radius: 10px;    
            font-size: 18px;        
        }

        #goTopButton:hover {
              background-color: #555;
        }
    </style>


</head>

<body>

<button onclick="goTop()" id="goTopButton" title="Go to top">Top</button>

<script>

    topButton = document.getElementById("goTopButton");

    
    window.onscroll = function() { scrollFunction() };

    function scrollFunction() {
        if (document.body.scrollTop > 40 || document.documentElement.scrollTop > 40) {
            topButton.style.display = "block";
        } else {
            topButton.style.display = "none";
        }
    }

    
    function goTop() {
        document.body.scrollTop = 0; 
        document.documentElement.scrollTop = 0; 
    }

</script>

<section class="top-bar animated-header">
    <div class="container">
        <div class="row">
            <div class="col-lg-12">
                <nav class="navbar navbar-expand-lg navbar-light bg-light">
                    <a class="navbar-brand" href="https://theweeklychallenge.org/">
                        <img src="https://theweeklychallenge.org/images/logo.svg" alt="logo">
                    </a>
                    <button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navgation" aria-controls="navigation"
                        aria-expanded="false" aria-label="Toggle navigation">
                        <span class="navbar-toggler-icon"></span>
                    </button>

                    <div class="collapse navbar-collapse" id="navigation">
                        <ul class="navbar-nav ml-auto">
                            <li class="nav-item">
                                <a class="nav-link" href="https://theweeklychallenge.org/">Home</a>
                            </li>
                            
                            <li class="nav-item">
                                <a class="nav-link" href="https://theweeklychallenge.org/about">About</a>
                            </li>
                            
                            <li class="nav-item">
                                <a class="nav-link" href="https://theweeklychallenge.org/chart">Chart</a>
                            </li>
                            
                            <li class="nav-item">
                                <a class="nav-link" href="https://theweeklychallenge.org/champions">Champions</a>
                            </li>
                            
                            <li class="nav-item">
                                <a class="nav-link" href="https://theweeklychallenge.org/team">Team</a>
                            </li>
                            
                            <li class="nav-item">
                                <a class="nav-link" href="https://theweeklychallenge.org/challenges">Challenges</a>
                            </li>
                            
                            <li class="nav-item">
                                <a class="nav-link" href="https://theweeklychallenge.org/p5-reviews">Perl/Review</a>
                            </li>
                            
                            <li class="nav-item">
                                <a class="nav-link" href="https://theweeklychallenge.org/p6-reviews">Raku/Review</a>
                            </li>
                            
                            <li class="nav-item">
                                <a class="nav-link" href="https://theweeklychallenge.org/recaps">Recaps</a>
                            </li>
                            
                            <li class="nav-item">
                                <a class="nav-link" href="https://theweeklychallenge.org/blogs">Blogs</a>
                            </li>
                            
                            <li class="nav-item">
                                <a class="nav-link" href="https://theweeklychallenge.org/faq">FAQ</a>
                            </li>
                            
                            <li class="nav-item">
                                <a class="nav-link" href="https://theweeklychallenge.org/contact">Contact</a>
                            </li>
                            
                        </ul>
                    </div>
                </nav>
            </div>
        </div>
    </div>
</section>


<section class="global-page-header">
    <div class="container">
        <div class="row">
            <div class="col-md-12">
                <div class="block">
                    <h2>Colin Crain › Perl Weekly Review #104</h2>
                    <div class="portfolio-meta">
                        <span>Monday, Apr 5, 2021</span>|
                        <span> Tags:
                            perl
                        </span>
                    </div>
                </div>
            </div>
        </div>
    </div>
</section>

<section class="single-post">
    <div class="container">
        <div class="row">
            <div class="col-md-12">
                
                <div style="text-align: center" class="post-img">
                    <img class="img-fluid" alt="" src="https://theweeklychallenge.org/images/blog/p5-review-challenge-104.jpg">
                </div>
                
                <div style="text-align: justify" class="post-content">
                    <p>( <em>&hellip;continues from <a href="/blog/review-challenge-103/">previous week</a>.</em> )</p>
<p>Welcome to the Perl review for <strong>Week 104</strong> of the Weekly Challenge! Here we will take the time to discuss the  submissions offered by the team, factor out the common methodologies that came up in those solutions, and highlight some of the unique approaches and unusual code created.</p>
<hr>
<h3 id="why-do-we-do-these-challenges">Why do we do these challenges?</h3>
<p>I suppose any answers to that would be as wide ranging and varied as the people who choose to join the team. One thing is clear: it&rsquo;s not a competition, and there are no judges, even if there is a &ldquo;prize&rdquo; of sorts. About that &ndash; I think of it more as an honorarium periodically awarded to acknowledge the efforts we make towards this strange goal. So there&rsquo;s no determination to find the <em>fastest</em>, or the <em>shortest</em>, or even, in some abstract way, the <em>best</em> way to go about things, although I&rsquo;m certain the individuals have their own aspirations and personal drives. As Perl is such a wonderfully expressive language, this provides quite a bit of fodder to the core idea of TMTOWTDI, producing a gamut of wonderfully varied techniques and solutions.</p>
<p>Even the tasks themselves are often open to a certain amount of discretionary interpretation. What we end up with is a situation where each participant is producing something in the manner they find the most interesting or satisfying. Some team members focus on carefully crafted complete applications that thoroughly vet input data and handle every use case they can think up. Others chose to apply themselves to the logic of the underlying puzzle and making it work in the most elegant way they can. Some eschew modules they would ordinarily reach for, others embrace them, bringing to light wheels perhaps invented years ago that happen to exactly solve the problem in front of them today.</p>
<p>I&rsquo;ve been considering this question for some time and have found one binding commonality between all of us solving these challenges each week, in that however we normally live our lives, the task in front of us more than likely has nothing to do with any of that . And I think this has great value. We all do what we do, out in the real world, and hopefully we do it well. The Weekly Challenge provides a opportunity to do something germane to that life yet distinctly different; if we only do the things we already know how to do we only do the same things over and over. This is where the &ldquo;challenge&rdquo; aspect comes into play.</p>
<p>So we can consider the Weekly Challenge as providing a problem space outside of our comfort zone, as far out from comfort as we wish to take things. From those reaches we can gather and learn things and bring what we want back into our lives. Personally, I think that&rsquo;s its greatest value of all.</p>
<hr>
<p>Every week there is an enormous global collective effort made by the team, analyzing and creatively coding the submissions, and that effort deserves credit due. And that&rsquo;s why I&rsquo;m here, to try and figure out how to do that.</p>
<p>Let&rsquo;s have a look and see what we can find.</p>
<hr>
<p><strong><big>For context</big></strong>  before we begin, you may wish to revisit either of the pages for the <a href="/blog/perl-weekly-challenge-104/"><strong>original tasks</strong></a> or the summary <a href="/blog/recap-challenge-104/"><strong>recap</strong></a> of the challenge. But don&rsquo;t worry, the challenges themselves will be briefly summarized, presented below as we progress from task by task. Oh, and one more thing before we get started:</p>
<h3 id="getting-in-touch-with-us">Getting in Touch with Us</h3>
<p><a href="mailto:pwc.perfectwave@gmail.com"><img src="/images/blog/Email.svg" height="50" width="50"> Email</a> › Please email me (Colin) with any feedback, notes, clarifications or whatnot about this review.</p>
<p><a href="https://github.com/manwar/perlweeklychallenge"><img src="/images/blog/Github.svg" height="50" width="50"> GitHub</a> › Submit a pull request to us for any issues you may find with this page.</p>
<p><a href="https://twitter.com/perlwchallenge"><img src="/images/blog/Twitter.svg" height="50" width="50"> Twitter</a> › Join the discussion on Twitter!</p>
<p>I&rsquo;m always curious as to what the people think of these efforts. Everyone here at the PWC would like to hear any feedback you&rsquo;d like to give.</p>
<p><strong>So finally, without further ado&hellip;</strong></p>
<hr>
<h2 id="---nbsp--nbsp--nbsp---task-1pwc104task1-------nbsp--nbsp--nbsp------nbsp--nbsp--nbsp---task-2pwc104task2---nbsp--nbsp--nbsp----------nbsp--nbsp--nbsp---blogspwc104blogs----nbsp--nbsp--nbsp---">•             <a href="#PWC104TASK1">Task 1</a>                 •             <a href="#PWC104TASK2">Task 2</a>                 •             <a href="#PWC104BLOGS">BLOGS</a>              	•</h2>
<hr>
<h1 id="PWC104TASK1">TASK 1</h1>
<h1 id="fusc-sequence">FUSC Sequence</h1>
<p><em>Submitted by: Mohammad S Anwar</em></p>
<p>Write a script to generate first 50 members of FUSC Sequence.</p>
<p>Please refer to OEIS for more information._</p>
<p>The sequence defined as below:</p>
<pre><code>fusc(0) = 0
fusc(1) = 1
for n &gt; 1:
when n is even: fusc(n) = fusc(n / 2),
when n is odd: fusc(n) = fusc((n-1)/2) + fusc((n+1)/2)
</code></pre>
<h2 id="about-the-solutions">about the solutions</h2>
<p><a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-104/alexander-karelas/perl/ch-1.pl"><strong>Alexander Karelas</strong></a>,
<a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-104/athanasius/perl/ch-1.pl"><strong>Athanasius</strong></a>,
<a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-104/cheok-yin-fung/perl/ch-1.pl"><strong>Cheok-Yin Fung</strong></a>,
<a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-104/colin-crain/perl/ch-1.pl"><strong>Colin Crain</strong></a>,
<a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-104/cristian-heredia/perl/ch-1.pl"><strong>Cristina Heredia</strong></a>,
<a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-104/dave-jacoby/perl/ch-1.pl"><strong>Dave Jacoby</strong></a>,
<a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-104/duncan-c-white/perl/ch-1.pl"><strong>Duncan C. White</strong></a>,
<a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-104/e-choroba/perl/ch-1.pl"><strong>E. Choroba</strong></a>,
<a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-104/polettix/perl/ch-1.pl"><strong>Flavio Poletti</strong></a>,
<a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-104/jaldhar-h-vyas/perl/ch-1.pl"><strong>Jaldhar H. Vyas</strong></a>,
<a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-104/james-smith/perl/ch-1.pl"><strong>James Smith</strong></a>,
<a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-104/jo-37/perl/ch-1.pl"><strong>Jorg Sommrey</strong></a>,
<a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-104/laurent-rosenfeld/perl/ch-1.pl"><strong>Laurent Rosenfeld</strong></a>,
<a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-104/lubos-kolouch/perl/ch-1.pl"><strong>Lubos Kolouch</strong></a>,
<a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-104/perlboy1967/perl/ch-1.pl"><strong>Niels van Dijke</strong></a>,
<a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-104/paulo-custodio/perl/ch-1.pl"><strong>Paulo Custodio</strong></a>,
<a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-104/pete-houston/perl/ch-1.pl"><strong>Pete Houston</strong></a>,
<a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-104/roger-bell-west/perl/ch-1.pl"><strong>Roger Bell_West</strong></a>,
<a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-104/stuart-little/perl/ch-1.pl"><strong>Stuart Little</strong></a>,
<a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-104/ulrich-rieke/perl/ch-1.pl"><strong>Ulrich Rieke</strong></a>, and
<a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-104/wanderdoc/perl/ch-1.pl"><strong>Wanderdoc</strong></a></p>
<p>There were 22 submissions for the first task this past week.</p>
<p>The directive, as stated, is to &ldquo;generate&rdquo; the first fifty members of the FUSC sequence. This is a rather open-ended request, as it isn&rsquo;t specified how we should go about doing so, only giving a simple definition for the values and a <a href="http://oeis.org/A002487">reference to the OEIS</a>. It wasn&rsquo;t, for example, stated that we should write a discreet function to produce an arbitrary FUSC value from an index.</p>
<p>As the only requirement was to run the script and end up with a list of elements, we ended up with a vast range of approaches to the problem, of varying complexity, from trivial to mind-bogglingly mathematical. So buckle up, this is going to take some time.</p>
<h2 id="the-basic-algorithm">the BASIC ALGORITHM</h2>
<p>The given algorithm, as defined, will produce any member of the FUSC sequence. This was by far the most commonly used method to generate the values.</p>
<h3 id="in-a-recursive-function">&hellip;in a RECURSIVE FUNCTION</h3>
<p><a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-104/alexander-karelas/perl/ch-1.pl"><strong>Alexander Karelas</strong></a>,
<a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-104/colin-crain/perl/ch-1.pl"><strong>Colin Crain</strong></a>,
<a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-104/dave-jacoby/perl/ch-1.pl"><strong>Dave Jacoby</strong></a>,
<a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-104/duncan-c-white/perl/ch-1.pl"><strong>Duncan C. White</strong></a>,
<a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-104/jaldhar-h-vyas/perl/ch-1.pl"><strong>Jaldhar H. Vyas</strong></a>,
<a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-104/james-smith/perl/ch-1.pl"><strong>James Smith</strong></a>,
<a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-104/perlboy1967/perl/ch-1.pl"><strong>Niels van Dijke</strong></a>,
<a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-104/paulo-custodio/perl/ch-1.pl"><strong>Paulo Custodio</strong></a>, and
<a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-104/roger-bell-west/perl/ch-1.pl"><strong>Roger Bell_West</strong></a></p>
<p>As the definition is <a href="https://perlweeklychallenge.org/blog/review-challenge-104/">self-referential</a>, it follows that a recursive function would fall right out, and it does, quite nicely.</p>
<p><a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-104/jaldhar-h-vyas/perl/ch-1.pl"><strong>Jaldhar H. Vyas</strong></a></p>
<p>Jaldhar demonstrates a straightforward implementation:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-perl" data-lang="perl">    <span style="color:#66d9ef">sub</span> <span style="color:#a6e22e">fusc</span> {
        <span style="color:#66d9ef">my</span> ($n) <span style="color:#f92672">=</span> @_;

        <span style="color:#66d9ef">if</span> ($n <span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">2</span>) {
            <span style="color:#66d9ef">return</span> $n;
        }

        <span style="color:#66d9ef">if</span> ($n % 2 <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>) {
            <span style="color:#66d9ef">return</span> fusc($n <span style="color:#f92672">/</span> <span style="color:#ae81ff">2</span>);
        } <span style="color:#66d9ef">else</span> {
            <span style="color:#66d9ef">return</span> fusc(($n <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>) <span style="color:#e6db74">/ 2) + fusc(($n + 1) /</span> <span style="color:#ae81ff">2</span>);
        }
    }

    <span style="color:#66d9ef">for</span> <span style="color:#66d9ef">my</span> $n (<span style="color:#ae81ff">0</span> <span style="color:#f92672">..</span> <span style="color:#ae81ff">49</span>) {
        <span style="color:#66d9ef">print</span> fusc($n), <span style="color:#e6db74">&#39; &#39;</span>;
    }
</code></pre></div><p><a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-104/alexander-karelas/perl/ch-1.pl"><strong>Alexander Karelas</strong></a></p>
<p>Here is another, very similar version from Karelas. As you can see the code follows directly from the definition.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-perl" data-lang="perl">    <span style="color:#66d9ef">sub</span> <span style="color:#a6e22e">fusc</span> ($n) {
        <span style="color:#66d9ef">return</span> $n <span style="color:#66d9ef">if</span> $n <span style="color:#f92672">&lt;=</span> <span style="color:#ae81ff">1</span>;
        <span style="color:#66d9ef">if</span> ($n % 2 <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>) {
            <span style="color:#66d9ef">return</span> fusc($n <span style="color:#f92672">/</span> <span style="color:#ae81ff">2</span>);
        } <span style="color:#66d9ef">else</span> {
            <span style="color:#66d9ef">return</span> fusc(($n <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>) <span style="color:#e6db74">/ 2) + fusc(($n + 1) /</span> <span style="color:#ae81ff">2</span>);
        }
    }

    <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">my</span> $i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; $i <span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">50</span>; $i<span style="color:#f92672">++</span>) {
        say $i, <span style="color:#e6db74">&#34;: &#34;</span>, fusc($i);
    }
</code></pre></div><p><a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-104/dave-jacoby/perl/ch-1.pl"><strong>Dave Jacoby</strong></a></p>
<p>As Dave is so wont to say,</p>
<blockquote>
<p>&quot;This looks like a job for RECURSION!&rdquo;</p>
</blockquote>
<p>With that lead in it would be a shame to leave out his example:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-perl" data-lang="perl">    say join <span style="color:#e6db74">&#39;, &#39;</span>, map { fusc($_) } <span style="color:#ae81ff">0</span> <span style="color:#f92672">..</span> <span style="color:#ae81ff">60</span>;

    <span style="color:#66d9ef">sub</span> <span style="color:#a6e22e">fusc</span> ( $n ) {

        <span style="color:#75715e"># fusc(0) = 0</span>
        <span style="color:#75715e"># fusc(1) = 1</span>
        <span style="color:#66d9ef">return</span> $n <span style="color:#66d9ef">if</span> $n <span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">2</span>;

        <span style="color:#75715e"># when n is even: fusc(n) = fusc(n / 2),</span>
        <span style="color:#66d9ef">return</span> fusc( int $n <span style="color:#f92672">/</span> <span style="color:#ae81ff">2</span> ) <span style="color:#66d9ef">if</span> $n % 2 <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>;

        <span style="color:#75715e"># when n is odd: fusc(n) = fusc((n-1)/2) + fusc((n+1)/2)</span>
        <span style="color:#66d9ef">return</span> fusc( int( $n <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span> ) <span style="color:#e6db74">/ 2 ) + fusc( ( $n + 1 ) /</span> <span style="color:#ae81ff">2</span> );
    }
</code></pre></div><h3 id="making-a-list-from-a-loop">&hellip;making a LIST from a LOOP</h3>
<p><a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-104/cheok-yin-fung/perl/ch-1.pl"><strong>Cheok-Yin Fung</strong></a>,
<a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-104/cristian-heredia/perl/ch-1.pl"><strong>Cristina Heredia</strong></a>,
<a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-104/laurent-rosenfeld/perl/ch-1.pl"><strong>Laurent Rosenfeld</strong></a>,
<a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-104/lubos-kolouch/perl/ch-1.pl"><strong>Lubos Kolouch</strong></a>, and
<a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-104/stuart-little/perl/ch-1.pl"><strong>Stuart Little</strong></a></p>
<p>The recursive function is straightforward, but making an explicit, separate function to randomly access our value isn&rsquo;t strictly required. As the method calculates from previous values, building up a list in a loop is extremely quick, and happens to be exactly what we are being asked for.</p>
<p><a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-104/cheok-yin-fung/perl/ch-1.pl"><strong>Cheok-Yin Fung</strong></a></p>
<p>CY displays the elegant simplicity of this approach, reducing the logic to an extremely compact form by using a ternary operator to decide the direction each value.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-perl" data-lang="perl">    <span style="color:#66d9ef">for</span> <span style="color:#66d9ef">my</span> $i (<span style="color:#ae81ff">2</span><span style="color:#f92672">..</span><span style="color:#ae81ff">50</span>) {
        $a[$i] <span style="color:#f92672">=</span> $i % 2 <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span> ? $a[$i<span style="color:#e6db74">/2] : $a[($i-1)/</span><span style="color:#ae81ff">2</span>]<span style="color:#f92672">+</span>$a[($i<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>)<span style="color:#f92672">/</span><span style="color:#ae81ff">2</span>];
    }
</code></pre></div><p><a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-104/cristian-heredia/perl/ch-1.pl"><strong>Cristina Heredia</strong></a></p>
<p>Christina stores her list in a hash, but otherwise operates in much the same manner.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-perl" data-lang="perl">    <span style="color:#66d9ef">sub</span> <span style="color:#a6e22e">sequenceFusc</span> {
        <span style="color:#66d9ef">while</span> ($n <span style="color:#f92672">&lt;=</span> $max) {
           <span style="color:#75715e">#if is even:</span>
           <span style="color:#66d9ef">if</span> ($n % 2 <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>) {
               $fusc{$n} <span style="color:#f92672">=</span> $fusc{$n<span style="color:#f92672">/</span><span style="color:#ae81ff">2</span>};
           }
           <span style="color:#66d9ef">else</span> {
               $fusc{$n} <span style="color:#f92672">=</span> $fusc{($n<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>)<span style="color:#e6db74">/2} + $fusc{($n+1)/</span><span style="color:#ae81ff">2</span>};
           }
           $n<span style="color:#f92672">++</span>;
        }
    }
</code></pre></div><p><a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-104/lubos-kolouch/perl/ch-1.pl"><strong>Lubos Kolouch</strong></a></p>
<p>Lubos also chose a hash structure to park his previous values&hellip;</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-perl" data-lang="perl">    <span style="color:#66d9ef">sub</span> <span style="color:#a6e22e">get_fusc</span> {
        <span style="color:#66d9ef">my</span> $what <span style="color:#f92672">=</span> shift;

        <span style="color:#66d9ef">my</span> %fusc <span style="color:#f92672">=</span> ( <span style="color:#ae81ff">0</span> <span style="color:#f92672">=&gt;</span> <span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">1</span> <span style="color:#f92672">=&gt;</span> <span style="color:#ae81ff">1</span> );

        <span style="color:#66d9ef">for</span> <span style="color:#66d9ef">my</span> $i (<span style="color:#ae81ff">2</span><span style="color:#f92672">..</span>$what <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>) {
            <span style="color:#66d9ef">if</span> ($i % 2 <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>) {
                $fusc{$i} <span style="color:#f92672">=</span> $fusc{$i <span style="color:#f92672">/</span> <span style="color:#ae81ff">2</span>}
            } <span style="color:#66d9ef">else</span> {
                $fusc{$i} <span style="color:#f92672">=</span> $fusc{($i<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>)<span style="color:#e6db74">/2} + $fusc{($i+1)/</span><span style="color:#ae81ff">2</span>}
            }
        }

        <span style="color:#66d9ef">return</span> [@fusc{<span style="color:#ae81ff">0</span> <span style="color:#f92672">..</span> $what<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>}];
    }
</code></pre></div><p><a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-104/laurent-rosenfeld/perl/ch-1.pl"><strong>Laurent Rosenfeld</strong></a></p>
<p>&hellip; and Laurent also uses a ternary operation to alternate between cases&hellip;</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-perl" data-lang="perl">    <span style="color:#66d9ef">my</span> @fusc <span style="color:#f92672">=</span> (<span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">1</span>);
    <span style="color:#66d9ef">for</span> <span style="color:#66d9ef">my</span> $i (<span style="color:#ae81ff">2</span><span style="color:#f92672">..</span><span style="color:#ae81ff">49</span>) {
        $fusc[$i] <span style="color:#f92672">=</span> $i % 2 <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span> ? $fusc[$i<span style="color:#f92672">/</span><span style="color:#ae81ff">2</span>] :
            $fusc[($i<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>)<span style="color:#e6db74">/2] + $fusc[($i+1)/</span><span style="color:#ae81ff">2</span>];
    }
</code></pre></div><p><a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-104/stuart-little/perl/ch-1.pl"><strong>Stuart Little</strong></a></p>
<p>&hellip;as does Stuart:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-perl" data-lang="perl">    <span style="color:#66d9ef">sub</span> <span style="color:#a6e22e">fusc</span>($n) {
        <span style="color:#66d9ef">my</span> @a<span style="color:#f92672">=</span>(<span style="color:#ae81ff">0</span>,<span style="color:#ae81ff">1</span>);
        <span style="color:#66d9ef">for</span> (<span style="color:#ae81ff">2</span><span style="color:#f92672">..</span>$n<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>) {
            <span style="color:#66d9ef">my</span> $new <span style="color:#f92672">=</span> ($_ % 2 <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>) ? ($a[$_<span style="color:#e6db74">/2]) : ($a[($_-1)/</span><span style="color:#ae81ff">2</span>] <span style="color:#f92672">+</span> $a[($_<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>)<span style="color:#f92672">/</span><span style="color:#ae81ff">2</span>]);
            push @a, ($new,);
        }
        <span style="color:#66d9ef">return</span> <span style="color:#f92672">\</span>@a;
    }
</code></pre></div><h3 id="a-slight-mathematical-reworking">a slight MATHEMATICAL REWORKING</h3>
<p><a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-104/duncan-c-white/perl/ch-1.pl"><strong>Duncan C. White</strong></a>,
<a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-104/roger-bell-west/perl/ch-1.pl"><strong>Roger Bell_West</strong></a>, and
<a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-104/ulrich-rieke/perl/ch-1.pl"><strong>Ulrich Rieke</strong></a></p>
<p>Several submissions noticed that if we apply a little algebra to our definition, it can be reworked into a arguably simpler form. In the second part of the definition, where the index is odd, the value is stated to be</p>
<pre><code>    fusc(n) = fusc((n-1)/2) + fusc((n+1)/2)

</code></pre><p>As the given index is known to be odd, one half the index will be a fractional value ending in one-half. The above equation can then be said to resolve to one-half the value <em>n</em> minus the fraction, rounded down, and one-half the value rounded <em>up</em>. Or alternately  first subtracting one from the value, making it even, then using one-half <em>n</em> and one-half <em>n</em> plus 1.</p>
<pre><code>    fusc(n) = fusc((n-1)/2) + fusc((n+1)/2)

    --&gt;       fusc( floor n/2 ) + fusc( floor n/2 + 1 )

</code></pre><p>We can then isolate out the floored half and the function becomes</p>
<pre><code>    half    = floor n/2
    fusc(n) = fusc( half ) + fusc( half + 1)

</code></pre><p><a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-104/ulrich-rieke/perl/ch-1.pl"><strong>Ulrich Rieke</strong></a></p>
<p>Ulrich uses this approach, as you can see here. For positive numbers integer truncation produces the floor.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-perl" data-lang="perl">    push (@fusc , <span style="color:#ae81ff">0</span> , <span style="color:#ae81ff">1</span> ) ;
    <span style="color:#66d9ef">for</span> <span style="color:#66d9ef">my</span> $n (<span style="color:#ae81ff">2</span> <span style="color:#f92672">..</span> <span style="color:#ae81ff">49</span> ) {
      <span style="color:#66d9ef">if</span> ( $n % 2 <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span> ) {
          $fusc[ $n ] <span style="color:#f92672">=</span> $fusc[ $n <span style="color:#f92672">/</span> <span style="color:#ae81ff">2</span> ] ;
      }
      <span style="color:#66d9ef">else</span> {
          <span style="color:#66d9ef">my</span> $half <span style="color:#f92672">=</span> int( $n <span style="color:#f92672">/</span> <span style="color:#ae81ff">2</span> ) ;
          $fusc[ $n ] <span style="color:#f92672">=</span> $fusc[ $half ] <span style="color:#f92672">+</span> $fusc[ $half <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span> ] ;
      }
    }
</code></pre></div><p><a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-104/duncan-c-white/perl/ch-1.pl"><strong>Duncan C. White</strong></a></p>
<p>Duncan takes the other approach, subtracting 1 from the number, causing it to become evenly divisible by 2 and making the integer truncation superfluous.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-perl" data-lang="perl">fun fusc( $n )
    {
        die <span style="color:#e6db74">&#34;fusc: $n must be +ve\n&#34;</span> <span style="color:#66d9ef">if</span> $n<span style="color:#f92672">&lt;</span><span style="color:#ae81ff">0</span>;
        <span style="color:#66d9ef">return</span> $n <span style="color:#66d9ef">if</span> $n <span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">2</span>;

        <span style="color:#75715e"># if $n is even:</span>
        <span style="color:#66d9ef">return</span> fusc( $n <span style="color:#f92672">/</span> <span style="color:#ae81ff">2</span> ) <span style="color:#66d9ef">if</span> $n % 2 <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>;

        <span style="color:#75715e"># if $n is odd:</span>
        <span style="color:#66d9ef">my</span> $halfn <span style="color:#f92672">=</span> ($n<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>)<span style="color:#f92672">/</span><span style="color:#ae81ff">2</span>;
        <span style="color:#66d9ef">return</span> fusc($halfn) <span style="color:#f92672">+</span> fusc($halfn<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>);
    }
</code></pre></div><p><a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-104/roger-bell-west/perl/ch-1.pl"><strong>Roger Bell_West</strong></a></p>
<p>Roger&rsquo;s code looks a little different, but utilizes the same transformation. No matter which method is chosen, in the end the same combinations of previous values are used to construct new elements of the sequence.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-perl" data-lang="perl">    <span style="color:#66d9ef">sub</span> <span style="color:#a6e22e">fusc</span> {
      <span style="color:#66d9ef">my</span> $n<span style="color:#f92672">=</span>shift;
      <span style="color:#66d9ef">if</span> ($n<span style="color:#f92672">==</span><span style="color:#ae81ff">0</span>) {
        <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
      } <span style="color:#66d9ef">elsif</span> ($n<span style="color:#f92672">==</span><span style="color:#ae81ff">1</span>) {
        <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">1</span>;
      } <span style="color:#66d9ef">elsif</span> ($n%2 <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>) {
        <span style="color:#66d9ef">return</span> fusc($n<span style="color:#f92672">/</span><span style="color:#ae81ff">2</span>);
      } <span style="color:#66d9ef">else</span> {
        <span style="color:#66d9ef">my</span> $h<span style="color:#f92672">=</span>($n<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>)<span style="color:#f92672">/</span><span style="color:#ae81ff">2</span>;
        <span style="color:#66d9ef">return</span> fusc($h)<span style="color:#f92672">+</span>fusc($h<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>);
      }
    }
</code></pre></div><h3 id="an-improved-version-of-looping">an IMPROVED version of LOOPING</h3>
<p><a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-104/athanasius/perl/ch-1.pl"><strong>Athanasius</strong></a> and
<a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-104/pete-houston/perl/ch-1.pl"><strong>Pete Houston</strong></a></p>
<p>As the construction of the sequence progresses in a alternating even and odd steps, it was noted that both steps could be made in each pass through a loop, doing twice the work and shortening the number of iterations.</p>
<p><a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-104/pete-houston/perl/ch-1.pl"><strong>Pete Houston</strong></a></p>
<p>Pete provides us with two versions of the solution, one using the basic algorithm in a loop, the other demonstrating this combining alternating steps into a single pass.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-perl" data-lang="perl">    <span style="color:#66d9ef">sub</span> <span style="color:#a6e22e">look_ahead</span> {
        <span style="color:#66d9ef">my</span> $max <span style="color:#f92672">=</span> shift;
        <span style="color:#66d9ef">my</span> @fusc <span style="color:#f92672">=</span> (<span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">1</span>);
        <span style="color:#66d9ef">for</span> <span style="color:#66d9ef">my</span> $n (<span style="color:#ae81ff">1</span> <span style="color:#f92672">..</span> $max <span style="color:#f92672">/</span> <span style="color:#ae81ff">2</span>) {
            push @fusc, $fusc[$n];
            push @fusc, $fusc[$n] <span style="color:#f92672">+</span> $fusc[$n <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>];
        }
        pop @fusc <span style="color:#66d9ef">unless</span> $max % 2;
        <span style="color:#66d9ef">return</span> @fusc;
    }
</code></pre></div><p><a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-104/athanasius/perl/ch-1.pl"><strong>Athanasius</strong></a></p>
<p>The monk utilizes this same technique, condensing the workflow into a very compact form:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-perl" data-lang="perl">    <span style="color:#66d9ef">for</span> <span style="color:#66d9ef">my</span> $n (<span style="color:#ae81ff">1</span> <span style="color:#f92672">..</span> <span style="color:#ae81ff">25</span>)
    {
        <span style="color:#66d9ef">my</span> $fusc_n <span style="color:#f92672">=</span> $fusc[ $n ];

        $fusc[ <span style="color:#ae81ff">2</span> <span style="color:#f92672">*</span> $n     ] <span style="color:#f92672">=</span> $fusc_n;
        $fusc[ <span style="color:#ae81ff">2</span> <span style="color:#f92672">*</span> $n <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span> ] <span style="color:#f92672">=</span> $fusc_n <span style="color:#f92672">+</span> $fusc[ $n <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span> ];
    }
</code></pre></div><h2 id="to-memoize-or-not-to-memoize">to MEMOIZE or not to MEMOIZE?</h2>
<p><a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-104/colin-crain/perl/ch-1.pl"><strong>Colin Crain</strong></a>,
<a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-104/james-smith/perl/ch-1.pl"><strong>James Smith</strong></a>,
<a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-104/perlboy1967/perl/ch-1.pl"><strong>Niels van Dijke</strong></a>,
<a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-104/paulo-custodio/perl/ch-1.pl"><strong>Paulo Custodio</strong></a>, and
<a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-104/roger-bell-west/perl/ch-1.pl"><strong>Roger Bell_West</strong></a></p>
<p>With the recursive solutions drawing on previously computed values, as the numbers get larger there will be a certain amount of redundant calculation as the fractional components get reused at, roughly, each doubling of the index. Unlike the Fibonacci sequence, where both of each values&rsquo; immediate predecessors are required to to do every computation, the FUSC sequence&rsquo;s self-referentiality is considerably sparser. No matter the actual expense incurred, though, waste is waste and both sequences benefit from memoization, or establishing a reference record of values as they are constructed should those values be required again.</p>
<p>Duncan White actually makes the argument that memoization is <em>not</em> required in this algorithm as it is very efficient as-is, and frankly he has a point — the  the complexity does not explode very quickly at all. For 50 values the expense of any repeated steps is minimal.</p>
<p>Of course whatever the rate, the complexity does grow exponentially, if not immediately, cripplingly so. Planting a counter within the code does reveal considerably more work being done as the sequence lengths get larger. For this short sequence starting from 0 the gain might be insignificant, but larger values show the speedup both obvious and accelerating.</p>
<pre><code>   0..10000  values:    3873034  vs  15000   function calls   258x speedup
   0..100000 values:  149830797  vs  150000  function calls   999x speedup
</code></pre><p><a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-104/colin-crain/perl/ch-1.pl"><strong>My Own Solution</strong></a></p>
<p>I think the whole argument of necessity is made moot by the ease of implementation. The <code>Memoize</code> module is core, and memoizing the <code>fusc()</code> function is as easy as adding two lines, to add the module and tell it which subroutines to watch.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-perl" data-lang="perl">    <span style="color:#66d9ef">use</span> Memoize;
    memoize <span style="color:#e6db74">qw(fusc)</span>;

    <span style="color:#66d9ef">sub</span> <span style="color:#a6e22e">fusc</span> ($n) {
        <span style="color:#66d9ef">return</span> undef <span style="color:#66d9ef">if</span> $n <span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">0</span>;
        <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span> <span style="color:#66d9ef">if</span> $n <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>;
        <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">1</span> <span style="color:#66d9ef">if</span> $n <span style="color:#f92672">==</span> <span style="color:#ae81ff">1</span>;

        $n % 2 <span style="color:#f92672">&amp;&amp;</span> <span style="color:#66d9ef">return</span> fusc(($n<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>)<span style="color:#e6db74">/2) + fusc(($n+1)/</span><span style="color:#ae81ff">2</span>);

        <span style="color:#66d9ef">return</span> fusc($n<span style="color:#f92672">/</span><span style="color:#ae81ff">2</span>);
    }
</code></pre></div><p><a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-104/perlboy1967/perl/ch-1.pl"><strong>Niels van Dijke</strong></a></p>
<p>Niels looks to <code>Memoize</code> for all his memoization needs as well. He also sees fit to add a function prototype, which is an interesting decision outside of our immediate scope here, but it&rsquo;s something I&rsquo;ve noticed he&rsquo;s been playing around with over the past 5 weeks or so.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-perl" data-lang="perl">    <span style="color:#66d9ef">use</span> Memoize;

    <span style="color:#75715e"># Prototype</span>
    <span style="color:#66d9ef">sub</span> <span style="color:#a6e22e">fusc</span>($);

    memoize(<span style="color:#e6db74">&#39;fusc&#39;</span>);

    printf <span style="color:#e6db74">&#34;%s\n&#34;</span>, join(<span style="color:#e6db74">&#39;, &#39;</span>, map { fusc($_) } (<span style="color:#ae81ff">0</span> <span style="color:#f92672">..</span> <span style="color:#ae81ff">49</span>));

    <span style="color:#66d9ef">sub</span> <span style="color:#a6e22e">fusc</span> ($) {
      <span style="color:#66d9ef">my</span> ($n) <span style="color:#f92672">=</span> @_;

      <span style="color:#66d9ef">return</span> $n <span style="color:#66d9ef">if</span> ($n <span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">2</span>);

      <span style="color:#66d9ef">if</span> (($n % 2) <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>) {
        <span style="color:#66d9ef">return</span> fusc($n<span style="color:#f92672">/</span><span style="color:#ae81ff">2</span>);
      } <span style="color:#66d9ef">else</span> {
        <span style="color:#66d9ef">return</span> fusc(($n<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>)<span style="color:#e6db74">/2) + fusc(($n+1)/</span><span style="color:#ae81ff">2</span>);
      }
    }
</code></pre></div><p><a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-104/james-smith/perl/ch-1.pl"><strong>James Smith</strong></a></p>
<p>James gives us a total of four solutions, working through many of the varieties we have seen earlier. He presents a recursive function, a loop constructing a list, and versions of these both utilizing a caching mechanism.</p>
<p>He also introduces bit shift operations to do the division, which is a new technique we have not seen previously and quite intriguing. To cache the array all he needs to do is define it as a <code>state</code> variable  and it will not get redefined at each new call. A little change to the internal logic preferentially returns the cached value, acting as memoization.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-perl" data-lang="perl">    <span style="color:#66d9ef">sub</span> <span style="color:#a6e22e">fusc</span> {
      <span style="color:#66d9ef">my</span> $n <span style="color:#f92672">=</span> shift; <span style="color:#75715e">## Both look the floor $n/2 value, but when</span>
                     <span style="color:#75715e">## odd also looks at ceil $n/2.</span>
                     <span style="color:#75715e">## We use bit shift operators to do the</span>
                     <span style="color:#75715e">## divide by 2 so it automatically does the</span>
                     <span style="color:#75715e">## floor (and ceiling by adding 1)</span>
      <span style="color:#66d9ef">return</span> $n<span style="color:#f92672">&lt;</span><span style="color:#ae81ff">2</span> ? $n : fusc($n<span style="color:#f92672">&gt;&gt;</span><span style="color:#ae81ff">1</span>) <span style="color:#f92672">+</span> ( $n<span style="color:#f92672">&amp;</span><span style="color:#ae81ff">1</span> ? fusc(<span style="color:#ae81ff">1</span><span style="color:#f92672">+</span>$n<span style="color:#f92672">&gt;&gt;</span><span style="color:#ae81ff">1</span>) : <span style="color:#ae81ff">0</span> );
    }

    <span style="color:#66d9ef">sub</span> <span style="color:#a6e22e">fusc_cache</span> {     <span style="color:#75715e">## Same method but with cache</span>
      <span style="color:#66d9ef">my</span> $n <span style="color:#f92672">=</span> shift;
      state @cache;
      <span style="color:#66d9ef">return</span> $cache[$n] <span style="color:#f92672">||=</span> $n<span style="color:#f92672">&lt;</span><span style="color:#ae81ff">2</span> ? $n :
        fusc_cache($n<span style="color:#f92672">&gt;&gt;</span><span style="color:#ae81ff">1</span>) <span style="color:#f92672">+</span> ( $n<span style="color:#f92672">&amp;</span><span style="color:#ae81ff">1</span> ? fusc_cache(<span style="color:#ae81ff">1</span><span style="color:#f92672">+</span>$n<span style="color:#f92672">&gt;&gt;</span><span style="color:#ae81ff">1</span>) : <span style="color:#ae81ff">0</span> );
    }
</code></pre></div><p><a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-104/paulo-custodio/perl/ch-1.pl"><strong>Paulo Custodio</strong></a></p>
<p>Paulo also uses a <code>state</code> variable to cache his prior results. The declaration and preferential return are clearly demonstrated in this version. Also of note is his bitwise check for evenness; a bitwise AND with 1 checks the value of the rightmost bit. If the bit is set, the operation will return TRUE, or 1, which happens when the value is odd. So if the result is 0, the value is even.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-perl" data-lang="perl">    <span style="color:#66d9ef">sub</span> <span style="color:#a6e22e">fusc</span> {
        <span style="color:#66d9ef">my</span>($n) <span style="color:#f92672">=</span> @_;
        state @fusc;
        <span style="color:#66d9ef">return</span> $fusc[$n] <span style="color:#66d9ef">if</span> defined $fusc[$n];
        <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span> <span style="color:#66d9ef">if</span> $n<span style="color:#f92672">==</span><span style="color:#ae81ff">0</span>;
        <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">1</span> <span style="color:#66d9ef">if</span> $n<span style="color:#f92672">==</span><span style="color:#ae81ff">1</span>;

        <span style="color:#66d9ef">if</span> (($n <span style="color:#f92672">&amp;</span> <span style="color:#ae81ff">1</span>)<span style="color:#f92672">==</span><span style="color:#ae81ff">0</span>) {      <span style="color:#75715e"># even</span>
            <span style="color:#66d9ef">return</span> $fusc[$n] <span style="color:#f92672">=</span> fusc($n<span style="color:#f92672">/</span><span style="color:#ae81ff">2</span>);                      <span style="color:#75715e"># assign and return</span>
        }
        <span style="color:#66d9ef">else</span> {
            <span style="color:#66d9ef">return</span> $fusc[$n] <span style="color:#f92672">=</span> fusc(($n<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>)<span style="color:#e6db74">/2) + fusc(($n+1)/</span><span style="color:#ae81ff">2</span>); <span style="color:#75715e"># assign and return</span>
        }
    }
</code></pre></div><h2 id="unique-approaches-and-other-things-that-caught-my-eye">UNIQUE approaches and other THINGS THAT CAUGHT MY EYE</h2>
<p><a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-104/abigail/perl/ch-1.pl"><strong>Abigail</strong></a>,
<a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-104/e-choroba/perl/ch-1.pl"><strong>E. Choroba</strong></a>,
<a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-104/polettix/perl/ch-1.pl"><strong>Flavio Poletti</strong></a>,
<a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-104/jo-37/perl/ch-1.pl"><strong>Jorg Sommrey</strong></a>, and
<a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-104/wanderdoc/perl/ch-1.pl"><strong>Wanderdoc</strong></a></p>
<p><a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-104/polettix/perl/ch-1.pl"><strong>Flavio Poletti</strong></a></p>
<p>Flavio seems to have gone out of his way to put the &ldquo;challenge&rdquo; back into this task. He delivers a pair of solutions that each add characteristics and obscurity in ways we&rsquo;ve only dreamed of. I want you to look me in the eye and tell me you haven&rsquo;t ever had a code nightmare.</p>
<p>For the first, he gives us an iterative solution that starts from the basic algorithm. We see some by now more familiar elements, like the bit shifting. On the other hand we have a quite unusual transformation:  if, for <em>even</em> numbers,</p>
<pre><code>f(n) = f(n/2)
</code></pre>
<p>then for an <em>odd</em> number</p>
<pre><code>f(n-1) = f( (n-1)/2 )
</code></pre>
<p>and hence the odd equation</p>
<pre><code>f(n) = f( (n-1)/2 ) + f( (n+1)/2 )
</code></pre>
<p>can be reconfigured as</p>
<pre><code>f(n) = f(n-1) + f( (n+1)/2 )
</code></pre>
<p>As we&rsquo;re growing the array one element at a time f(n) is the last element added to the array, or <code>@fusc[-1]</code>.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-perl" data-lang="perl">    <span style="color:#66d9ef">sub</span> <span style="color:#a6e22e">fusc</span> ($n) {
       <span style="color:#66d9ef">return</span> [<span style="color:#ae81ff">0</span> <span style="color:#f92672">..</span> $n <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>] <span style="color:#66d9ef">if</span> $n <span style="color:#f92672">&lt;=</span> <span style="color:#ae81ff">2</span>;
       <span style="color:#66d9ef">my</span> @fusc <span style="color:#f92672">=</span> (<span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">1</span>); <span style="color:#75715e"># fusc(0), fusc(1)</span>
       <span style="color:#66d9ef">while</span> (@fusc <span style="color:#f92672">&lt;</span> $n) {
          push @fusc, $fusc[@fusc <span style="color:#f92672">&gt;&gt;</span> <span style="color:#ae81ff">1</span>];
          <span style="color:#66d9ef">last</span> <span style="color:#66d9ef">if</span> @fusc <span style="color:#f92672">&gt;=</span> $n;
          push @fusc, $fusc[<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>] <span style="color:#f92672">+</span> $fusc[<span style="color:#ae81ff">1</span> <span style="color:#f92672">+</span> @fusc <span style="color:#f92672">&gt;&gt;</span> <span style="color:#ae81ff">1</span>];
       }
       <span style="color:#66d9ef">return</span> <span style="color:#f92672">\</span>@fusc;
    }
</code></pre></div><p>For his second course, Flavio decides that instead of looking backwards to find the components of the new numbers being created, why not just add the components to future numbers as they come up and be done with it? This one gets a little weird and kludgy, requiring fusc[1] to be continually reset.</p>
<p>A fuller explanation is available in his <a href="https://github.polettix.it/ETOOBUSY/2021/03/17/pwc104-fusc-sequence/">blog writeup</a>, where he fully acknowledges</p>
<blockquote>
<p>**&ldquo;simpler solutions are often better for a reason.&quot;**</p>
</blockquote>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-perl" data-lang="perl">    <span style="color:#66d9ef">sub</span> <span style="color:#a6e22e">fusc_sieve</span> ($n) {
       <span style="color:#66d9ef">my</span> @fusc <span style="color:#f92672">=</span> (<span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">1</span>);
       <span style="color:#66d9ef">for</span> <span style="color:#66d9ef">my</span> $i (<span style="color:#ae81ff">1</span> <span style="color:#f92672">..</span> $n <span style="color:#f92672">&gt;&gt;</span> <span style="color:#ae81ff">1</span>) {
          $fusc[$i <span style="color:#f92672">*</span> <span style="color:#ae81ff">2</span>]      <span style="color:#f92672">=</span> $fusc[$i];
          $fusc[$i <span style="color:#f92672">*</span> <span style="color:#ae81ff">2</span> <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>] <span style="color:#f92672">+=</span> $fusc[$i];
          $fusc[$i <span style="color:#f92672">*</span> <span style="color:#ae81ff">2</span> <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>] <span style="color:#f92672">+=</span> $fusc[$i];
       }
       $fusc[<span style="color:#ae81ff">1</span>] <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>;
       <span style="color:#66d9ef">return</span> [@fusc[<span style="color:#ae81ff">0</span> <span style="color:#f92672">..</span> $n <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>]];
    }
</code></pre></div><p><a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-104/e-choroba/perl/ch-1.pl"><strong>E. Choroba</strong></a></p>
<p>I found Choroba&rsquo;s submission immensely interesting. Short and sweet, it constructs a loop selecting one of two coderefs for each entry, which are then called and evaluated. Once the number of elements requested are constructed, the function returns the list.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-perl" data-lang="perl">    <span style="color:#66d9ef">sub</span> <span style="color:#a6e22e">fusc</span> {
        <span style="color:#66d9ef">my</span> ($l) <span style="color:#f92672">=</span> @_;
        <span style="color:#66d9ef">my</span> @seq <span style="color:#f92672">=</span> (<span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">1</span>);
        <span style="color:#66d9ef">while</span> (@seq <span style="color:#f92672">&lt;</span> $l) {
            <span style="color:#66d9ef">my</span> $n <span style="color:#f92672">=</span> @seq;
            push @seq, (<span style="color:#66d9ef">sub</span> { $seq[ $n <span style="color:#f92672">/</span> <span style="color:#ae81ff">2</span> ]},
                        <span style="color:#66d9ef">sub</span> { $seq[ ($n <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>) <span style="color:#e6db74">/ 2] + $seq[ ($n - 1) /</span> <span style="color:#ae81ff">2</span>] }
                    )[$n % 2]<span style="color:#f92672">-&gt;</span>();
        }
        <span style="color:#66d9ef">return</span> @seq
    }
</code></pre></div><p><a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-104/wanderdoc/perl/ch-1.pl"><strong>Wanderdoc</strong></a></p>
<p>The doctor takes a unique approach to their method: rather than directly producing either a value or a list of values, they provide a function that, when initialized with an upper bound, returns a code reference to an iterator function, closed around the internal variables <code>$i</code>, an array of values, and the given initialized maximum.  Successive calls to this iterator will increment the index <code>$i</code> and return the FUSC value at that index.</p>
<p>Because of the closure, the values of the growing list are always available to the function, so the function works like growing lists in a loop, with all previous results cached and accessable.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-perl" data-lang="perl">    <span style="color:#66d9ef">sub</span> <span style="color:#a6e22e">generate_fusc</span>
    {
         <span style="color:#66d9ef">my</span> $max <span style="color:#f92672">=</span> $_[<span style="color:#ae81ff">0</span>];
         <span style="color:#66d9ef">my</span> @arr;
         <span style="color:#66d9ef">my</span> $i <span style="color:#f92672">=</span> <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>;

         <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">sub</span>
         {
              $i<span style="color:#f92672">++</span>;

              <span style="color:#66d9ef">if</span>     ( $i <span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">2</span> ) { $arr[$i] <span style="color:#f92672">=</span> $i; }
              <span style="color:#66d9ef">elsif</span>  ( $i % 2 ) { $arr[$i] <span style="color:#f92672">=</span> $arr[($i<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>)<span style="color:#e6db74">/2] + $arr[($i+1)/</span><span style="color:#ae81ff">2</span>]; }
              <span style="color:#66d9ef">else</span>              { $arr[$i] <span style="color:#f92672">=</span> $arr[$i <span style="color:#f92672">/</span> <span style="color:#ae81ff">2</span>]; }
              <span style="color:#66d9ef">return</span> undef <span style="color:#66d9ef">if</span> $i <span style="color:#f92672">&gt;</span> $max;
              <span style="color:#66d9ef">return</span> [$i, $arr[$i]];
         }
    }

    <span style="color:#66d9ef">my</span> $next <span style="color:#f92672">=</span> generate_fusc(<span style="color:#ae81ff">50</span>);
    <span style="color:#66d9ef">while</span> ( <span style="color:#66d9ef">my</span> $item <span style="color:#f92672">=</span> $next<span style="color:#f92672">-&gt;</span>() ) { <span style="color:#66d9ef">print</span> join(<span style="color:#e6db74">&#34;: &#34;</span>, @$item), $/; }
</code></pre></div><p><a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-104/jo-37/perl/ch-1.pl"><strong>Jorg Sommrey</strong></a></p>
<p>Where to begin with Jorg? Well to start amidst the profuse commentary there are remarkably few lines of code. And it&rsquo;s perhaps not immediately obvious but there are two solutions here as well, one containing a single line and the other three.</p>
<p>Going to the OEIS page, should one wish to prepare the sequence from alternate formulae, then there are a variety to chose from, arguably each more obscure than the last. Jorg picks two, &ldquo;the number of odd entries in the diagonals of Pascal&rsquo;s triangle at 45 degrees slope&rdquo; and for the other a back derivation from the <a href="https://en.wikipedia.org/wiki/Calkin%E2%80%93Wilf_tree">Calkin Wilf Tree</a>. That Wiki page alone is worth the price of admission. As for the run-length encoding, I&rsquo;m just going to take his word for it.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-perl" data-lang="perl">    <span style="color:#66d9ef">use</span> Math::Prime::Util <span style="color:#e6db74">&#39;binomial&#39;</span>;
    <span style="color:#66d9ef">use</span> List::Util <span style="color:#e6db74">&#39;reduce&#39;</span>;
    <span style="color:#66d9ef">use</span> Math::BigRat;
    <span style="color:#66d9ef">use</span> PDL; <span style="color:#75715e"># Just for ceil and rle</span>

    <span style="color:#75715e"># Non-recursive implementation of fusc according to</span>
    <span style="color:#75715e"># http://oeis.org/A002487 as the number of odd elements in the diagonal</span>
    <span style="color:#75715e"># of Pascal&#39;s triangle.  Drawback of this implementation: rather large</span>
    <span style="color:#75715e"># numbers are involved and lots of memory are wasted.</span>
    <span style="color:#66d9ef">sub</span> <span style="color:#a6e22e">fusc</span> ($n) {
        <span style="color:#75715e"># Interestingly, without the modulus this would produce the</span>
        <span style="color:#75715e"># respective Fibonacci number.</span>
        reduce {$a <span style="color:#f92672">+=</span> $b % 2} <span style="color:#ae81ff">0</span>, map binomial($_, $n <span style="color:#f92672">-</span> $_ <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>),
            ceil(($n <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>) <span style="color:#f92672">/</span> <span style="color:#ae81ff">2</span>) <span style="color:#f92672">..</span> $n <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>;
    }

    <span style="color:#75715e"># An alternative non-recursive implementation:</span>
    <span style="color:#75715e"># Compute fusc(n) from the Calkin-Wilf sequence.  The n-th element of</span>
    <span style="color:#75715e"># the Calkin-Wilf sequence is the fraction fusc(n)/fusc(n+1).  This</span>
    <span style="color:#75715e"># element can be calculated by taking the run-length encoding of the</span>
    <span style="color:#75715e"># binary representation of n as the coefficients of a continued</span>
    <span style="color:#75715e"># fraction.</span>
    <span style="color:#75715e"># See https://en.wikipedia.org/wiki/Calkin%E2%80%93Wilf_tree</span>
    <span style="color:#75715e"># Coefficients are in reversed order here.</span>
    <span style="color:#66d9ef">sub</span> <span style="color:#a6e22e">fusc_from_cws</span> ($n) {
        <span style="color:#75715e"># This doesn&#39;t work for zero.</span>
        <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span> <span style="color:#66d9ef">unless</span> $n;

        <span style="color:#75715e"># Get the rle of the binary representation.  Using PDL here as I</span>
        <span style="color:#75715e"># didn&#39;t find an easier way.</span>
        <span style="color:#66d9ef">my</span> @rle <span style="color:#f92672">=</span> grep $_, (rle(byte split <span style="color:#e6db74">//</span>, sprintf <span style="color:#e6db74">&#39;%b&#39;</span>, $n))[<span style="color:#ae81ff">0</span>]<span style="color:#f92672">-&gt;</span>list;
        <span style="color:#75715e"># Append a zero if the binary number ends in zero.  See the example</span>
        <span style="color:#75715e"># in Wikipedia.</span>
        push @rle, <span style="color:#ae81ff">0</span> <span style="color:#66d9ef">unless</span> $n % 2;

        <span style="color:#75715e"># Return the numerator from the rational number corresponding to the</span>
        <span style="color:#75715e"># continued fraction. The identity value in this case is &#39;inf&#39; as</span>
        <span style="color:#75715e"># the reciprocal of zero.  Performing rational arithmetics.</span>
        (reduce {<span style="color:#ae81ff">1</span> <span style="color:#f92672">/</span> $a <span style="color:#f92672">+</span> $b} Math::BigRat<span style="color:#f92672">-&gt;</span><span style="color:#66d9ef">new</span>(<span style="color:#e6db74">&#39;inf&#39;</span>), @rle)<span style="color:#f92672">-&gt;</span>numerator;
    }
</code></pre></div><p><a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-104/abigail/perl/ch-1.pl"><strong>Abigail</strong></a></p>
<blockquote>
<p>Remember what the first rule of optimization is? Don’t do anything which is not needed.</p>
</blockquote>
<p>With this statement Abigail, taking the directives in the most literal manner possible, prints a list of the first 50 items in the sequence, taken from the OEIS. One could justly question, if not the undeniable validity of this program, than perhaps the underlying value it provides. Which, by self-admission, is just a &ldquo;glorified Hello, World!&quot;. So not much, in that regard.</p>
<p>This leads into the thought of: if we&rsquo;re not to do anything which is not needed, why participate in the challenge at all then, if the code provides only minimal value? And there&rsquo;s the rub.</p>
<p>The logical way out of this predicament is the meta-analysis: the code isn&rsquo;t the thing. The advice <em>about</em> the code is the thing.</p>
<p>In this pursuit we&rsquo;ve chosen to participate in we sometimes go to quite extraordinary lengths to perform what amount to, in the end, silly and useless tasks. Even when the task serves an obviously useful purpose, it remains unlikely that any one of us will ever say: &ldquo;Oh wait, I solved that before in PWC 057! Let me find that code! Here boss, I saved you an hour!&rdquo;</p>
<p>No, even if the specific puzzles in themselves are not immediately useful or necessary, the act of doing them itself has value. And this is why I&rsquo;m glad someone works out these logical extremes.</p>
<p>Someone has to do it. And I don&rsquo;t feel like it. The advice is sound, and the community is well-served by the reminder. We all have our roles to play in this elaborate production.</p>
<p>Here is his submission:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-perl" data-lang="perl">    say <span style="color:#e6db74">&#34;0 1 1 2 1 3 2 3 1 4 3 5 2 5 3 4 1 5 4 7 3 8 5 7 2 7 &#34;</span> <span style="color:#f92672">.</span>
        <span style="color:#e6db74">&#34;5 8 3 7 4 5 1 6 5 9 4 11 7 10 3 11 8 13 5 12 7 9 2 9&#34;</span>;
</code></pre></div><p>Abigail has instead invested his time in producing the generating code in a large number of languages, viewable at the the <a href="https://github.com/manwar/perlweeklychallenge-club/tree/master/challenge-104/abigail">GitHub repository</a>.</p>
<hr>
<hr>
<h1 id="PWC104TASK2">TASK 2</h1>
<h1 id="nim-game">NIM Game</h1>
<p><em>Submitted by: Mohammad S Anwar</em></p>
<p>Write a script to simulate the NIM Game.</p>
<p>It is played between 2 players. For the purpose of this task, let assume you play against the machine.</p>
<p>There are 3 simple rules to follow:</p>
<ol>
<li>You have 12 tokens</li>
<li>Each player can pick 1, 2 or 3 tokens at a time</li>
<li>The player who picks the last token wins the game</li>
</ol>
<h2 id="about-the-solutions-1">about the solutions</h2>
<p><a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-104/abigail/perl/ch-2.pl"><strong>Abigail</strong></a>,
<a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-104/alexander-karelas/perl/ch-2.pl"><strong>Alexander Karelas</strong></a>,
<a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-104/athanasius/perl/ch-2.pl"><strong>Athanasius</strong></a>,
<a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-104/cheok-yin-fung/perl/ch-2.pl"><strong>Cheok-Yin Fung</strong></a>,
<a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-104/colin-crain/perl/ch-2.pl"><strong>Colin Crain</strong></a>,
<a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-104/dave-jacoby/perl/ch-2.pl"><strong>Dave Jacoby</strong></a>,
<a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-104/duncan-c-white/perl/ch-2.pl"><strong>Duncan C. White</strong></a>,
<a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-104/e-choroba/perl/ch-2.pl"><strong>E. Choroba</strong></a>,
<a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-104/polettix/perl/ch-2.pl"><strong>Flavio Poletti</strong></a>,
<a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-104/jaldhar-h-vyas/perl/ch-2.pl"><strong>Jaldhar H. Vyas</strong></a>,
<a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-104/james-smith/perl/ch-2.pl"><strong>James Smith</strong></a>,
<a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-104/jo-37/perl/ch-2.pl"><strong>Jorg Sommrey</strong></a>,
<a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-104/laurent-rosenfeld/perl/ch-2.pl"><strong>Laurent Rosenfeld</strong></a>,
<a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-104/lubos-kolouch/perl/ch-2.pl"><strong>Lubos Kolouch</strong></a>,
<a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-104/perlboy1967/perl/ch-2.pl"><strong>Niels van Dijke</strong></a>,
<a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-104/paulo-custodio/perl/ch-2.pl"><strong>Paulo Custodio</strong></a>,
<a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-104/pete-houston/perl/ch-2.pl"><strong>Pete Houston</strong></a>,
<a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-104/roger-bell-west/perl/ch-2.pl"><strong>Roger Bell_West</strong></a>,
<a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-104/stuart-little/perl/ch-2.pl"><strong>Stuart Little</strong></a>, and
<a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-104/ulrich-rieke/perl/ch-2.pl"><strong>Ulrich Rieke</strong></a></p>
<p>There were 20 submissions for the second task this past week. One common first observation made was &ldquo;This is not Nim!&rdquo; Although this claim was made often, it&rsquo;s not exactly true, as the rules of Nim are ancient and not strictly defined. One could reasonably call this version, itself commonly called &ldquo;the Take-Away Game&rdquo;, or &ldquo;The Subtraction Game&rdquo;, a simplified degenerate form of the archetype, with only one pool and an additional restraint of only being able to remove one to three tokens.</p>
<p>When I first read this challenge, it looked somewhat familiar, but it wasn&rsquo;t a game I recalled ever playing. Maybe as a child, I don&rsquo;t know. I figured I could do a little research and glean more about it, but as I enjoy thinking about the theory underlying games and game play, I decided to just go at it and figure it out from scratch instead.</p>
<p>At first I suspected that with enough tokens the limited range allowed in moves, only allowing either 1,2, or 3 draws per player, would be multiplied and eventually result in complex behavior. This proved to be incorrect. The limited moves instead lock the game into a small number of equivalent repeating cycles, and if a player has opportunity to present their opponent with a certain pattern of positions, then with perfect play that player will always win. Adding more moves only adds more cycles, and although play will take longer it will always end up in one of the same final scenarios.  Because this perfect strategy is symmetric, once the number of tokens and the first to draw is decided the outcome of the game is already determined.</p>
<p>So it&rsquo;s not much of a game at all, really. The only challenge left between two naive players is who can figure out the perfect strategy first. If one player goes into the match already knowing the strategy, then the game is changed for this sharpster, into keeping their opponent from figuring out they are being swindled.</p>
<p>This second meta-game, being seated in vagaries of social engineering, exhibits myriad diverse and unpredictable complex behaviors. Although lacking an ethical grounding, it&rsquo;s much more interesting than the game we&rsquo;re modeling today.</p>
<p>There exist complex games that can be constructed from simple rules, such as Go, or even Checkers. This is not one of those games.</p>
<h2 id="how-to-win">How to Win</h2>
<p><a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-104/abigail/perl/ch-2.pl"><strong>Abigail</strong></a>,
<a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-104/e-choroba/perl/ch-2.pl"><strong>E. Choroba</strong></a>,
<a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-104/paulo-custodio/perl/ch-2.pl"><strong>Paulo Custodio</strong></a>,
<a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-104/stuart-little/perl/ch-2.pl"><strong>Stuart Little</strong></a>, and
<a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-104/ulrich-rieke/perl/ch-2.pl"><strong>Ulrich Rieke</strong></a></p>
<p>Forgetting the distraction of the gameplay mechanics as already laid out, the object of the game is to give your opponent a pot of tokens that is a multiple of 4. If one can accomplish this, then whatever draw is taken, counter with taking 4 minus the number of tokens your opponent just took. As the two of you together have now taken 4 tokens, this will ensure your opponent will again be left with a pot that is a multiple of 4. Eventually they will be left with 4 tokens and be required to draw at least one token, and you can take the remainder and win.</p>
<p><a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-104/abigail/perl/ch-2.pl"><strong>Abigail</strong></a></p>
<p>As Abigail ruthlessly does not allow any variance and always forces the player to draw first, implementing a mechanism so the computer can win the game becomes a short, straightforward exercise.</p>
<p>After proper input validation, a simple formula allows the computer to take whatever number of tokens are required to return the player&rsquo;s pot to a multiple of 4.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-perl" data-lang="perl">    <span style="color:#66d9ef">my</span> $tokens   <span style="color:#f92672">=</span> <span style="color:#ae81ff">12</span>;
    <span style="color:#66d9ef">my</span> $max_take <span style="color:#f92672">=</span>  <span style="color:#ae81ff">3</span>;

    <span style="color:#66d9ef">while</span> ($tokens <span style="color:#f92672">&gt;</span> <span style="color:#ae81ff">0</span>) {
        printf <span style="color:#e6db74">&#34;How many tokens do you take? (%2d token%s are left) &#34;</span> <span style="color:#f92672">=&gt;</span>
                        $tokens, $tokens <span style="color:#f92672">==</span> <span style="color:#ae81ff">1</span> ? <span style="color:#e6db74">&#34;&#34;</span> : <span style="color:#e6db74">&#34;s&#34;</span>;
        chomp (<span style="color:#66d9ef">my</span> $t <span style="color:#f92672">=</span> <span style="color:#f92672">&lt;&gt;</span>);
        <span style="color:#66d9ef">redo</span> <span style="color:#66d9ef">unless</span> $t <span style="color:#f92672">=~</span><span style="color:#e6db74"> /^\s*[0-9]+\s*$/</span> <span style="color:#f92672">&amp;&amp;</span> <span style="color:#ae81ff">1</span> <span style="color:#f92672">&lt;=</span> $t <span style="color:#f92672">&lt;=</span> $max_take;
        <span style="color:#66d9ef">my</span> $takes <span style="color:#f92672">=</span> $max_take <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span> <span style="color:#f92672">-</span> $t;
        printf <span style="color:#e6db74">&#34;Computer takes %d token%s\n&#34;</span> <span style="color:#f92672">=&gt;</span> $takes, $takes <span style="color:#f92672">==</span> <span style="color:#ae81ff">1</span> ? <span style="color:#e6db74">&#34;&#34;</span> : <span style="color:#e6db74">&#34;s&#34;</span>;
        $tokens <span style="color:#f92672">-=</span> ($max_take <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>);
    }
</code></pre></div><p><a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-104/stuart-little/perl/ch-2.pl"><strong>Stuart Little</strong></a></p>
<p>Stuart presents the same logic as a piece of modulo arithmetic, where the options for the computer are to preferentially take the size of the pot modulo 4 tokens, or if that result is 0, a random draw. Variations on this modulo equation were by far the most commonly seen manner of calculating the perfect move.</p>
<p>Here he gives us a nice compact, balanced structure with two routines, for a player move and a computer move, each routine calling the other on the last line.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-perl" data-lang="perl">    <span style="color:#66d9ef">sub</span> <span style="color:#a6e22e">youPlay</span>($heap,$k){
        $heap<span style="color:#f92672">==</span><span style="color:#ae81ff">0</span> <span style="color:#f92672">&amp;&amp;</span> <span style="color:#66d9ef">do</span> {
        say <span style="color:#e6db74">&#34;You lose!&#34;</span>;
        exit;
        };
        say <span style="color:#e6db74">&#34;The heap contains $heap tokens.&#34;</span>;
        <span style="color:#66d9ef">print</span> <span style="color:#e6db74">&#34;How many tokens are you removing? Please enter an integer between 1 and $k inclusive: &#34;</span>;
        <span style="color:#66d9ef">my</span> $take <span style="color:#f92672">=</span> <span style="color:#e6db74">&lt;STDIN&gt;</span>;
        chomp($take);
        compPlay($heap<span style="color:#f92672">-</span>$take,$k);
    }

    <span style="color:#66d9ef">sub</span> <span style="color:#a6e22e">compPlay</span>($heap,$k) {
        $heap<span style="color:#f92672">==</span><span style="color:#ae81ff">0</span> <span style="color:#f92672">&amp;&amp;</span> <span style="color:#66d9ef">do</span> {
        say <span style="color:#e6db74">&#34;You win!&#34;</span>;
        exit;
        };
        say <span style="color:#e6db74">&#34;The heap contains $heap tokens.&#34;</span>;
        <span style="color:#66d9ef">my</span> $take <span style="color:#f92672">=</span> ($heap % <span style="color:#960050;background-color:#1e0010">($</span>k<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>)) <span style="color:#f92672">||</span> [<span style="color:#ae81ff">1</span><span style="color:#f92672">..</span>$k]<span style="color:#f92672">-&gt;</span>[rand $k];
        say <span style="color:#e6db74">&#34;The computer removes $take items.&#34;</span>;
        youPlay($heap<span style="color:#f92672">-</span>$take,$k);
    }

    <span style="color:#66d9ef">my</span> $heap <span style="color:#f92672">=</span> (scalar @ARGV) ? ($ARGV[<span style="color:#ae81ff">0</span>]) : (<span style="color:#ae81ff">12</span>);
    youPlay($heap,<span style="color:#ae81ff">3</span>);
</code></pre></div><p><a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-104/e-choroba/perl/ch-2.pl"><strong>E. Choroba</strong></a></p>
<p>Choroba uses the <code>Moo</code> framework to prepare a <code>Game::Nim</code> object which knows how to play the game. As mentioned before the modulo operation was the most common method to produce a prefect strategy draw, and here it can be seen in the private <code>_my_turn()</code> method.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-perl" data-lang="perl">    <span style="color:#66d9ef">sub</span> <span style="color:#a6e22e">_my_turn</span> {
        <span style="color:#66d9ef">my</span> ($self) <span style="color:#f92672">=</span> @_;
        <span style="color:#66d9ef">my</span> $r <span style="color:#f92672">=</span> $self<span style="color:#f92672">-&gt;</span>remainder;
        <span style="color:#66d9ef">my</span> $pick <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
        $pick <span style="color:#f92672">=</span> ($r % 4) <span style="color:#f92672">||</span> <span style="color:#ae81ff">1</span> <span style="color:#f92672">+</span> int rand <span style="color:#ae81ff">3</span>;
        say <span style="color:#e6db74">&#39;Picking &#39;</span>, $pick;
        $self<span style="color:#f92672">-&gt;</span>_set_remainder($self<span style="color:#f92672">-&gt;</span>remainder <span style="color:#f92672">-</span> $pick);
    }
</code></pre></div><p>Choroba also includes a <code>.dot</code> file to <a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-104/e-choroba/perl/ch-2.dot">visualize a graph of the state progression</a> through possible games, which is nice but I cannot display it here.</p>
<p><a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-104/paulo-custodio/perl/ch-2.pl"><strong>Paulo Custodio</strong></a></p>
<p>Paulo provided a framework for analyzing the action, setting up a scenario where the computer, playing an optimal strategy for the player with the first move, plays 100,000 games against an opponent making either random draws or also playing a perfect game.</p>
<p>Predictably, played against a random strategy the first player will only be presented with a pot of 4 in 1/11th of the cases, yielding an approximately 91% win rate against that opponent. Against a second player also using the optimal strategy the win rate drops to 0%. As we know playing perfectly the second player will always win. In fact, as the optimal strategy is completely deterministic, a little math reveals that there are 3 move options available to the first player, and the game will last 3 rounds. This yields only 3<sup>3</sup> or 27 possible games, with the second player winning all 27.</p>
<p>Here is Paulo&rsquo;s table for deriving the perfect move:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-perl" data-lang="perl">    <span style="color:#66d9ef">sub</span> <span style="color:#a6e22e">play_to_win</span> {
        <span style="color:#66d9ef">my</span>($T) <span style="color:#f92672">=</span> @_;
        <span style="color:#66d9ef">return</span> $T <span style="color:#66d9ef">if</span> $T <span style="color:#f92672">&lt;=</span> <span style="color:#ae81ff">3</span>;       <span style="color:#75715e"># win the game</span>
        <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">1</span> <span style="color:#66d9ef">if</span> ($T % 4)<span style="color:#f92672">==</span><span style="color:#ae81ff">0</span>;    <span style="color:#75715e"># lose the game</span>
        <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">1</span> <span style="color:#66d9ef">if</span> ($T % 5)<span style="color:#f92672">==</span><span style="color:#ae81ff">0</span>;    <span style="color:#75715e"># win the game</span>
        <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">2</span> <span style="color:#66d9ef">if</span> ($T % 6)<span style="color:#f92672">==</span><span style="color:#ae81ff">0</span>;    <span style="color:#75715e"># win the game</span>
        <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">3</span> <span style="color:#66d9ef">if</span> ($T % 7)<span style="color:#f92672">==</span><span style="color:#ae81ff">0</span>;    <span style="color:#75715e"># win the game</span>
        <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">2</span> <span style="color:#66d9ef">if</span> ($T % 9)<span style="color:#f92672">==</span><span style="color:#ae81ff">0</span>;    <span style="color:#75715e"># win the game</span>
        <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">2</span> <span style="color:#66d9ef">if</span> ($T % 11)<span style="color:#f92672">==</span><span style="color:#ae81ff">0</span>;   <span style="color:#75715e"># win the game</span>
        die $T;
    }
</code></pre></div><p><a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-104/ulrich-rieke/perl/ch-2.pl"><strong>Ulrich Rieke</strong></a></p>
<p>Ulrich provides a hardcoded version of the decision-making process as a sequence of <code>if</code> statements. This is the same as unwinding the modulo 4 operation into a set of linear choices.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-perl" data-lang="perl">      <span style="color:#66d9ef">if</span> ( $parts <span style="color:#f92672">&gt;</span> <span style="color:#ae81ff">8</span> <span style="color:#f92672">and</span> $parts <span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">12</span> ) {
    $takeaway <span style="color:#f92672">=</span> $parts <span style="color:#f92672">-</span> <span style="color:#ae81ff">8</span> ;
      }
      <span style="color:#66d9ef">if</span> ( $parts <span style="color:#f92672">&gt;</span> <span style="color:#ae81ff">4</span> <span style="color:#f92672">and</span> $parts <span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">8</span> ) {
    $takeaway <span style="color:#f92672">=</span> $parts <span style="color:#f92672">-</span> <span style="color:#ae81ff">4</span> ;
      }
      <span style="color:#66d9ef">if</span> ( $parts <span style="color:#f92672">==</span> <span style="color:#ae81ff">4</span> ) {
    $takeaway <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span> ;
      }
      <span style="color:#66d9ef">if</span> ( $parts <span style="color:#f92672">==</span> <span style="color:#ae81ff">8</span> ) {
    $takeaway <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span> ;
      }
      <span style="color:#66d9ef">if</span> ( $parts <span style="color:#f92672">&gt;</span> <span style="color:#ae81ff">0</span> <span style="color:#f92672">and</span> $parts <span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">4</span> ) {
    $takeaway <span style="color:#f92672">=</span> $parts ;
      }
</code></pre></div><h2 id="playing-against-the-computer">Playing Against the Computer</h2>
<p>The challenge can be considered as two parts, the underlying logic of determining what to do and the act of presenting the state of the game to the user.</p>
<h3 id="should-the-computer-use-the-perfect-strategy"><em>Should</em> the Computer Use the Perfect Strategy?</h3>
<p><a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-104/dave-jacoby/perl/ch-2.pl"><strong>Dave Jacoby</strong></a>,
<a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-104/lubos-kolouch/perl/ch-2.pl"><strong>Lubos Kolouch</strong></a>, and
<a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-104/perlboy1967/perl/ch-2.pl"><strong>Niels van Dijke</strong></a></p>
<p>It wasn&rsquo;t explicitly stated that the computer should play the perfect strategy. I mean, this seems like a reasonable goal but, as the game is essentially fixed and the human has access to the computer&rsquo;s power switch this might not always be in the computer&rsquo;s best interest.</p>
<p>Nearly every submission ended up programming in the perfect strategy, but not all. There were random-draw strategies employed as well, and even some creative outliers, both simpler and more complex. Subjectively, none of this seemed to me to provide objectively superior gameplay than the deterministic version, although a break from predictability was welcome.</p>
<p>On the whole I don&rsquo;t think any amount of cleverness can really save this version of Nim. Que sera, sera.</p>
<p><a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-104/dave-jacoby/perl/ch-2.pl"><strong>Dave Jacoby</strong></a></p>
<p>Dave implemented a considerably simpler computer player. It was never specified that the computer should play particularly well or anything.</p>
<p>He kindly lays down his plan before the world:</p>
<blockquote>
<p>Opponent “AI”
This was simple:</p>
<ul>
<li>If there are three tokens, take the win</li>
<li>If there are two tokens, take the win</li>
<li>Otherwise, take one token</li>
</ul>
</blockquote>
<p>A simple plan, destined to fail if the human is not lulled into a false sense of security by the computer always drawing 1. Yet in the brutal zero-sum reality of wining and losing, each loss for the computer offers a win for some human player. This simple act of kindness was an olive-branch to humanity on an otherwise ruthless and unforgiving playing field among the rest of the submissions.</p>
<p>Or maybe it&rsquo;s just self-preservation. You know, &ldquo;Let the Wookiee win.&rdquo;</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-perl" data-lang="perl">    <span style="color:#75715e"># opponent</span>
    <span style="color:#66d9ef">my</span> $op <span style="color:#f92672">=</span> opponent_choice($tokens);
    $plural <span style="color:#f92672">=</span> $op <span style="color:#f92672">==</span> <span style="color:#ae81ff">1</span> ? <span style="color:#e6db74">&#39;token&#39;</span> : <span style="color:#e6db74">&#39;tokens&#39;</span>;
    say <span style="color:#e6db74">qq{    Opponent chose $op $plural \n}</span>;
    <span style="color:#66d9ef">if</span> ( $tokens <span style="color:#f92672">==</span> $op ) {
        say <span style="color:#e6db74">&#39;Opponent has won!&#39;</span>;
        exit;
    }
    $tokens <span style="color:#f92672">-=</span> $op;

    <span style="color:#75715e"># sneaky opponent AI</span>
    <span style="color:#66d9ef">sub</span> <span style="color:#a6e22e">opponent_choice</span>( $tokens ) {
        <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">3</span> <span style="color:#66d9ef">if</span> $tokens <span style="color:#f92672">==</span> <span style="color:#ae81ff">3</span>;
        <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">2</span> <span style="color:#66d9ef">if</span> $tokens <span style="color:#f92672">==</span> <span style="color:#ae81ff">2</span>;
        <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">1</span>;
    }
</code></pre></div><p><a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-104/perlboy1967/perl/ch-2.pl"><strong>Niels van Dijke</strong></a></p>
<p>Niels gives us a few unusual takes, both in his data collection, using <code>Term::ReadKey</code> to collect user input, and the strategy implemented.</p>
<p>The <code>Term::ReadKey</code> module provides direct access to the terminal, tying it to STDIN. Keypresses are immediately read and acted on without the need for an enter or return key to signify we are finished with our input. As a result, the interaction is very responsive.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-perl" data-lang="perl">     <span style="color:#66d9ef">do</span> {
       $takeTokens <span style="color:#f92672">=</span> ReadKey(<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>);
       <span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>defined $takeTokens) {
         usleep(<span style="color:#ae81ff">1_000</span>);
       } <span style="color:#66d9ef">elsif</span> (uc($takeTokens) <span style="color:#f92672">eq</span> <span style="color:#e6db74">&#39;Q&#39;</span>) {
         <span style="color:#75715e"># Give up, you loose</span>
         <span style="color:#66d9ef">print</span> <span style="color:#e6db74">&#34;Quit\n\n&gt;&gt;&gt; You lose &lt;&lt;&lt;\n&#34;</span>;
         exit;
       } <span style="color:#66d9ef">elsif</span> ($takeTokens <span style="color:#f92672">=~</span> m<span style="color:#75715e">#^[\r\n]$#) {</span>
         $takeTokens <span style="color:#f92672">=</span> $defaultPick;
       } <span style="color:#66d9ef">elsif</span> ($takeTokens <span style="color:#f92672">!~</span> m<span style="color:#75715e">#$validPickRE# or</span>
                <span style="color:#f92672">!</span>grep {$takeTokens <span style="color:#f92672">==</span> $_} @validPicks) {
         undef($takeTokens);
       }
     } <span style="color:#66d9ef">while</span> (<span style="color:#f92672">!</span>defined $takeTokens);
</code></pre></div><p>The strategy takes a sort of hybrid approach, playing a perfect game at the finish, sliding into a completely determined table of moves from previously using random draws at the beginning. This gives a certain amount of ability to win back to the user, which is nice.</p>
<p>Here is his hardcoded table. Should the number of tokens in the pot exceed the values covered the draw is random, which in practice is the first and maybe the second move.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-perl" data-lang="perl">     <span style="color:#66d9ef">my</span> %tStrategy <span style="color:#f92672">=</span> (
       <span style="color:#ae81ff">1</span> <span style="color:#f92672">=&gt;</span> <span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">2</span> <span style="color:#f92672">=&gt;</span> <span style="color:#ae81ff">2</span>, <span style="color:#ae81ff">3</span> <span style="color:#f92672">=&gt;</span> <span style="color:#ae81ff">3</span>,
       <span style="color:#ae81ff">4</span> <span style="color:#f92672">=&gt;</span> <span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">5</span> <span style="color:#f92672">=&gt;</span> <span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">6</span> <span style="color:#f92672">=&gt;</span> <span style="color:#ae81ff">2</span>,
       <span style="color:#ae81ff">7</span> <span style="color:#f92672">=&gt;</span> <span style="color:#ae81ff">3</span>, <span style="color:#ae81ff">8</span> <span style="color:#f92672">=&gt;</span> <span style="color:#ae81ff">2</span>, <span style="color:#ae81ff">9</span> <span style="color:#f92672">=&gt;</span> <span style="color:#ae81ff">3</span>
     );

     $takeTokens <span style="color:#f92672">=</span> $tStrategy{$tokens} <span style="color:#e6db74">//</span> ceil(rand(@validPicks));
</code></pre></div><p>The table portion implements &ldquo;leave the opponent with a multiple of four&rdquo; with a few more more random moves towards the top end.</p>
<p><a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-104/lubos-kolouch/perl/ch-2.pl"><strong>Lubos Kolouch</strong></a></p>
<p>Lubos opens with the statement that the second player always wins, and &ldquo;What would be the fun then?&rdquo; With the perfect strategy, this is of course true. So without actually stating that this is the reason he choses a random strategy for the computer to play. I can see his point.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-perl" data-lang="perl">    <span style="color:#66d9ef">while</span> (<span style="color:#ae81ff">1</span>) {
        <span style="color:#75715e"># player turn</span>
        <span style="color:#66d9ef">my</span> $player_input <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;

        <span style="color:#66d9ef">do</span> {
            <span style="color:#66d9ef">print</span> <span style="color:#e6db74">&#34;Tokens remaining: $tokens . How many do you take (1-3) ?\n&#34;</span>;
            $player_input <span style="color:#f92672">=</span> <span style="color:#f92672">&lt;&gt;</span>;
            chomp $player_input;
        } <span style="color:#66d9ef">until</span> (($player_input <span style="color:#f92672">=~</span><span style="color:#e6db74"> /\d+/</span>) <span style="color:#f92672">and</span> ($player_input <span style="color:#f92672">&gt;</span> <span style="color:#ae81ff">0</span>) <span style="color:#f92672">and</span> ($player_input <span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">4</span>));

        $tokens <span style="color:#f92672">-=</span> $player_input;

        <span style="color:#66d9ef">if</span> ($tokens <span style="color:#f92672">&lt;=</span> <span style="color:#ae81ff">0</span>) {
            <span style="color:#66d9ef">print</span> <span style="color:#e6db74">&#34;Great job! You have won!\n&#34;</span>;
            <span style="color:#66d9ef">return</span>;
        }

        <span style="color:#75715e"># comp turn</span>
        $player_input <span style="color:#f92672">=</span> int(rand(<span style="color:#ae81ff">3</span>)) <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>;
        <span style="color:#66d9ef">print</span> <span style="color:#e6db74">&#34;Comp takes $player_input\n&#34;</span>;

        $tokens <span style="color:#f92672">-=</span> $player_input;

        <span style="color:#66d9ef">if</span> ($tokens <span style="color:#f92672">&lt;=</span> <span style="color:#ae81ff">0</span>) {
            <span style="color:#66d9ef">print</span> <span style="color:#e6db74">&#34;Sorry, comp won\n&#34;</span>;
            <span style="color:#66d9ef">return</span>;
        }
    }
</code></pre></div><h3 id="the-kobayashi-maru">The <em>Kobayashi Maru</em></h3>
<p>As presented, if the player takes the first move against a perfect strategy, the player will invariably lose. For any of the three legal moves there exists a perfect counter to return the pot to the player as a multiple of 4. Inevitably the player will be presented with 4 tokens and be forced to take either 1,2 or 3 tokens, allowing the computer to draw the remainder of the pot.</p>
<p>Faced with an untenable situation leading to certain death, what is there to do? Frustrated, the player may enter 0, unwilling to meet their fate unchallenged.</p>
<blockquote>
<p>***&ldquo;Rage, rage against the dying of the light.&quot;***</p>
</blockquote>
<p>Surprisingly, this was often accepted, with the computer countering with either 1 token or a random draw, in any event yielding advantage, allowing the player to seize control and win.</p>
<p>In fact, many implementations skipped validating user input. One could argue that treating the source code as a black box and then discovering this ability after losing a few too many soul-crushing games can provide an important life lesson about assumptions, and this is itself more valuable than actually playing the game. Again the meta-game in context is more interesting than the rote process of the gameplay.</p>
<p>I&rsquo;m not going to name names or give examples in this section, as that would probably violate my own self-imposed rules for making these reviews, but certain people may consider their code and whether or not this concerns them.</p>
<h3 id="natural-language-programming">Natural Language Programming</h3>
<p><a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-104/athanasius/perl/ch-2.pl"><strong>Athanasius</strong></a>,
<a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-104/cheok-yin-fung/perl/ch-2.pl"><strong>Cheok-Yin Fung</strong></a>,
<a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-104/colin-crain/perl/ch-2.pl"><strong>Colin Crain</strong></a>,
<a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-104/jaldhar-h-vyas/perl/ch-2.pl"><strong>Jaldhar H. Vyas</strong></a>,
<a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-104/jo-37/perl/ch-2.pl"><strong>Jorg Sommrey</strong></a>, and
<a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-104/pete-houston/perl/ch-2.pl"><strong>Pete Houston</strong></a></p>
<p>With the ability to succinctly implement a winning strategy in a line or two, many submissions then went on to focus on the interactive portion of the challenge, trying to liven up the exchange into an improved user experience. To this end the prompts and  feedback to the user would change depending on the state of the game, or the input offered. The changes made were sometimes small and simple, such as whether or not to add an &ldquo;s&rdquo; to &ldquo;token&rdquo;, or much more complex, altering whole phrases.</p>
<p><a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-104/jaldhar-h-vyas/perl/ch-2.pl"><strong>Jaldhar H. Vyas</strong></a></p>
<p>Jaldar, for instance, is annoyed by improper pluralization. I mean, who wouldn&rsquo;t be? As such he has constructed a little purpose-built routine to amend his strings:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-perl" data-lang="perl">    <span style="color:#66d9ef">sub</span> <span style="color:#a6e22e">plural</span> {
        <span style="color:#66d9ef">my</span> ($word, $count) <span style="color:#f92672">=</span> @_;
        <span style="color:#66d9ef">return</span> $word <span style="color:#f92672">.</span> ($count <span style="color:#f92672">==</span> <span style="color:#ae81ff">1</span> ? <span style="color:#e6db74">q{}</span> : <span style="color:#e6db74">&#39;s&#39;</span>);
    }
</code></pre></div><p>Deployed, it looks like this:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-perl" data-lang="perl">    <span style="color:#66d9ef">my</span> $computerChoice <span style="color:#f92672">=</span> <span style="color:#ae81ff">4</span> <span style="color:#f92672">-</span> $playerChoice;
    say <span style="color:#e6db74">&#34;The computer picks $computerChoice &#34;</span>, plural(<span style="color:#e6db74">&#34;token&#34;</span>, $computerChoice);
    $tokens <span style="color:#f92672">-=</span> $computerChoice;
</code></pre></div><p>But we&rsquo;re just getting started.</p>
<p><a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-104/athanasius/perl/ch-2.pl"><strong>Athanasius</strong></a></p>
<p>The monk has noticed that as the play progresses, at the end there may not, for instance, be 3 tokens to draw, so allowing this option seems wrong. They have provided some nice corrections to the input request as the options diminish, reflected in the <code>@choices</code> array.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-perl" data-lang="perl">    <span style="color:#66d9ef">my</span>  @choices <span style="color:#f92672">=</span> $$tokens <span style="color:#f92672">&gt;=</span> <span style="color:#ae81ff">3</span> ? (<span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">2</span>, <span style="color:#ae81ff">3</span>) :
                   $$tokens <span style="color:#f92672">==</span> <span style="color:#ae81ff">2</span> ? (<span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">2</span>)    : <span style="color:#ae81ff">1</span>;
    <span style="color:#66d9ef">my</span>  $done    <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;

    <span style="color:#66d9ef">until</span> ($done)
    {
        printf <span style="color:#e6db74">&#39;   Enter your pick (%s): &#39;</span>, join <span style="color:#e6db74">&#39;, &#39;</span>, @choices;

        <span style="color:#66d9ef">my</span> $pick <span style="color:#f92672">=</span> <span style="color:#e6db74">&lt;STDIN&gt;</span>;

        <span style="color:#66d9ef">if</span> ($pick <span style="color:#f92672">=~</span><span style="color:#e6db74"> / ^ $RE{num}{int} $ /x</span> <span style="color:#f92672">&amp;&amp;</span> <span style="color:#ae81ff">0</span> <span style="color:#f92672">&lt;</span> $pick <span style="color:#f92672">&lt;=</span> $choices[ <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span> ])
        {
            $$tokens <span style="color:#f92672">-=</span> $pick;

            printf <span style="color:#e6db74">&#34;%d. %-8s picks %d. Tokens remaining: %2d\n&#34;</span>,
                $move, $name, $pick, $$tokens;

            $done <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>;
        }

        <span style="color:#66d9ef">print</span> <span style="color:#e6db74">&#34;   * Invalid entry, try again.\n&#34;</span> <span style="color:#66d9ef">unless</span> $done;
    }
</code></pre></div><p><a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-104/pete-houston/perl/ch-2.pl"><strong>Pete Houston</strong></a></p>
<p>Pete takes these steps to the next level with the introduction of <code>Lingua::EN::Inflexion</code>, Damien Conway&rsquo;s excellent module for adapting text content to the complexities of language, in this case English. All of the available phrases are configured by it, which allows such constructions as this one for stating the decision of a random roll:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-perl" data-lang="perl">    <span style="color:#75715e"># Choose who goes first</span>
    <span style="color:#66d9ef">my</span> $player <span style="color:#f92672">=</span> int rand <span style="color:#ae81ff">2</span>;
    <span style="color:#66d9ef">print</span> <span style="color:#e6db74">&#34;Why don&#39;t &#34;</span> <span style="color:#f92672">.</span> noun (<span style="color:#e6db74">&#39;she&#39;</span>)<span style="color:#f92672">-&gt;</span>singular ($player <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>) <span style="color:#f92672">.</span>
        <span style="color:#e6db74">&#34; go first this time?\n&#34;</span>;
</code></pre></div><p>This will, depending on the value of <code>$player</code>, produce either the sentence</p>
<p>&ldquo;Why don&rsquo;t I go first this time?&rdquo;</p>
<p>or</p>
<p>&ldquo;Why don&rsquo;t you go first this time?&rdquo;</p>
<p>Cool, huh?</p>
<p>Another example is this routine to state the value ofthe pot:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-perl" data-lang="perl">    <span style="color:#66d9ef">sub</span> <span style="color:#a6e22e">say_pot</span> {
        <span style="color:#66d9ef">my</span> $x <span style="color:#f92672">=</span> shift;
        <span style="color:#66d9ef">print</span> inflect (<span style="color:#e6db74">&#34;\n&lt;#d:$x&gt;There &lt;V:is&gt; $x &lt;N:token&gt; in the pot.\n&#34;</span>);
    }
</code></pre></div><p>The first tag establishes <code>$x</code> as the thing being counted. Depending on the value of <code>$x</code>, then, the verb &ldquo;is&rdquo; and the noun &ldquo;token&rdquo; are properly pluralized.</p>
<p><a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-104/colin-crain/perl/ch-2.pl"><strong>My Own Solution</strong></a></p>
<p>For my own solution I also brought in <code>Lingua::EN::Inflexion</code>, and once it was there inflected everything in sight. I also realized the running-out-of-tokens possibility and implemented a little operation to select the correct phrase at the end of the game. You might say I went to town on the whole thing.</p>
<p>I elected to implement that game <em>misère</em>, or forcing the opponent to take the last token, resulting in a loss. This is marginally more interesting, but not terribly so, as the objective becomes trying to deliver your opponent a single last token, which drags things out a little longer.</p>
<p>In other words towards the end of the game the pot will be depleted such that this change in the request will be necessary.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-perl" data-lang="perl">    <span style="color:#66d9ef">my</span> $request <span style="color:#f92672">=</span>
        $pot <span style="color:#f92672">&gt;</span> <span style="color:#ae81ff">2</span> ? <span style="color:#e6db74">&#34;1, 2 or 3 tokens.&#34;</span>
                 : $pot <span style="color:#f92672">&gt;</span> <span style="color:#ae81ff">1</span> ? <span style="color:#e6db74">&#34;1 or 2 tokens.&#34;</span>
                            : <span style="color:#e6db74">&#34;the token.&#34;</span>;

    say inflect(
        <span style="color:#e6db74">&#34;&lt;#d:$pot&gt;There &lt;V:is&gt;$now $pot &lt;N:token&gt; on the pot. Please draw $request&#34;</span>
    );

</code></pre></div><p>The underlying logic is now built on delivering your opponent a multiple of 4 <em>plus 1</em>, or 1, 5 or 9 tokens.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-perl" data-lang="perl">    $now <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34; now&#34;</span>;

    say inflect(
        <span style="color:#e6db74">&#34;&lt;#d:$pot&gt;
</span><span style="color:#e6db74">        There &lt;V:is&gt;$now $pot &lt;N:token&gt; in the pot. Computer will draw next.&#34;</span>
    );

    <span style="color:#66d9ef">my</span> $target <span style="color:#f92672">=</span> int(($pot<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>)<span style="color:#f92672">/</span><span style="color:#ae81ff">4</span>) <span style="color:#f92672">*</span> <span style="color:#ae81ff">4</span> <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>;
</code></pre></div><p>Another cute trick I pulled out was if you give the computer bogus input, it becomes less polite. Notice how on being forced to reiterate itself, &ldquo;There are now 9 tokens on the pot&rdquo; becomes &ldquo;There are 9 tokens on the pot&rdquo;, removing the &ldquo;now&rdquo;. Once the pot size changes it will be reinstated.</p>
<pre><code>    There are 12 tokens on the pot. Please draw 1, 2 or 3 tokens.
    2
    You drew two tokens.
    There are now 10 tokens in the pot. Computer will draw next.
    Computer draws one token.
    There are now 9 tokens on the pot. Please draw 1, 2 or 3 tokens.
    4
    Please take 1, 2 or 3 tokens.
    There are 9 tokens on the pot. Please draw 1, 2 or 3 tokens.
    3
    You drew three tokens.
    There are now 6 tokens in the pot. Computer will draw next.
    Computer draws one token.
    There are now 5 tokens on the pot. Please draw 1, 2 or 3 tokens.
    1
    You drew one token.
    There are now 4 tokens in the pot. Computer will draw next.
    Computer draws three tokens.
    There is now 1 token on the pot. Please draw the token.
    0
    Please take the token.
    There is 1 token on the pot. Please draw the token.
    no
    Please take the token.
    There is 1 token on the pot. Please draw the token.
    1
    You drew one token.
    Player loses.

</code></pre><p><a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-104/jo-37/perl/ch-2.pl"><strong>Jorg Sommrey</strong></a></p>
<p>Jorg also implemented an option to play the game either &ldquo;normal&rdquo; or &ldquo;misère&rdquo;, which required some adjustments to the language employed. You can see these options in the last lines of the code and the <code>token()</code> subroutine.</p>
<p>A flip-flop flag oscillates between two states in an <code>if/else</code> structure, for the player and computer moves. I do like the <code>redo</code> when validating input, as if to say: &ldquo;Go ahead, mess around. I can wait all day.&rdquo; Simple and direct.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-perl" data-lang="perl">    <span style="color:#66d9ef">while</span> ($tokens <span style="color:#f92672">&gt;</span> $misere) {
        say token($tokens);
        <span style="color:#66d9ef">my</span> $move;
        <span style="color:#66d9ef">if</span> (<span style="color:#f92672">++</span>$turn % 2) {
            once: {
                say <span style="color:#e6db74">&#39;How many?&#39;</span>;
                say(<span style="color:#e6db74">&#39;Invalid amount.&#39;</span>), <span style="color:#66d9ef">redo</span> <span style="color:#66d9ef">if</span> ($move <span style="color:#f92672">=</span> <span style="color:#e6db74">&lt;STDIN&gt;</span>) <span style="color:#f92672">!~</span> <span style="color:#e6db74">/^[123]$/</span>;
                say(token($tokens, <span style="color:#ae81ff">1</span>)), <span style="color:#66d9ef">redo</span> <span style="color:#66d9ef">if</span> $move <span style="color:#f92672">&gt;</span> $tokens;
            }
        } <span style="color:#66d9ef">else</span> {
            $move <span style="color:#f92672">=</span> ($tokens <span style="color:#f92672">-</span> $misere) % 4 <span style="color:#f92672">||</span> <span style="color:#ae81ff">1</span> <span style="color:#f92672">+</span> int rand <span style="color:#ae81ff">3</span>;
            say <span style="color:#e6db74">&#34;I take $move.&#34;</span>;
        }
        $tokens <span style="color:#f92672">-=</span> $move;
    }
    say <span style="color:#e6db74">&#39;The last token is &#39;</span>, <span style="color:#e6db74">qw(mine. yours.)</span>[($turn <span style="color:#f92672">+</span> $tokens) % 2];
    say <span style="color:#e6db74">qw(I You)</span>[($turn <span style="color:#f92672">+</span> $tokens <span style="color:#f92672">+</span> $misere) % 2], <span style="color:#e6db74">&#39; win.&#39;</span>;

    <span style="color:#66d9ef">sub</span> <span style="color:#a6e22e">token</span> ($n, $r=0) {
        <span style="color:#66d9ef">my</span> @p <span style="color:#f92672">=</span> $n <span style="color:#f92672">&gt;</span> <span style="color:#ae81ff">1</span> ? (<span style="color:#e6db74">&#39;are&#39;</span>, <span style="color:#e6db74">&#39;s&#39;</span>) : (<span style="color:#e6db74">&#39;is&#39;</span>, <span style="color:#e6db74">&#39;&#39;</span>);
        splice @p, <span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">0</span>, <span style="color:#e6db74">&#39; only&#39;</span> x $r, $n;
        splice @p, <span style="color:#ae81ff">4</span>, <span style="color:#ae81ff">0</span>, <span style="color:#e6db74">&#39; remaining&#39;</span> x $r;

        sprintf <span style="color:#e6db74">&#34;There %s%s %d token%s%s.&#34;</span>, @p;
    }
</code></pre></div><p><a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-104/cheok-yin-fung/perl/ch-2.pl"><strong>Cheok-Yin Fung</strong></a></p>
<p>Finally, the &ldquo;good sportsmanship&rdquo; award goes to CY, for having the thought to complement the player after the match. It&rsquo;s the little things in life that elevate us from the savages. Bravo.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-perl" data-lang="perl">    <span style="color:#66d9ef">sub</span> <span style="color:#a6e22e">endgame</span> {
        <span style="color:#66d9ef">my</span> $winner <span style="color:#f92672">=</span> $_[<span style="color:#ae81ff">0</span>];
        <span style="color:#66d9ef">print</span> <span style="color:#e6db74">&#34;The winner is &#34;</span>;
        <span style="color:#66d9ef">if</span> ($winner <span style="color:#f92672">==</span> $player) {
            <span style="color:#66d9ef">print</span> <span style="color:#e6db74">&#34;YOU. \n&#34;</span>
        }
        <span style="color:#66d9ef">else</span> {
            <span style="color:#66d9ef">print</span> <span style="color:#e6db74">&#34;the computer. \n&#34;</span>
        }
        <span style="color:#66d9ef">print</span> <span style="color:#e6db74">&#34;Good game. \n&#34;</span>;
        exit;
    }
</code></pre></div><h3 id="working-through-the-options-all-the-options">Working Through the Options. <em>All</em> the Options.</h3>
<p><a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-104/alexander-karelas/perl/ch-2.pl"><strong>Alexander Karelas</strong></a></p>
<p>Alexander gives a very unusual and novel approach, in that at every stage he draws on the result of a recursive function that works through all possible outcomes of the gameplay going forward to determine the optimal move. Rather than isolating and directly selecting the best move from the limited states available, like everybody else, he instead <em>derives</em> the best plan forward at every step by stepping through an increasingly constrained group of games, selecting the move that leads to the best chance on winning.</p>
<p>I&rsquo;m quite glad someone solved it this way, and here is the logic:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-perl" data-lang="perl">    <span style="color:#66d9ef">sub</span> <span style="color:#a6e22e">position_value</span> ($n) {
        <span style="color:#66d9ef">if</span> ($n <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>) {
            <span style="color:#66d9ef">return</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>;
        }

        <span style="color:#66d9ef">my</span> @move_values;
        <span style="color:#66d9ef">for</span> <span style="color:#66d9ef">my</span> $move (<span style="color:#ae81ff">1</span> <span style="color:#f92672">..</span> min(<span style="color:#ae81ff">3</span>, $n)) {
            $move_values[$move] <span style="color:#f92672">=</span> <span style="color:#f92672">-</span> position_value($n <span style="color:#f92672">-</span> $move);
        }

        <span style="color:#66d9ef">return</span> max(grep defined, @move_values);
    }

    <span style="color:#66d9ef">sub</span> <span style="color:#a6e22e">best_move</span> ($n) {
        <span style="color:#66d9ef">my</span> $pos_value <span style="color:#f92672">=</span> position_value($n);
        <span style="color:#66d9ef">my</span> @best_moves <span style="color:#f92672">=</span> grep position_value($n <span style="color:#f92672">-</span> $_) <span style="color:#f92672">==</span> <span style="color:#f92672">-</span> $pos_value, (<span style="color:#ae81ff">1</span> <span style="color:#f92672">..</span> min(<span style="color:#ae81ff">3</span>, $n));
        <span style="color:#66d9ef">return</span> $best_moves[int rand @best_moves];
    }
</code></pre></div><hr>
<h1 id="PWC104BLOGS">BLOGS</h1>
<hr>
<p><strong>That’s it for me this week, people! Warped by the rain, driven by the snow, resolute and unbroken by the torrential influx, I somehow continue to maintain my bearings. Looking forward to next wave, the perfect wave, I am: <em>your humble servant</em>.</strong></p>
<h1 id="PWC093BLOGS">But if Your <em>THIRST</em> for <em>KNOWLEDGE</em> is not <em>SLAKED</em>,</h1>
<h1 id="then-run-dont-walk-to-the-watering-hole">then <em>RUN</em> <em>(dont walk!)</em> to the <em>WATERING HOLE</em></h1>
<h1 id="and-read-these-blog-links">and <em>READ</em> these <em>BLOG</em> <em>LINKS</em>:</h1>
<p><strong>( <em>don&rsquo;t think, trust your training, you&rsquo;re in the zone, just do it &hellip;</em> )</strong></p>
<p><strong>Aaron Smith</strong></p>
<ul>
<li><a href="https://aaronreidsmith.github.io/blog/perl-weekly-challenge-104/">Perl Weekly Challenge 104 - Aaron Smith</a> ( <em>Raku</em> )</li>
</ul>
<p><strong>Abigail</strong></p>
<ul>
<li><a href="https://wp.me/pcxd30-vx">Perl Weekly Challenge 104: FUSC Sequence — Abigail&rsquo;s Programming Blog</a> ( <em>Perl</em> )</li>
<li><a href="https://wp.me/pcxd30-w5">Perl Weekly Challenge 104: NIM Game — Abigail&rsquo;s Programming Blog</a> ( <em>Perl</em> )</li>
</ul>
<p><strong>Arne Sommer</strong></p>
<ul>
<li><a href="https://raku-musings.com/nimbly-fuscous.html">Nimbly Fuscous with Raku</a> ( <em>Raku</em> )</li>
</ul>
<p><strong>Dave Jacoby</strong></p>
<ul>
<li><a href="https://jacoby.github.io/2021/03/15/fuscing-tokens-perl-weekly-challenge-104.html">FUSCing Tokens: Perl Weekly Challenge 104 | Committed to Memory</a> ( <em>Perl</em> )</li>
</ul>
<p><strong>Flavio Poletti</strong></p>
<ul>
<li><a href="https://github.polettix.it/ETOOBUSY/2021/03/17/pwc104-fusc-sequence/">PWC104 - FUSC Sequence - ETOOBUSY</a> ( <em>Perl</em> )</li>
<li><a href="https://github.polettix.it/ETOOBUSY/2021/03/18/pwc104-nim-game/">PWC104 - NIM Game - ETOOBUSY</a> ( <em>Perl</em> )</li>
</ul>
<p><strong>Jaldhar H. Vyas</strong></p>
<ul>
<li><a href="https://www.braincells.com/perl/2021/03/perl_weekly_challenge_week_104.html">Perl Weekly Challenge: Week 104</a> ( <em>Perl &amp; Raku</em> )</li>
</ul>
<p><strong>James Smith</strong></p>
<ul>
<li><a href="http://blogs.perl.org/users/james_curtis-smith/2021/03/perl-weekly-challenge-104.html">Perl weekly challenge 104 | James Curtis-Smith</a> ( <em>Perl</em> )</li>
</ul>
<p><strong>Laurent Rosenfeld</strong></p>
<ul>
<li><a href="http://blogs.perl.org/users/laurent_r/2021/03/perl-weekly-challenge-104-fusc-sequence-and-nim-game.html">Perl Weekly Challenge 104: Fusc Sequence and NIM Game | laurent_r</a> ( <em>Perl &amp; Raku</em> )</li>
</ul>
<p><strong>Luca Ferrari</strong></p>
<ul>
<li><a href="https://fluca1978.github.io/2021/03/15/PerlWeeklyChallenge104.html#task1">Perl Weekly Challenge 104: recursion and picking – Luca Ferrari</a> ( <em>Raku</em> )</li>
<li><a href="https://fluca1978.github.io/2021/03/15/PerlWeeklyChallenge104.html#task2">Perl Weekly Challenge 104: recursion and picking – Luca Ferrari – Open Source advocate, human being</a> ( <em>Raku</em> )</li>
</ul>
<p><strong>Roger Bell_West</strong></p>
<ul>
<li><a href="https://blog.firedrake.org/archive/2021/03/Perl_Weekly_Challenge_104__FUSC_NIM.html">RogerBW&rsquo;s Blog: Perl Weekly Challenge 104: FUSC NIM</a> ( <em>Perl &amp; Raku</em> )</li>
</ul>

                </div>
            </div>
        </div>
    </div>
</section>


<!-- Call To Action Section Start -->
<section id="call-to-action">
    <div class="container">
        <div class="row">
            <div class="col-md-12">
                <div class="block">
                    <h2 class="title wow fadeInDown" data-wow-delay=".3s" data-wow-duration="500ms">SO WHAT DO YOU THINK ?</h2>
                    <p class="wow fadeInDown" data-wow-delay=".5s" data-wow-duration="500ms">If you have any suggestions or ideas then please do share with us.</p>
                    <a href="/contact" class="btn btn-default btn-contact wow fadeInDown" data-wow-delay=".7s" data-wow-duration="500ms">Contact with me</a>
                </div>
            </div>

        </div>
    </div>
</section>
<!-- Call To Action Section End -->



<!-- Footer Section Start -->
<footer id="footer">
    <div class="container">
        <div class="row content-justify-between">
            <div class="col-md-8 col-12 text-center text-lg-left text-md-left">
                <p class="copyright">Copyright:
                    <span>
                        2019 - 2021
                    </span> The Weekly Challenge. Theme Design and Developed by
                    <a href="http://www.Themefisher.com" rel="noreferrer" rel="noreferrer" target="_blank">Themefisher</a>.
                </p>
            </div>
            <div class="col-md-4 col-12">
                <!-- Social Media -->
                <ul class="social text-center text-md-right text-lg-right">
                    <li>
                        <a href="https://twitter.com/PerlWChallenge" class="twitter" rel="noreferrer" target="_blank" title="Follow us">
                            <i class="ion-social-twitter"></i>
                        </a>
                    </li>
                    <li>
                        <a href="/rss.xml" class="rss" target="_blank" title="RSS Feed">
                            <i class="ion-social-rss"></i>
                        </a>
                    </li>
                    <li>
                        <a href="https://www.nomtimes.co.uk/site/shop.do?cref=PerlBooks" title="Free Perl Books" rel="noreferrer" target="_blank">
                            <img src="/images/NomTimes.jpg" style="width:22px; height: 18px;" alt=""/>
                        </a>
                    </li>
                </ul>
            </div>
        </div>
    </div>
</footer>
<!-- footer section end -->

<!-- jquery -->
<script src="https://theweeklychallenge.org/plugins/jQurey/jquery.min.js"></script>
<!-- Form Validation -->
<script src="https://theweeklychallenge.org/plugins/form-validation/jquery.form.min.js"></script>
<script src="https://theweeklychallenge.org/plugins/form-validation/jquery.validate.min.js"></script>
<!-- slick slider -->
<script src="https://theweeklychallenge.org/plugins/slick/slick.min.js"></script>
<!-- bootstrap js -->
<script src="https://theweeklychallenge.org/plugins/bootstrap/bootstrap.min.js"></script>
<!-- chart js -->
<script src="https://theweeklychallenge.org/plugins/chart/highstock.js"></script>
<script src="https://theweeklychallenge.org/plugins/chart/drilldown.js"></script>
<script src="https://theweeklychallenge.org/plugins/chart/data.js"></script>
<script src="https://theweeklychallenge.org/plugins/chart/chart.js"></script>
<script src="https://theweeklychallenge.org/plugins/chart/pwc-challenge.js"></script>
<script src="https://theweeklychallenge.org/plugins/chart/gc-challenge.js"></script>
<!-- wow js -->
<script src="https://theweeklychallenge.org/plugins/wow-js/wow.min.js"></script>
<!-- slider js -->
<script src="https://theweeklychallenge.org/plugins/slider/slider.js"></script>
<!-- Fancybox -->
<script src="https://theweeklychallenge.org/plugins/facncybox/jquery.fancybox.js"></script>
<!-- template main js -->

<script src="https://theweeklychallenge.org/js/script.min.js"></script>
<!-- google analitycs -->
<script>
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
    (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
    m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
    ga('create', 'UA-136524905-1', 'auto');
    ga('send', 'pageview');
</script>
</body>

</html>

