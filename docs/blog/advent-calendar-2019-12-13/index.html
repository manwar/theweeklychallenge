<!DOCTYPE html>
<html class="no-js" lang="en-us">
<head>
    <!-- Basic Page Needs -->

    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta property="og:title"       content="The Weekly Challenge - Perl & Raku"/>
    <meta property="og:type"        content="website"/>
    <meta property="og:url"         content="https://perlweeklychallenge.org/"/>
    <meta property="og:image"       content="https://perlweeklychallenge.org/images/about/about.jpg"/>
    <meta property="og:description" content="You do not have to be an expert."/>
    <meta name="twitter:card"       content="summary" />
    <meta name="twitter:image"      content="https://perlweeklychallenge.org/images/about/about.jpg"/>

    <meta http-equiv="Content-Type" content="text/html; charset=utf-8">

    <meta name="description" content="Advent Calendar - December 13, 2019">
    <meta name="author" content="Perl Weekly Challenge Team">
    <meta name="generator" content="Hugo 0.66.0-DEV" />

    <!-- Mobile Specific Metas -->
    <meta name="format-detection" content="telephone=no">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>Advent Calendar - December 13, 2019</title>
    <link rel="icon" href="https://perlweeklychallenge.org/images/favicon.ico">

    
    <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.0/css/bootstrap.min.css"/>

    <!-- Twitter Bootstrs CSS -->
    <link rel="stylesheet" href="https://perlweeklychallenge.org/plugins/bootstrap/bootstrap.min.css">
    <!-- Ionicons Fonts Css -->
    <link rel="stylesheet" href="https://perlweeklychallenge.org/plugins/ionicons/ionicons.min.css">
    <!-- animate css -->
    <link rel="stylesheet" href="https://perlweeklychallenge.org/plugins/animate-css/animate.css">
    <!-- Hero area slider css-->
    <link rel="stylesheet" href="https://perlweeklychallenge.org/plugins/slider/slider.css">
    <!-- slick slider -->
    <link rel="stylesheet" href="https://perlweeklychallenge.org/plugins/slick/slick.css">
    <!-- Fancybox -->
    <link rel="stylesheet" href="https://perlweeklychallenge.org/plugins/facncybox/jquery.fancybox.css">
    <!-- hover -->
    <link rel="stylesheet" href="https://perlweeklychallenge.org/plugins/hover/hover-min.css">
    <!-- template main css file -->
    
    <link rel="stylesheet" href="https://perlweeklychallenge.org/css/style.min.css" integrity="" media="screen">
    <link rel="stylesheet" href="https://perlweeklychallenge.org/css/main.css">
</head>

<body>

<section class="top-bar animated-header">
    <div class="container">
        <div class="row">
            <div class="col-lg-12">
                <nav class="navbar navbar-expand-lg navbar-light bg-light">
                    <a class="navbar-brand" href="https://perlweeklychallenge.org/">
                        <img src="https://perlweeklychallenge.org/images/logo.svg" alt="logo">
                    </a>
                    <button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navgation" aria-controls="navigation"
                        aria-expanded="false" aria-label="Toggle navigation">
                        <span class="navbar-toggler-icon"></span>
                    </button>

                    <div class="collapse navbar-collapse" id="navigation">
                        <ul class="navbar-nav ml-auto">
                            <li class="nav-item">
                                <a class="nav-link" href="https://perlweeklychallenge.org/">Home</a>
                            </li>
                            
                            <li class="nav-item">
                                <a class="nav-link" href="https://perlweeklychallenge.org/about">About</a>
                            </li>
                            
                            <li class="nav-item">
                                <a class="nav-link" href="https://perlweeklychallenge.org/chart">Chart</a>
                            </li>
                            
                            <li class="nav-item">
                                <a class="nav-link" href="https://perlweeklychallenge.org/champions">Champions</a>
                            </li>
                            
                            <li class="nav-item">
                                <a class="nav-link" href="https://perlweeklychallenge.org/team">Team</a>
                            </li>
                            
                            <li class="nav-item">
                                <a class="nav-link" href="https://perlweeklychallenge.org/challenges">Challenges</a>
                            </li>
                            
                            <li class="nav-item">
                                <a class="nav-link" href="https://perlweeklychallenge.org/p5-reviews">Perl/Review</a>
                            </li>
                            
                            <li class="nav-item">
                                <a class="nav-link" href="https://perlweeklychallenge.org/p6-reviews">Raku/Review</a>
                            </li>
                            
                            <li class="nav-item">
                                <a class="nav-link" href="https://perlweeklychallenge.org/recaps">Recaps</a>
                            </li>
                            
                            <li class="nav-item">
                                <a class="nav-link" href="https://perlweeklychallenge.org/blogs">Blogs</a>
                            </li>
                            
                            <li class="nav-item">
                                <a class="nav-link" href="https://perlweeklychallenge.org/faq">FAQ</a>
                            </li>
                            
                            <li class="nav-item">
                                <a class="nav-link" href="https://perlweeklychallenge.org/contact">Contact</a>
                            </li>
                            
                        </ul>
                    </div>
                </nav>
            </div>
        </div>
    </div>
</section>


<section class="global-page-header">
    <div class="container">
        <div class="row">
            <div class="col-md-12">
                <div class="block">
                    <h2>Advent Calendar - December 13, 2019</h2>
                    <div class="portfolio-meta">
                        <span>Friday, Dec 13, 2019</span>|
                        <span> Tags:
                            Perl
                        </span>
                    </div>
                </div>
            </div>
        </div>
    </div>
</section>

<section class="single-post">
    <div class="container">
        <div class="row">
            <div class="col-md-12">
                
                <div style="text-align: center" class="post-img">
                    <img class="img-fluid" alt="" src="https://perlweeklychallenge.org/images/blog/2019-12-13.jpg">
                </div>
                
                <div style="text-align: justify" class="post-content">
                    <p><a href="/blog/advent-calendar-2019"><strong>Advent Calendar 2019</strong></a></p>
<hr>
<p>The gift is presented by <a href="/blog/meet-the-champion-034"><strong>Burkhard Nickels</strong></a>. Today he is talking about his solutions to <strong>Task #1: Demonstrate Array/Hash Slices** of </strong>&ldquo;The Weekly Challenge - 034&rdquo;**<a href="/blog/perl-weekly-challenge-034"></a>.</p>
<hr>
<h4 id="demonstrate-array-slices-or-hash-slices">Demonstrate Array Slices or Hash slices.</h4>
<hr>
<p>\</p>
<p>To demonstate some different Array and Hash slicing features I do some image processing. An image is &ldquo;data&rdquo; that can be stored in 2- or 3-dimensional Arrays. To separate the data I will store the data in Hashes (Named Lists). For example a coloured image can be separated in its &lsquo;red&rsquo;, &lsquo;green&rsquo; and &lsquo;blue&rsquo; parts.</p>
<p>The source is a miraculous colored image from my son. This example creates a new miracle image (Some odd inheritance). I go two ways to solve it: (A) First I use PDL, the Perl Data Language. With PDL you can simply calculate big arrays of data. All operators can be used directly on the Piddle (PDL object). (B) Second I use Perl Arrays.</p>
<p>The steps done in this example are:</p>
<ol>
<li>Reading Image from PNG file: Using Hash</li>
<li>Separate RGB and Bit Plane: Hash Slices</li>
<li>Extract hidden image from Bit 0: Hash Slice</li>
<li>Write hidden image to file: PDL::NiceSlice</li>
<li>Comparision of execution time</li>
</ol>
<h2 id="synopsis">SYNOPSIS</h2>
<pre><code># perldoc ch-1.pl              - POD
./ch-1.pl &lt;command&gt;

# ./ch-1.pl pdl                - Creates Hidden Grayscale from Colored Image
# ./ch-1.pl array              - Array Version does NOT work properly
# ./ch-1.pl html               - HTML/CSS in ch-1.html/pwc.css
# ./ch-1.pl help               - Usage information
</code></pre>
<h2 id="1-reading-image-from-png-file-general-usage-of-a-hash">1) Reading Image from PNG file: General Usage of a Hash</h2>
<p>A Hash is a List of Key/Value pairs, so that values can be accessed easily by a name (key). In Perl a Hash is declared with a percent sign &ldquo;%&rdquo; (i.e. %hash) in front of the name. The Hash can be initialized with key/value pairs.</p>
<pre><code>%hash = ( key =&gt; $value, ... );       # Initialize Hash
$hash{ key } = $value;                # Assign Value to Hash Element
$var = $hash{ key };                  # Get Hash Value of Key
</code></pre>
<p>As example I read a PNG file and store every needed parameter in a hash. In the below example the keys base (basename of file), file (filename) and data (read PDL data) are used.</p>
<pre><code>my %image = (                          # Initialize Hash
    base =&gt; &quot;miraculous-image-400x533&quot;,
    file =&gt; &quot;miraculous-image-400x533.png&quot;,
);
$image{data} = read_png($image{file}); # Assign Value to Hash Element
info_pdl($image{data},$image{file});   # Use Hash Values
</code></pre>
<p><img src="/images/blog/miraculous-image-400x533.png" alt="miraculous-image-400x533.png"></p>
<h2 id="2-separating-rgb-and-bit-plane">2) Separating RGB and Bit Plane</h2>
<h3 id="hash-slice">Hash Slice</h3>
<p>A Hash Slice represents more Hash elements at once. The At (@) sign is used to represent a hash slice.</p>
<pre><code>@list = @hash{'key1','key2'};          # Access Hash Slice
@hash{ 'key1','key2','key3' } = ...;   # Assignment of Values to Hash Slice
</code></pre>
<h3 id="a-separation-with-pdl">A. Separation with PDL</h3>
<p>In the example below we assign the RGB layers of the image to a Hash Slice. The rgb() function is doing it for us. Then we create a Hash Element named &ldquo;bit_plane&rdquo; and assign the bit planes (an array) of each color to the Hash Slice (&lsquo;red&rsquo;,&lsquo;green&rsquo;,&lsquo;blue&rsquo;). This is done with the function bit_plane().</p>
<pre><code>@image{ 'red','green','blue' } = rgb($image{data}); # Assigning values to Hash slice

my @colors = ('red','green','blue');
@{ $image{bit_plane} }{ @colors } = (   # Assigning values to Hash Slice
    [ bit_plane($image{red}) ],
    [ bit_plane($image{green}) ],
    [ bit_plane($image{blue}) ],
);
</code></pre>
<h3 id="b-separation-with-array">B. Separation with Array</h3>
<p>Because we read the PNG file with PDL mechanisms, first we need to change the PDL object into an array. This we do with exchanging the order of the dimensions with PDL xchg(0,2) and with PDL unpdl() function.</p>
<p>Also for the Array-Solution we implemented a rgb_array() function that is separating the 3 RGB channels. Than the bit_plane_array() function is creating the Bit Planes</p>
<pre><code>my $tmp1 = $image{data}-&gt;xchg(0,2);
$image{array} = $tmp1-&gt;unpdl;

@image{ 'red','green','blue' } = rgb_array($image{array});

my @colors = ('red','green','blue');
@{ $image{bit_plane} }{ @colors } = (   # Bit Plane
    bit_plane_array($image{red}),
    bit_plane_array($image{green}),
    bit_plane_array($image{blue}),
);
</code></pre>
<h3 id="bit-plane">Bit Plane</h3>
<p>The following 3 Images are an extract of the previous operations. Every Pixel can have a value range from 0 - 255.</p>
<p>For the third image, Bit Mask on Bit 0 of Bit Plane, to make it visible I multiplied it with 255. Normally the values are only 0 / 1, so it would be a black image. When multiplied with 255, value 1 becomes 255, value 0 is still value 0. On the Green channel, Bit 6 of the hidden Image is available.</p>
<ol>
<li>Green Channel only. Green Value Range from 0 - 255.</li>
</ol>
<p><img src="/images/blog/miraculous-green.png" alt="miraculous-green.png"></p>
<ol start="2">
<li>Green Channel Bit 7 of Bit Plane. Only Value 0 / 128, because of Bit Mask on Bit 7.</li>
</ol>
<p><img src="/images/blog/miraculous-green-bit7.png" alt="miraculous-green-bit7.png"></p>
<ol start="3">
<li>Green Channel Bit 0 of Bit Plane, multiplied with 255.</li>
</ol>
<p><img src="/images/blog/miraculous-green-bit0.png" alt="miraculous-green-bit0.png"></p>
<h3 id="about-image-data">About Image Data</h3>
<p>The miraculous image has a size of 3x400x533. The image has a size width x height of 400x533 and is composed of 3 color values red/green/blue (RGB). Each value has 8 Bit means decimal from 0 to 255. One Red Pixel for example has the R/G/B values of 255/0/0.</p>
<p>When we first separate the RGB values, we assign to $image{red} an image of 400x533 only red pixel values. Afterwards we separate all 8 bit planes.</p>
<p>The 8 Bit Value of 255 is a binary value of 0b11111111. Separating the 8 bit planes means we create an array of only Bit 0 (LSB), only Bit 1, &hellip;, only Bit 7 (MSB). So the bit plane of Bit 7 can have value 0 or 1, means in decimal 0 or 128 (because of MSB).</p>
<p>Representation of Bits and Significancy:</p>
<pre><code>Bit Number:    (MSB) 7           6           5           4   3  2  1  0 (LSB)
Binary Value:        0b10000000, 0b01000000, 0b00100000, ...
Decimal Value:       128,        64,         32,         16, 8, 4, 2, 1
</code></pre>
<p>So the most information of an image is in the highest bits. Only with Bits 5-7 it is possible to get a visible image out of the data. In Bit 0 is the least information of the image, this is rather some image noise in the LSB.</p>
<h2 id="3-compose-hidden-image-from-bit-0">3) Compose hidden image from Bit 0</h2>
<p>So in Bit 0 (Least Significant, Noise) of each RGB Value you can hide the Bits 5-7 (Most Significant) of another image. I separated a grayscale image in its bit plane and put these 3 bit planes from Bit 5-7 into the Bit 0 of the RGB. To extract the hidden image the process is vice versa.</p>
<p>The Bits extracted from the coloured image are in Bit position 0, means they need to be shifted to their original position. That is Bit 7/6/5. For this we can use the &ldquo;Shift&rdquo; &laquo; operator. Than the 3 Bytes with their proper position must be binary ORed with the OR | operator. Both operator exist in PDL as well for Scalars.</p>
<h3 id="a-compose-hidden-image-with-pdl">A. Compose hidden image with PDL</h3>
<p>With PDL a whole Matrix can be Shifted and ORed at once. This is done in one single line.</p>
<pre><code>my %hidden;
@hidden{ 'bit7','bit6','bit5' } = (
    $image{bit_plane}{red}[0],
    $image{bit_plane}{green}[0],
    $image{bit_plane}{blue}[0],
);
$hidden{data} = ($hidden{bit7} &lt;&lt; 7) | ($hidden{bit6} &lt;&lt; 6) | ($hidden{bit5} &lt;&lt; 5);
</code></pre>
<p>The first 3 PNG files are from @hidden{&lsquo;bit7&rsquo;,&lsquo;bit6&rsquo;,&lsquo;bit5&rsquo;}, all three multiplied with 255. In the code above each image (bit position) is shifted up to the proper position for the resulting image. The fourth image is from $hidden{data}, and is the composed image out of the other three.</p>
<p><img src="/images/blog/miraculous-red-bit7.png" alt="miraculous-red-bit7.png"></p>
<p><img src="/images/blog/miraculous-grn-bit6.png" alt="miraculous-grn-bit6.png"></p>
<p><img src="/images/blog/miraculous-blu-bit5.png" alt="miraculous-blu-bit5.png"></p>
<p><img src="/images/blog/miraculous-grey.png" alt="miraculous-grey.png"></p>
<h3 id="b-compose-hidden-image-with-array">B. Compose hidden image with Array</h3>
<p>With a Perl Array we must iterate through every element to shift and OR every single element. I implemented the recreate() function for this task.</p>
<p>The recreate() function puts the bits 7/6/5 together to one image. The perl array is converted back to a PDL object, because we write the data to a PNG file with PDL. The PDL xchg() function has to exchange the dimensions of the data.</p>
<pre><code>@hidden{ 'bit7','bit6','bit5' } = (
    $image{bit_plane}{red}[0],
    $image{bit_plane}{green}[0],
    $image{bit_plane}{blue}[0],
);
my $tmp1 = recreate(@hidden{'bit7','bit6','bit5'});

my $tmp2 = pdl(byte(),$tmp1);
$hidden{data} = $tmp2-&gt;xchg(0,1);
</code></pre>
<h3 id="res--recreatebit7bit6bit5">$res = recreate($bit7,$bit6,$bit5)</h3>
<p>To put Bits 7/6/5 together I have to iterate through every value of that image matrix (array). Each bit needs to be shifted from bit position 0 (LSB) to the appropriate position (7/6/5). Afterwards the Bytes with the proper bit position needs to be binary ORed to one value. This one value is stored in the resulting array at its indices.</p>
<pre><code>sub recreate {
    my ($bit7,$bit6,$bit5) = @_;
    my @res;
    for( my $w=0; $w&lt;=$#$bit7; $w++ ) {   # Iterate Column
            my $col = $bit7-&gt;[$w];
            for( my $h=0; $h&lt;=$#$col; $h++ ) {  # Iterate Row
                    my $v7 = $bit7-&gt;[$w][$h] &lt;&lt; 7;  # Shift to Bit 7
                    my $v6 = $bit6-&gt;[$w][$h] &lt;&lt; 6;  # Shift to Bit 6
                    my $v5 = $bit5-&gt;[$w][$h] &lt;&lt; 5;  # Shift to Bit 5
                    $res[$w][$h] = $v7 | $v6 | $v5; # Binary OR
            }
    }
    return \@res;    # Return resulting image
}
</code></pre>
<h2 id="4-write-hidden-image-to-file-pdlniceslice">4) Write hidden image to file: PDL::NiceSlice</h2>
<p>The hidden image was a grayscale with size 200x265. So I create an empty PDL object with this size and assign a PDL::NiceSlice of that size from the composed data. Afterwards the data is written to file.</p>
<pre><code>$hidden{slice} = zeroes(byte(),200,265);
my $tmp = $hidden{data};
$hidden{slice} .= $tmp(0:199,0:264);
write_png($hidden{slice},&quot;hidden-200x265.png&quot;);
</code></pre>
<p>So this is our final result:</p>
<p><img src="/images/blog/hidden-pdl-200x265.png" alt="hidden-pdl-200x265.png"></p>
<h2 id="5-comparision-of-execution-time">5) Comparision of Execution Time</h2>
<p>The measurement of the time to extract the hidden image from the vessel results in 4.52 sec for the Array Solution and 0.06 sec for the PDL Solution. Details see below.</p>
<h3 id="a-execution-time-of-array-solution">A. Execution Time of Array Solution:</h3>
<pre><code>./ch-1.pl array
ch-1.pl (Version 1.0) PWC #34 Task #1: Argument - array
TIME: read_png(): 0.029254
TIME: read_image: 0.0293169021606445
TIME: bit_plane_array(): 1.379272
TIME: bit_plane_array(): 1.385368
TIME: bit_plane_array(): 1.380695
TIME: extract_bit_plane: 4.21236300468445
TIME: create_hidden: 0.25209
Write PNG file hidden-array-200x265.png
TIME: write_png(): 0.029869
    hidden-array-200x265.png:  Type byte (0) Dims 2 (200/265) #Ele 53000 Sum  6348672
TIME: main(): 4.524511
</code></pre>
<h3 id="b-execution-time-of-pdl-solution">B. Execution Time of PDL Solution:</h3>
<pre><code>./ch-1.pl pdl
ch-1.pl (Version 1.0) PWC #34 Task #1: Argument - pdl
TIME: read_png(): 0.028898
TIME: read_image: 0.0289709568023682
TIME: bit_plane(): 0.003825
TIME: bit_plane(): 0.003659
TIME: bit_plane(): 0.003666
TIME: extract_bit_plane: 0.0113928318023682
TIME: create_hidden: 0.00251
Write PNG file hidden-pdl-200x265.png
TIME: write_png(): 0.018439
    hidden-pdl-200x265.png:  Type byte (0) Dims 2 (200/265) #Ele 53000 Sum  6348672
TIME: main(): 0.062353
</code></pre>
<h3 id="basic-functions">Basic Functions</h3>
<p>Some basic functions are used in this example.</p>
<pre><code>$data = one_color($rgb_data,$color);    # Creates rgb image from one color channel
$data = read_png($filename);            # Reads image data from PNG file.
write_png($data,$filename);             # Writes image data to PNG file.
@bit_planes = bit_plane($data,$type);   # Separates bit planes.
$bit_planes = bit_plane_array($data,$type); # Separates bit planes.
($red,$green,$blue) = rgb($data);       # Separates red/green/blue from Color Image.
($red,$green,$blue) = rgb_array($data); # Separates red/green/blue from Color Image.
info_array($array_ref);                 # Prints Array Size to STDOUT.
info_pdl($data,$title);                 # Prints PDL Info to STDOUT.
</code></pre>
<p>Because two different solutions are implemented in this script, I wanted to compare both related to time behaviour. For this reason I used the module Time::HiRes. The following code I inserted to measure the time.</p>
<pre><code>use Time::HiRes qw(gettimeofday tv_interval);
...

my $t0 = [gettimeofday];

... (measured code)

my $t1 = [gettimeofday];
my $td = tv_interval $t0, $t1;
print &quot;TIME: bit_plane(): $td\n&quot;;
</code></pre>
<h3 id="data--one_colorrgb_datacolor">$data = one_color($rgb_data,$color)</h3>
<p>The function one_color() creates a RGB image with one color channel set to its value, but the two other colors are set to zero. This is done to better visualize the splitted channels of a RGB image.</p>
<pre><code>sub one_color {
    my ($img,$color) = @_;   # $color = red|green|blue

    # ------- Create image data of same dimension with only zeroes
    my $result = zeroes(byte(),3,$img-&gt;dims);

    # ------- Assign image data to choosen channel
    my %c = ( red=&gt;0, green=&gt;1, blue=&gt;2 );
    for(my $i=0; $i&lt;3; $i++) {
            if($i == $c{$color}) { $result(($i),:,:) .= $img; }     # PDL::NiceSlice
    }
    return ($result); # Return new image
}
</code></pre>
<h3 id="data--read_pngfilename">$data = read_png($filename);</h3>
<p>Reads an image file with PNG format and returns the PDL data.</p>
<pre><code>sub read_png {
    my ($png) = @_;
    my $cr = PDL-&gt;rpiccan('PNG');   # is PNG format allowed
    if(! $cr ) { print &quot;Error (read): Png not allowed!\n&quot;; return 0; }
    my $tmp = PDL::IO::Pic::rpic($png, {FORMAT =&gt; 'PNG'}); # read image
}
</code></pre>
<h3 id="write_pngdatafilename">write_png($data,$filename);</h3>
<p>Writes a PDL image as PNG file.</p>
<pre><code>sub write_png {
    my ($img,$png) = @_;
    my $cr = PDL-&gt;wpiccan('PNG');   # is PNG format allowed
    if(! $cr ) { print &quot;Error (write): Png not allowed!\n&quot;; return 0; }
    PDL::IO::Pic::wpic($img,$png, {FORMAT =&gt; 'PNG'}); # write image
}
</code></pre>
<h3 id="a-bit_planes--bit_planedatatype">A. @bit_planes = bit_plane($data,$type);</h3>
<p>Separates image $data in its @bit_planes. The $type can be &lsquo;raw'|'msb'|'lsb&rsquo;. This function takes only a 2-dimensional array, i.e. a grayscale image or only one color of a RGB image. All the operations are done on the whole image matrix at once. This is the advantage the PDL module gives to us.</p>
<p>It returns an array of 8 images, for each bit plane one separate image.</p>
<p>Let me give an example: A grayscale pixel has a decimal value of 255. The binary value is 0b11111111.</p>
<p>Each bit is masked in the for loop:</p>
<pre><code>Pixel      &amp; Mask       = Bit Plane (raw)            = (lsb)      = (msb)
0b11111111 &amp; 0b00000001 = 0b00000001 = $bit_plane[0] = 0b00000001 = 0b10000000
0b11111111 &amp; 0b00000010 = 0b00000010 = $bit_plane[1] = 0b00000001 = 0b10000000
0b11111111 &amp; 0b00000100 = 0b00000100 = $bit_plane[2] = 0b00000001 = 0b10000000
...
</code></pre>
<p>What is the meaning of the $type argument? (raw, lsb, msb)</p>
<h4 id="row">row</h4>
<p>The masked bit is on the same position in the byte than the original bit.</p>
<h4 id="lsb">lsb</h4>
<p>The masked bit is shifted down to the LSB position (bit 0). This is needed because I want to hide the MSB of the hidden image in the LSB of the vessel image. So I need to shift the MSB down to the LSB.</p>
<h4 id="msb">msb</h4>
<p>The masked bit is shifted up to the MSB position (bit 7). This can be useful in case you want to see the Bit Plane as an image. When you have binary values 0/1 on LSB the grayscale has a decimal value of 0/1, so you can not see the difference. When you have binary values 0/1 on MSB, the grayscale has a decimal value of 0/128, this difference in intensity you can see in an image.</p>
<pre><code>sub bit_plane {                                    # $type = raw|lsb|msb
    my ($layer,$type) = @_;
    $type = &quot;raw&quot; if not $type;
    my @bit_plane;                                   # resulting bit plane
    my $mask = PDL::Core::pdl(PDL::Core::byte(),
        0b00000001);                                 # initial mask on LSB
    for(my $i=0;$i&lt;=7;$i++) {                        # iterate bit 0 to bit 7
        $bit_plane[$i] = $layer &amp; $mask;               # mask image
        $mask = $mask &lt;&lt; 1;                            # shift mask to bit 1
        if($type eq &quot;lsb&quot;) {
            $bit_plane[$i] = $bit_plane[$i] &gt;&gt; $i;       # shift to LSB
        }
        elsif($type eq &quot;msb&quot;) {
            $bit_plane[$i] = $bit_plane[$i] &lt;&lt; (7 - $i); # shift to MSB
        }
    }
    return @bit_plane;                               # return bit plane
}
</code></pre>
<h3 id="b-bit_planes--bit_plane_arraydatatype">B. $bit_planes = bit_plane_array($data,$type)</h3>
<p>The bit_plane_array() function is doing the same as the bit_plane() function. Only the implementation is different, that it needs to iterate through every array element and also through all eight bits. Every Pixel value is binary ANDed &amp; with a Mask. The same Option $type exists, to keep the Bit in its original position &ldquo;raw&rdquo;, to put the Bit in LSB &ldquo;lsb&rdquo; or to put the Bit in MSB &ldquo;msb&rdquo;.</p>
<pre><code>sub bit_plane_array {                       # raw|lsb|msb
    my ($layer,$type) = @_;
    $type = &quot;raw&quot; if not $type;
    my @bit_plane;
    my $mask = 0b00000001;                    # Initialize Mask
    my $act_mask = $mask;
    for( my $w=0; $w&lt;=$#$layer; $w++ ) {      # Iterate Column
        my $col = $layer-&gt;[$w];
        for( my $h=0; $h&lt;=$#$col; $h++ ) {      # Iterate Row
            $act_mask = $mask;
            for(my $i=0;$i&lt;=7;$i++) {                     # Iterate Mask
                my $val = $col-&gt;[$h];                         # Value
                $bit_plane[$i][$w][$h] = $val &amp; $act_mask;    # Binary AND: Value &amp; Mask
                $act_mask = $mask &lt;&lt; $i;                      # Shift Mask
                if($type eq &quot;lsb&quot;) {
                    $bit_plane[$i][$w][$h] = $bit_plane[$i][$w][$h] &gt;&gt; $i;
                }
                elsif($type eq &quot;msb&quot;) {
                    $bit_plane[$i][$w][$h] = $bit_plane[$i][$w][$h] &lt;&lt; (7 - $i);
                }
            }
        }
    }
    return \@bit_plane;                       # Return Bit Plane
}
</code></pre>
<h3 id="a-redgreenblue--rgbdata">A. ($red,$green,$blue) = rgb($data);</h3>
<p>Returns the RED/GREEN/BLUE layers of a coloured image PDL $data. The separation is done with the PDL::NiceSlice module. So it is an easy task.</p>
<pre><code>sub rgb {
    my ($img) = @_;
    my $red   = $img((0),:,:);      # PDL::NiceSlice
    my $green = $img((1),:,:);
    my $blue  = $img((2),:,:);
    return ($red,$green,$blue);
}
</code></pre>
<h3 id="b-redgreenblue--rgb_arraydata">B. ($red,$green,$blue) = rgb_array($data);</h3>
<p>The function rgb_array() is rather easy, it only returns the Array Slice.</p>
<pre><code>sub rgb_array {
    my ($img) = @_;
    return @{$img}[0..2];    # Array Slice
}
</code></pre>
<h3 id="a-info_arrayarray_ref">A. info_array($array_ref)</h3>
<p>The function info_array() prints the size of the array to STDOUT. This can be helpful to debug the image processing, to see the size of some resulting image array.</p>
<pre><code>sub info_array {
    my ($aref) = @_;
    print &quot;Array: Size &quot;;
    print &quot;$#{$aref}&quot; if ref($aref) eq &quot;ARRAY&quot;;
    print &quot; x $#{$aref-&gt;[0]} &quot; if ref($aref-&gt;[0]) eq &quot;ARRAY&quot;;
    print &quot; x $#{$aref-&gt;[0]-&gt;[0]}&quot; if ref($aref-&gt;[0][0]) eq &quot;ARRAY&quot;;
    print &quot;\n&quot;;
}
</code></pre>
<h3 id="b-info_pdldatatitle">B. info_pdl($data,$title)</h3>
<p>The function info_pdl() prints some information of the PDL data to STDOUT. This can be helpful to debug the image processing, to see the size and some other data of some resulting image PDL.</p>
<p>Some PDL functions are used to get this information, i.e. get_datatype(), ndims(), nelem(), dims() and sum().</p>
<pre><code>sub info_pdl {
    my ($image,$title) = @_;
    my $dt = $image-&gt;get_datatype;
    my @type = (&quot;byte&quot;,&quot;short&quot;,&quot;ushort&quot;,&quot;long&quot;,&quot;indx&quot;,&quot;unknown&quot;,&quot;float&quot;,&quot;double&quot;);

    my $str = &quot;$title: &quot;;
    $str .= &quot; Type &quot; . $type[$dt]    . &quot; (&quot; . $dt . &quot;)&quot;;
    $str .= &quot; Dims &quot; . $image-&gt;ndims . &quot; (&quot; . join(&quot;/&quot;,( $image-&gt;dims )) . &quot;)&quot;;
    $str .= &quot; #Ele &quot; . $image-&gt;nelem;
    $str .= &quot; Sum  &quot; . $image-&gt;sum . &quot;\n&quot;;
    print $str;
    return $str;
}
</code></pre>
<hr>
<p>If you have any suggestion then please do share with us <a href="mailto:perlweeklychallenge@yahoo.com">perlweeklychallenge@yahoo.com</a>.</p>
<p><a href="/blog/advent-calendar-2019"><strong>Advent Calendar 2019</strong></a></p>

                </div>
            </div>
        </div>
    </div>
</section>


<!-- Call To Action Section Start -->
<section id="call-to-action">
    <div class="container">
        <div class="row">
            <div class="col-md-12">
                <div class="block">
                    <h2 class="title wow fadeInDown" data-wow-delay=".3s" data-wow-duration="500ms">SO WHAT DO YOU THINK ?</h2>
                    <p class="wow fadeInDown" data-wow-delay=".5s" data-wow-duration="500ms">If you have any suggestions or ideas then please do share with us.</p>
                    <a href="/contact" class="btn btn-default btn-contact wow fadeInDown" data-wow-delay=".7s" data-wow-duration="500ms">Contact with me</a>
                </div>
            </div>

        </div>
    </div>
</section>
<!-- Call To Action Section End -->



<!-- Footer Section Start -->
<footer id="footer">
    <div class="container">
        <div class="row content-justify-between">
            <div class="col-md-8 col-12 text-center text-lg-left text-md-left">
                <p class="copyright">Copyright:
                    <span>
                        <script>document.write(new Date().getFullYear())</script>
                    </span> PerlWeeklyChallenge. Theme Design and Developed by
                    <a href="http://www.Themefisher.com" target="_blank">Themefisher</a>.
                </p>
            </div>
            <div class="col-md-4 col-12">
                <!-- Social Media -->
                <ul class="social text-center text-md-right text-lg-right">
                    <li>
                        <a href="https://twitter.com/PerlWChallenge" class="twitter" target="_blank" title="Follow us">
                            <i class="ion-social-twitter"></i>
                        </a>
                    </li>
                    <li>
                        <a href="/rss.xml" class="rss" target="_blank" title="RSS Feed">
                            <i class="ion-social-rss"></i>
                        </a>
                    </li>
                    <li>
                        <a href="https://www.nomtimes.co.uk/site/shop.do?cref=PerlBooks" title="Free Perl Books" target="_blank">
                            <img src="/images/NomTimes.jpg" style="width:22px; height: 18px;" alt=""/>
                        </a>
                    </li>
                </ul>
            </div>
        </div>
    </div>
</footer>
<!-- footer section end -->

<!-- jquery -->
<script src="https://perlweeklychallenge.org/plugins/jQurey/jquery.min.js"></script>
<!-- Form Validation -->
<script src="https://perlweeklychallenge.org/plugins/form-validation/jquery.form.js"></script>
<script src="https://perlweeklychallenge.org/plugins/form-validation/jquery.validate.min.js"></script>
<!-- slick slider -->
<script src="https://perlweeklychallenge.org/plugins/slick/slick.min.js"></script>
<!-- bootstrap js -->
<script src="https://perlweeklychallenge.org/plugins/bootstrap/bootstrap.min.js"></script>
<!-- chart js -->
<script src="https://perlweeklychallenge.org/plugins/chart/highstock.js"></script>
<script src="https://perlweeklychallenge.org/plugins/chart/drilldown.js"></script>
<script src="https://perlweeklychallenge.org/plugins/chart/data.js"></script>
<script src="https://perlweeklychallenge.org/plugins/chart/chart.js"></script>
<!-- wow js -->
<script src="https://perlweeklychallenge.org/plugins/wow-js/wow.min.js"></script>
<!-- slider js -->
<script src="https://perlweeklychallenge.org/plugins/slider/slider.js"></script>
<!-- Fancybox -->
<script src="https://perlweeklychallenge.org/plugins/facncybox/jquery.fancybox.js"></script>
<!-- template main js -->

<script src="https://perlweeklychallenge.org/js/script.min.js"></script>
<!-- google analitycs -->
<script>
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
    (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
    m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
    ga('create', 'UA-136524905-1', 'auto');
    ga('send', 'pageview');
</script>
</body>

</html>

