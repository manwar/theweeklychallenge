<!DOCTYPE html>
<html class="no-js" lang="en-us">
<head>
    <!-- Basic Page Needs -->

    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta property="og:title"       content="The Weekly Challenge - Perl & Raku"/>
    <meta property="og:type"        content="website"/>
    <meta property="og:url"         content="https://perlweeklychallenge.org/"/>
    <meta property="og:image"       content="https://perlweeklychallenge.org/images/about/about.jpg"/>
    <meta property="og:description" content="You do not have to be an expert."/>
    <meta name="twitter:card"       content="summary" />
    <meta name="twitter:image"      content="https://perlweeklychallenge.org/images/about/about.jpg"/>

    <meta http-equiv="Content-Type" content="text/html; charset=utf-8">

    <meta name="description" content="Laurent Rosenfeld Weekly Review: Challenge - #022.">
    <meta name="author" content="Perl Weekly Challenge Team">
    <meta name="generator" content="Hugo 0.67.0-DEV" />

    <!-- Mobile Specific Metas -->
    <meta name="format-detection" content="telephone=no">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>Laurent Rosenfeld Weekly Review: Challenge - 022</title>
    <link rel="icon" href="https://perlweeklychallenge.org/images/favicon.ico">

    
    <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.0/css/bootstrap.min.css"/>

    <!-- Twitter Bootstrs CSS -->
    <link rel="stylesheet" href="https://perlweeklychallenge.org/plugins/bootstrap/bootstrap.min.css">
    <!-- Ionicons Fonts Css -->
    <link rel="stylesheet" href="https://perlweeklychallenge.org/plugins/ionicons/ionicons.min.css">
    <!-- animate css -->
    <link rel="stylesheet" href="https://perlweeklychallenge.org/plugins/animate-css/animate.css">
    <!-- Hero area slider css-->
    <link rel="stylesheet" href="https://perlweeklychallenge.org/plugins/slider/slider.css">
    <!-- slick slider -->
    <link rel="stylesheet" href="https://perlweeklychallenge.org/plugins/slick/slick.css">
    <!-- Fancybox -->
    <link rel="stylesheet" href="https://perlweeklychallenge.org/plugins/facncybox/jquery.fancybox.css">
    <!-- hover -->
    <link rel="stylesheet" href="https://perlweeklychallenge.org/plugins/hover/hover-min.css">
    <!-- Google fonts -->
    <link href='https://fonts.googleapis.com/css?family=Source Code Pro' rel='stylesheet'>
    <!-- template main css file -->
    
    <link rel="stylesheet" href="https://perlweeklychallenge.org/css/style.min.css" integrity="" media="screen">
    <link rel="stylesheet" href="https://perlweeklychallenge.org/css/main.css">
</head>

<body>

<section class="top-bar animated-header">
    <div class="container">
        <div class="row">
            <div class="col-lg-12">
                <nav class="navbar navbar-expand-lg navbar-light bg-light">
                    <a class="navbar-brand" href="https://perlweeklychallenge.org/">
                        <img src="https://perlweeklychallenge.org/images/logo.svg" alt="logo">
                    </a>
                    <button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navgation" aria-controls="navigation"
                        aria-expanded="false" aria-label="Toggle navigation">
                        <span class="navbar-toggler-icon"></span>
                    </button>

                    <div class="collapse navbar-collapse" id="navigation">
                        <ul class="navbar-nav ml-auto">
                            <li class="nav-item">
                                <a class="nav-link" href="https://perlweeklychallenge.org/">Home</a>
                            </li>
                            
                            <li class="nav-item">
                                <a class="nav-link" href="https://perlweeklychallenge.org/about">About</a>
                            </li>
                            
                            <li class="nav-item">
                                <a class="nav-link" href="https://perlweeklychallenge.org/chart">Chart</a>
                            </li>
                            
                            <li class="nav-item">
                                <a class="nav-link" href="https://perlweeklychallenge.org/champions">Champions</a>
                            </li>
                            
                            <li class="nav-item">
                                <a class="nav-link" href="https://perlweeklychallenge.org/team">Team</a>
                            </li>
                            
                            <li class="nav-item">
                                <a class="nav-link" href="https://perlweeklychallenge.org/challenges">Challenges</a>
                            </li>
                            
                            <li class="nav-item">
                                <a class="nav-link" href="https://perlweeklychallenge.org/p5-reviews">Perl/Review</a>
                            </li>
                            
                            <li class="nav-item">
                                <a class="nav-link" href="https://perlweeklychallenge.org/p6-reviews">Raku/Review</a>
                            </li>
                            
                            <li class="nav-item">
                                <a class="nav-link" href="https://perlweeklychallenge.org/recaps">Recaps</a>
                            </li>
                            
                            <li class="nav-item">
                                <a class="nav-link" href="https://perlweeklychallenge.org/blogs">Blogs</a>
                            </li>
                            
                            <li class="nav-item">
                                <a class="nav-link" href="https://perlweeklychallenge.org/faq">FAQ</a>
                            </li>
                            
                            <li class="nav-item">
                                <a class="nav-link" href="https://perlweeklychallenge.org/contact">Contact</a>
                            </li>
                            
                        </ul>
                    </div>
                </nav>
            </div>
        </div>
    </div>
</section>


<section class="global-page-header">
    <div class="container">
        <div class="row">
            <div class="col-md-12">
                <div class="block">
                    <h2>Laurent Rosenfeld Weekly Review: Challenge - 022</h2>
                    <div class="portfolio-meta">
                        <span>Wednesday, Oct 9, 2019</span>|
                        <span> Tags:
                            Raku
                        </span>
                    </div>
                </div>
            </div>
        </div>
    </div>
</section>

<section class="single-post">
    <div class="container">
        <div class="row">
            <div class="col-md-12">
                
                <div style="text-align: center" class="post-img">
                    <img class="img-fluid" alt="" src="https://perlweeklychallenge.org/images/blog/p6-review-challenge-022.jpg">
                </div>
                
                <div style="text-align: justify" class="post-content">
                    <hr>
<h1 id="raku-solutions-weekly-review">Raku Solutions Weekly Review</h1>
<hr>
<h2 id="task-1-sexy-prime-pairs">Task #1: Sexy Prime Pairs</h2>
<p>This is derived from my <a href="http://blogs.perl.org/users/laurent_r/2019/08/perl-weekly-challenge-22-sexy-prime-pairs-and-compression-algorithm.html">blog post</a> made in answer to the <a href="https://perlweeklychallenge.org/blog/perl-weekly-challenge-022/">Week 22 of the Perl Weekly Challenge</a> organized by  <a href="http://blogs.perl.org/users/mohammad_s_anwar/">Mohammad S. Anwar</a> as well as answers made by others to the same challenge.</p>
<p>The challenge reads as follows:</p>
<p><em>Write a script to print first 10 Sexy Prime Pairs. Sexy primes are prime numbers that differ from each other by 6. For example, the numbers 5 and 11 are both sexy primes, because 11 - 5 = 6. The term “sexy prime” is a pun stemming from the Latin word for six: sex. For more information, please checkout <a href="https://en.wikipedia.org/wiki/Sexy_prime">wiki</a> page.</em></p>
<p>My first question, when reading this definition, was whether sexy primes had to be consecutive prime numbers. The example provided (as well as those found in the the Wikipedia page) shows that it needs not be the case: 5 and 11 are not consecutive primes (since 7 is also prime). If sexy primes had to be consecutive primes, then the first such pair would be (23, 29). With that answer to my question, it seems to me that all we need to do is to look at each prime number <em>p</em> and check whether <em>p + 6</em> is prime (and stop as soon as we have 10 sexy pairs).</p>
<p>Note that (1, 7) is not a sexy prime pair (despite having a gap of 6), because 1 is not considered to be a prime number. Therefore, to avoid the risk of finding a false sexy prime pair, we will start our search with number 2.</p>
<h2 id="my-solution">My Solution</h2>
<p>We first build a lazy infinite list <code>@sexy-primes</code> of prime numbers such that each such prime + 6 is also prime, and then print the pairs:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-Perl6" data-lang="Perl6">    <span style="color:#66d9ef">use</span> v6;

    <span style="color:#66d9ef">my</span> @sexy<span style="color:#f92672">-</span>primes <span style="color:#f92672">=</span> grep { <span style="color:#f92672">.</span>is<span style="color:#f92672">-</span>prime <span style="color:#f92672">and</span> ($_ <span style="color:#f92672">+</span> <span style="color:#ae81ff">6</span>)<span style="color:#f92672">.</span>is<span style="color:#f92672">-</span>prime}, (<span style="color:#ae81ff">2</span>, <span style="color:#ae81ff">3</span>, <span style="color:#f92672">*+</span><span style="color:#ae81ff">2</span> <span style="color:#f92672">...</span> Inf);
    say <span style="color:#e6db74">&#34;@sexy-primes[$_] &#34;</span>, @sexy<span style="color:#f92672">-</span>primes[$_] <span style="color:#f92672">+</span> <span style="color:#ae81ff">6</span> <span style="color:#66d9ef">for</span> <span style="color:#f92672">^</span><span style="color:#ae81ff">10</span>;
</code></pre></div><p>Note that, as a basis for finding the primes, we use a sequence operator with an explicit generator in order to check parity only for odd numbers. This avoids useless computations on even numbers which cannot be prime (except for 2). This might be considered premature optimization (and we all know what Donald Knuth said about premature optimization). Well, yes, but, at the same time, I don&rsquo;t like to let my programs do unnecessary work.</p>
<p>And this prints:</p>
<pre><code>$ perl6 sexy-pairs.p6
5 11
7 13
11 17
13 19
17 23
23 29
31 37
37 43
41 47
47 53
</code></pre>
<p>This program is so short that we can easily get rid of the <code>@sexy-primes</code> temporary array and transform the script into a Perl6 one-liner:</p>
<pre><code>$ perl6 'say &quot;$_ &quot;, $_+6 for (2...*).grep({.is-prime &amp;&amp; ($_ + 6).is-prime})[^10];'
5 11
7 13
11 17
13 19
17 23
23 29
31 37
37 43
41 47
47 53
</code></pre>
<h2 id="alternative-solutions">Alternative Solutions</h2>
<p><a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-022/arne-sommer/perl6/ch-1.p6">Arne Sommer</a> also used a lazy infinite list of primes, grepped those primes to keep only those primes <em>n</em> for which <em>n + 6</em> is also prime, and printed the first ten.</p>
<p><a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-022/kevin-colyer/perl5/ch-1.pl">Kevin Colyer</a> also populated a lazy infinite list of primes and then looks for those primes <em>n</em> where <em>n + 6</em> is also prime. I must say that I find that the way Kevin loops over the array of primes, with two nested loops and two iteration variables, is a little bit contrived and not very perlish.</p>
<p><a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-022/mark-senn/perl6/ch-1.p6">Mark Senn</a> also used a lazy infinite list of primes but then looks for those where the <em>number - 6</em> is also prime. Why not? After all, defining sexy prime pairs as pairs of numbers such that <em>n</em> and <em>n</em> - 6 are both prime is equivalent to defining them as as pairs of numbers such that <em>n</em> and <em>n</em> + 6 are both prime. So this is perfectly fine. I think, however, that Mark&rsquo;s solution is a bit more complicated than it really needs to be. In particular, it uses a <code>@cb</code> circular buffer which seems unnecessary to me.</p>
<p><a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-022/simon-proctor/perl6/ch-1.p6">Simon Proctor</a> used a one-real-code line solution:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-Perl6" data-lang="Perl6"><span style="color:#f92672">.</span>say <span style="color:#66d9ef">for</span> (<span style="color:#f92672">^</span>Inf)<span style="color:#f92672">.</span>hyper<span style="color:#f92672">.</span>grep( { $_<span style="color:#f92672">.</span>is<span style="color:#f92672">-</span>prime <span style="color:#f92672">&amp;&amp;</span> ($_ <span style="color:#f92672">+</span> <span style="color:#ae81ff">6</span>)<span style="color:#f92672">.</span>is<span style="color:#f92672">-</span>prime } )<span style="color:#f92672">.</span>map( { ($_,$_<span style="color:#f92672">+</span><span style="color:#ae81ff">6</span>)<span style="color:#f92672">.</span>join(<span style="color:#e6db74">&#34;,&#34;</span>) } )[<span style="color:#f92672">^</span>$n];
</code></pre></div><p>Note the use of the <code>hyper</code> method to enable the processing of items in parallel (and preserving the order). It probably doesn&rsquo;t boost performance very much with such a small dataset, but it is still a good idea to keep in mind.</p>
<p><a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-022/athanasius/perl6/ch-1.p6">Athanasius</a> used a lexical construct that I had never seen before to loop over prime numbers:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-Perl6" data-lang="Perl6">Nil <span style="color:#66d9ef">until</span> is<span style="color:#f92672">-</span>prime(<span style="color:#f92672">++</span>$prime);
<span style="color:#75715e"># Now do something with $prime</span>
</code></pre></div><p>Otherwise, he defines a <code>$partner</code> of <code>$prime</code> as <code>$prime + 6</code>, checks if the partner is prime and, if so, stores <code>[$prime, $partner]</code> into a <code>@pairs</code> array. His main <code>while</code> loop stops when the <code>@pairs</code> array has ten elements.</p>
<p><a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-022/jaldhar-h-vyas/perl6/ch-1.sh">Jaldhar M. Vyas</a> made a Perl 6 one-liner fairly similar to my second solution:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-Perl6" data-lang="Perl6">perl6 <span style="color:#f92672">-</span>e <span style="color:#e6db74">&#39;(1..∞).grep({.is-prime}).map({($_,$_+6) if ($_+6).is-prime})[^10].map({.join(q{, }).say});&#39;</span>
</code></pre></div><p><a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-022/joelle-maslak/perl6/ch-1.p6">Joelle Maslak</a> also used a lazy infinite list of primes, but then she used a <code>lazy gather ... take</code> statement to pick up the sexy pairs.</p>
<p><a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-022/randy-lauen/perl6/ch-1.p6">Randy Lauen</a>&lsquo;s solution uses a single line of real code:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-Perl" data-lang="Perl">say (<span style="color:#ae81ff">1</span> <span style="color:#f92672">..</span> Inf)<span style="color:#f92672">.</span>map( { $_, $_<span style="color:#f92672">+</span><span style="color:#ae81ff">6</span> } )<span style="color:#f92672">.</span>flat<span style="color:#f92672">.</span>grep( { $<span style="color:#960050;background-color:#1e0010">^</span>a<span style="color:#f92672">.</span>is<span style="color:#f92672">-</span>prime <span style="color:#f92672">&amp;&amp;</span> $<span style="color:#960050;background-color:#1e0010">^</span>b<span style="color:#f92672">.</span>is<span style="color:#f92672">-</span>prime } )<span style="color:#f92672">.</span>head(<span style="color:#ae81ff">10</span>)<span style="color:#f92672">.</span>join(<span style="color:#e6db74">&#34;\n&#34;</span>);
</code></pre></div><p><a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-022/roger-bell-west/perl6/ch-1.p6">Roger Bell West</a> made an iterative solution with an infinite <code>for</code> loop. It appears that Roger did not read the challenge specification closely enough, since his solution only prints 6 sexy pairs.</p>
<p><a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-022/ruben-westerberg/perl6/ch-1.p6">Ruben Westerberg</a> also started with a lazy infinite list of primes, but then almost lost me with an eleven-line <code>map</code> statement. Too complicated in my humble opinion.</p>
<p><a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-022/yet-ebreo/perl6/ch-1.p6">Yet Ebreo</a>, who just joined this challenge team (welcome, Yet!) and was writing a Perl 6 script for the first time (congratulations!). He supplied actually two solutions. The first one is a quite original one-liner generating all pairs of numbers between 0 and 55 with the <code>combinations</code> method and then grepping them for primality and a gap of 6:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-Perl6" data-lang="Perl6">say grep { $_[<span style="color:#ae81ff">1</span>]<span style="color:#f92672">-</span>$_[<span style="color:#ae81ff">0</span>] <span style="color:#f92672">==</span> <span style="color:#ae81ff">6</span> }, (grep { $_<span style="color:#f92672">.</span>is<span style="color:#f92672">-</span>prime }, <span style="color:#ae81ff">0</span><span style="color:#f92672">..</span><span style="color:#ae81ff">55</span>)<span style="color:#f92672">.</span>combinations: <span style="color:#ae81ff">2</span>;
</code></pre></div><p>Yet does not say how he knew he could stop his range at 55. His second solution implements manually a sieve of Eratosthenes (i.e. basically crossing out all composite numbers in a <code>0..55</code> range in order to retain only the primes), using a <code>grep</code> statement in a highly uncommon way. Then, his solution does another <code>grep</code> to find the primes with a gap of 6.</p>
<h2 id="task-2-the-lempelzivwelch-lzw-compression-algorithm">Task #2: The Lempel–Ziv–Welch (LZW) Compression Algorithm</h2>
<p>This is derived from my <a href="http://blogs.perl.org/users/laurent_r/2019/08/perl-weekly-challenge-22-sexy-prime-pairs-and-compression-algorithm.html">blog post</a> made in answer to the <a href="https://perlweeklychallenge.org/blog/perl-weekly-challenge-022/">Week 22 of the Perl Weekly Challenge</a> organized by  <a href="http://blogs.perl.org/users/mohammad_s_anwar/">Mohammad S. Anwar</a> as well as answers made by others to the same challenge.</p>
<p>The challenge reads as follows:</p>
<p><em>Write a script to implement Lempel–Ziv–Welch (LZW) compression algorithm. The script should have method to encode/decode algorithm. The <a href="https://en.wikipedia.org/wiki/Lempel%E2%80%93Ziv%E2%80%93Welch">wiki page</a> explains the compression algorithm very nicely.</em></p>
<p>Lempel–Ziv–Welch (LZW) is a lossless data compression algorithm created by Abraham Lempel, Jacob Ziv, and Terry Welch. It was published by Welch in 1984 as an improved implementation of the <a href="https://en.wikipedia.org/wiki/LZ77_and_LZ78">LZ78</a> algorithm published by Lempel and Ziv in 1978.</p>
<p>The scenario described by Welch encodes sequences of 8-bit data as fixed-length 12-bit codes. The codes from 0 to 255 represent 1-character sequences consisting of the corresponding 8-bit character, and the codes 256 through 4095 are created in a dictionary for sequences encountered in the data as it is encoded. At each stage in compression, input bytes are gathered into a sequence until the next character would make a sequence with no code yet in the dictionary. The code for the sequence (without that character) is added to the output, and a new code (for the sequence with that character) is added to the dictionary.</p>
<p>For encoding (or, really, compressing) a string, we buffer input the characters in a sequence <code>$ω</code> (note that we use here the variables names from the Wikipedia page to facilitate understanding) until the next <code>$ω</code> is not in the <code>%dict</code> hash.  At this point, emit the code for <code>$ω</code>, and add <code>$ω</code> plus the next character to the hash. Start buffering again with the next character. Concretely, we first populate the <code>%dict</code> hash with the single possible letters. Then, we traverse the input string character by character and build the sequence as long as it exists in the <code>dict</code> hash. When the new sequence to be built does not exist in the hash, we add the previous sequence to the result, add the new one to the hash and start a new sequence with the last visited character.</p>
<p>For decoding (decompressing), we use the same initial hash as when encoding (we don&rsquo;t need the final hash, so we don&rsquo;t need to transmit the final dictionary; the start dictionary is all we need and can be hard coded).  Additional entries can be reconstructed as they are always simply concatenations of previous entries. Concretely, we populate <code>%dict</code> hash as before, but inverting keys and values. Then we go through the codes one by one; if a code exists in the hash, we just convert it and add it to the output; else, we build the new sequence, add it to the output and add the sequence concatenated with the sequence&rsquo;s first character to the hash.</p>
<p>Note that the Wikipedia description specifies a stop character (<code>#</code>) to indicate the end of a message, but we don&rsquo;t really need it.</p>
<h3 id="my-solution-1">My Solution</h3>
<p>For a start, we will use an input string (&lsquo;TOBEORNOTTOBEORTOBEOR&hellip;') consisting only of capital letters (<code>'A'..'Z'</code>), as in the Wikipedia article, and populate our initial hash <code>%dict</code> with corresponding numeric codes between 0 and 25. Then we start at looking at the string to be encoded. The first letter <em>T</em> exists in <code>%dict</code>, so we look for a two letter sequence, <em>TO</em>, which does not exists in the hash; at this point we add the code for <em>T</em> to the result and add to <code>%dict</code> a new code (in this case 26) corresponding to <em>TO</em>. And so on.</p>
<p>The beginning of the compressed sequence might be as follows:</p>
<pre><code>T  O  B E O  R  N  O  T  TO BE
19 14 1 4 14 17 13 14 19 26 28
</code></pre>
<p>When decoding, we first build the same initial hash, but with keys and values inverted. The first 9 codes (all between 0 and 25) will be decoded with the initial hash. When we find code 26, which is not in our hash, we know it is the first sequence of letters at the start of the part of the string that we have already decoded, so it is <em>TO</em>, and we can add that to our <code>%dict</code> hash. The next (28) will be <em>BE</em> (since code 27, not appearing so far in our codes, will have been taken by <em>OB</em>). And so on. Except that, in reality, you don&rsquo;t wait for a code not present in your hash to add an entry to the <code>%dict</code> hash: you start doing it as soon as you start decoding the first letters, so that, in effect, the <code>encode</code> and <code>decode</code> subroutines populate the dictionary in exactly the same way.</p>
<pre><code>use v6;

constant $start-dict-size = 26;

sub encode (Str $in) {
    my %dict = map { $_[0] =&gt; $_[1] },
        ( ('A'..'Z') Z (^$start-dict-size) );
    my $ω = &quot;&quot;;
    my @result = gather {
        for $in.comb -&gt; $c {
            my $ωc = $ω ~ $c;
            if %dict{$ωc}:exists {
                $ω = $ωc;
            } else {
                take %dict{$ω};
                %dict{$ωc} = +%dict;
                $ω = $c;
            }
        }
        take %dict{$ω} if $ω.chars;
    }
    # say %dict;
    return @result;
}
sub decode (@encoded) {
    my $dict-size = $start-dict-size;
    my %dict = map { $_[1] =&gt; $_[0] },
        ( ('A'..'Z') Z (^$start-dict-size) );
    my $ω = %dict{shift @encoded};
    my @result = gather {
        take $ω;
        for @encoded -&gt; $i {
            my $str;
            if %dict{$i}:exists {
                $str = %dict{$i};
            } elsif  $i == $dict-size {
                $str = $ω ~ $ω.substr(0,1)
            }
            take $str;
            %dict{$dict-size++} = $ω ~ $str.substr(0,1);
            $ω = $str;
        }
    }
    return join &quot;&quot;, @result;
}

my $input_str = 'TOBEORNOTTOBETOBEORNOTTOBETOBEORNOTTOBE';
my @encoded = encode $input_str;
say @encoded;
say decode @encoded;
</code></pre>
<p>Running this code produces a correct round trip and displays the following output:</p>
<pre><code>$ perl6 LZW_compression.p6
[19 14 1 4 14 17 13 14 19 26 28 35 29 31 33 37 37 30 32 34 27 4]
TOBEORNOTTOBETOBEORNOTTOBETOBEORNOTTOBE
</code></pre>
<p>The encoded (compressed) code has 22 numbers that could each be encoded over 6 bits, so that&rsquo;s a total of 132 bits. The input string had 39 bytes, i.e. 312 bits. In other words, we obtain a compression ratio of 2.36. Admittedly, we could have used a fixed-length encoding scheme and encoded each character of the input string over 5 bits, which would have led to a total of 195 bits, leading to a compression ratio of 1.6. We still get an LZW compression ratio which is 1.47 times better than a fixed-length encoding.</p>
<p>The reason for this better compression ratio is that many of our numeric codes represent two letters of the input, and some of them even more letters; for example, numeric code (35) stands for 3 letters, &ldquo;TOB&rdquo;, and code 37 stands for 4 letters, &ldquo;TOBE&rdquo;:</p>
<pre><code>19 14 1 4 14 17 13 14 19 26 28 35  29 31 33 37   37   30 32 34 27 4
T  O  B E O  R  N  O  T  TO BE TOB EO RN OT TOBE TOBE OR NO TT OB E
</code></pre>
<p>Encoding only ASCII upper case letters is of course very limited. Leaving aside Unicode, we would like at least to be able to compress bytes encoded over 256 bits. For this, we only need to change the <code>$start-dict-size</code> constant to 256 and to populate the initial <code>%dict</code> hash accordingly. For example, this way for the <code>encode</code> subroutine:</p>
<pre><code>my %dict = map { .chr =&gt; $_ }, ^$start-dict-size;
</code></pre>
<p>And this way in the <code>decode</code> subroutine:</p>
<pre><code>my %dict = map { $_ =&gt; .chr }, ^$start-dict-size;
</code></pre>
<p>The compressed code still has 22 numbers, but the compression rate would fall down, because these numbers would now need to be encoded over more bits:</p>
<pre><code>[84 79 66 69 79 82 78 79 84 256 258 265 259 261 263 267 267 260 262 264 257 69]
</code></pre>
<p>And we can now compress data not comprising only of capital ASCII letters. For example, with the following input string:</p>
<pre><code>To be or not to be, to be or not to be, that's the question
</code></pre>
<p>we obtain the following output:</p>
<pre><code>perl6 LZW_compression.p6
[84 111 32 98 101 32 111 114 32 110 111 116 32 116 257 259 44 268 270 260 262 264 266
273 258 101 272 116 104 97 116 39 115 268 104 260 113 117 101 115 116 105 111 110]
To be or not to be, to be or not to be, that's the question
</code></pre>
<p>Here, we have 44 the compressed codes for an input string of 59 bytes; i.e. a compression ration of about 0.74.</p>
<p>In a real implementation, we would need to set some limit to the dictionary size, because memory is limited and, also, it doesn&rsquo;t really make sense to keep adding longer and longer sequences of characters as, the longer they grow, the more unlikely we will find repetitions. On course, the <code>encode</code> and <code>decode</code> subroutines have to agree on that size limit. There was no reason to implement such a size limit for our tiny toy examples.</p>
<p>If you&rsquo;re interested with data compression techniques, you might also want to take a look at the exercise on Huffman coding (as well as its solutions) at the end of chapter 10 of my <em>Think Perl 6</em> book, which can be downloaded for free in PDF format on this <a href="https://github.com/LaurentRosenfeld/thinkperl6/tree/master/PDF">same github repository</a>.</p>
<h2 id="alternative-solutions-1">Alternative Solutions</h2>
<p>The description of the LZW algorithm is a fairly detailed specification that leaves relatively little room for imagination. Therefore, the solutions suggested by the challengers are mostly looking very similar, usually only implementation details outside the algorithm itself vary.</p>
<p><a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-022/arne-sommer/perl6/ch-2.p6">Arne Sommer</a> started with an alphabet and a hash consisting only of the letters occurring in the string to be compressed. This make a smaller alphabet and initial dictionary size, but this means that the alphabet needs to be transmitted to the decoding subroutine. Besides that, the algorithm is essentially the same, except that Arne converts the compressed message into a binary string (i.e. a string comprised of 0 and 1 characters).</p>
<p><a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-022/ruben-westerberg/perl6/ch-2.p6">Roger Bell West</a> also started with a dictionary consisting only of the letters occurring in the string to be compressed. His <code>encode</code> subroutine does what it is supposed to do. But his <code>decode</code> subroutine uses the full dictionary prepared by <code>encode</code> as a parameter, so that it does not have anything to do other than a simple dictionary lookup:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-Perl6" data-lang="Perl6"><span style="color:#66d9ef">sub</span> <span style="color:#a6e22e">decode</span>(@dict, @in, @out) {
    <span style="color:#66d9ef">for</span> @in {
        push @out, @dict[$_];
    }
}
</code></pre></div><p>OK, fair enough, this is simple and it works, but, IMHO, that&rsquo;s not really the spirit of the LZW algorithm, in which the decoder is supposed to rebuild the dictionary in the same way as the coder originally populated it.</p>
<p><a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-022/kevin-colyer/perl5/ch-2.pl">Kevin Colyer</a> used a dictionary hardset to ASCII upper case, as I did in my initial solution. Also to be noted; Kevin used an array and not a hash for his dictionary, so that letter sequence lookup is a bit tedious in his <code>encode</code> subroutine.</p>
<p><a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-022/ozzy/perl6/ch-2.p6">Ozzy</a> used a dictionary with the full extended ASCII range. Ozzy&rsquo;s code provides a nice graphical description of the way the algorithm works for the sample string &ldquo;yadayada,&rdquo; which I think is worth quoting, just in case my description above wasn&rsquo;t clear or concise enough in your eyes:</p>
<pre><code># Encoding
# String      : yadayada
# Code points : [121 97 100 97 121 97 100 97]
#
#     Output       Code      New dict. entry
#          y        121            ya  [256]
#          a         97            ad  [257]
#          d        100            da  [258]
#          a         97            ay  [259]
#         ya        256           yad  [260]
#         da        258
#
# Decoding
# Code points : [121 97 100 97 256 258]
#
#     Output       Code      New dict. entry
#          y        121
#          a         97             ya [256]
#          d        100             ad [257]
#          a         97             da [258]
#         ya        256             ay [259]
#         da        258            yad [260]
</code></pre>
<p><a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-022/simon-proctor/perl6/ch-2.p6">Simon Proctor</a> created a program with not less than 8 multi MAIN subroutines, to provide possibilities to encode or decode from a passed argument, from STDIN, from a file, etc. He used an alphabet somewhat intermediate between only upper case ASCII letters and full extended ASCII range, with all alphanumerical characters and some additional punctuation and other signs:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-Perl6" data-lang="Perl6">subset ValidToEncode of Str where <span style="color:#e6db74">m/^&lt;[a..z A..Z 0..9 \  _ \n \. , ]&gt;* \n?$/</span>;
</code></pre></div><p>This subset is used in the signature of the <code>encode-data</code> multi method to accept or reject input. The output of that method is a string of space separated numbers.</p>
<p><a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-022/athanasius/perl6/ch-2.p6">Athanasius</a> compressed the input into an array of numeric codes. His starting dictionary contains all extended ASCII or ISO-8859-1) codes between 0 and 255. His program nicely outputs some statistics about the compression, for example (with a highly repetitive input string):</p>
<pre><code>Number of characters
  Original: 15
  Encoded:   9
  Decoded:  15

Encoding/decoding successful
  Compression ratio:  1.7
  Space savings:      40.0%
  Dictionary entries: 264
</code></pre>
<p><a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-022/jaldhar-h-vyas/perl6/ch-2.p6">Jaldar H. Vyas</a>&lsquo;s starting alphabet also contains all extended ASCII characters with codes between 0 and 255, although his test uses a string with only a few upper case ASCII letters (<code>A..Z</code>).</p>
<p><a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-022/yet-ebreo/perl6/ch-2.p6">Yet Ebreo</a> also started with a dictionary containing all extended ASCII characters with codes between 0 and 255. His encoded result is an array of integers, as for many of us. For someone who had never written any script in Perl 6 just days before, Yet&rsquo;s code is pretty clean and even often quite idiomatic (although some syntax constructs are obviously influenced by his knowledge of Perl 5, but I guess you could probably say the same thing about me).</p>
<p><a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-022/joelle-maslak/perl6/ch-2.p6">Joelle Maslak</a> wrote a full OOP program with three classes, <code>Dictionary</code>,  <code>Bitwise-Write</code>, and <code>Bitwise-Read</code>. Her solution is the most complete one, as it is one of the only two that actually perform binary encoding of the compressed data.</p>
<p><a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-022/randy-lauen/perl6/ch-2.p6">Randy Lauen</a> is the other most complete solution that provides actual binary encoding of the compressed data. For this, it uses lizmat&rsquo;s <a href="https://github.com/lizmat/P5pack">P5pack</a> module, which implements in Perl 6 the Perl 5 <code>pack</code> and <code>unpack</code> built-ins. He used this module presumably because he found it easier since his P6 version is a port of his earlier P5 implementation.</p>
<h2 id="see-also">SEE ALSO</h2>
<p>Four blog posts this time:</p>
<p>Arne Sommer: <a href="https://perl6.eu/prime-lzw.html">https://perl6.eu/prime-lzw.html</a>. Arne adds some bonuses: sexy prime triplets, sexy prime quadruplets, and even one sexy prime quintuplet.</p>
<p>Mark Senn: <a href="https://engineering.purdue.edu/~mark/pwc-022-1.pdf">https://engineering.purdue.edu/~mark/pwc-022-1.pdf</a></p>
<p>Jaldar H. Vyas: <a href="https://www.braincells.com/perl/2019/08/perl_weekly_challenge_week_22.html">https://www.braincells.com/perl/2019/08/perl_weekly_challenge_week_22.html</a></p>
<p>Yet Ebreo: <a href="http://blogs.perl.org/users/yet_ebreo/2019/08/perl-weekly-challenge-w022.html">http://blogs.perl.org/users/yet_ebreo/2019/08/perl-weekly-challenge-w022.html</a></p>
<h2 id="wrapping-up">Wrapping up</h2>
<p>Please let me know if I forgot any of the challengers or if you think my explanation of your code misses something important.</p>
<p>If you want to participate to the Perl Weekly Challenge, please connect to <a href="https://perlweeklychallenge.org/">this site</a>.</p>

                </div>
            </div>
        </div>
    </div>
</section>


<!-- Call To Action Section Start -->
<section id="call-to-action">
    <div class="container">
        <div class="row">
            <div class="col-md-12">
                <div class="block">
                    <h2 class="title wow fadeInDown" data-wow-delay=".3s" data-wow-duration="500ms">SO WHAT DO YOU THINK ?</h2>
                    <p class="wow fadeInDown" data-wow-delay=".5s" data-wow-duration="500ms">If you have any suggestions or ideas then please do share with us.</p>
                    <a href="/contact" class="btn btn-default btn-contact wow fadeInDown" data-wow-delay=".7s" data-wow-duration="500ms">Contact with me</a>
                </div>
            </div>

        </div>
    </div>
</section>
<!-- Call To Action Section End -->



<!-- Footer Section Start -->
<footer id="footer">
    <div class="container">
        <div class="row content-justify-between">
            <div class="col-md-8 col-12 text-center text-lg-left text-md-left">
                <p class="copyright">Copyright:
                    <span>
                        2020
                    </span> PerlWeeklyChallenge. Theme Design and Developed by
                    <a href="http://www.Themefisher.com" rel="noreferrer" rel="noreferrer" target="_blank">Themefisher</a>.
                </p>
            </div>
            <div class="col-md-4 col-12">
                <!-- Social Media -->
                <ul class="social text-center text-md-right text-lg-right">
                    <li>
                        <a href="https://twitter.com/PerlWChallenge" class="twitter" rel="noreferrer" target="_blank" title="Follow us">
                            <i class="ion-social-twitter"></i>
                        </a>
                    </li>
                    <li>
                        <a href="/rss.xml" class="rss" target="_blank" title="RSS Feed">
                            <i class="ion-social-rss"></i>
                        </a>
                    </li>
                    <li>
                        <a href="https://www.nomtimes.co.uk/site/shop.do?cref=PerlBooks" title="Free Perl Books" rel="noreferrer" target="_blank">
                            <img src="/images/NomTimes.jpg" style="width:22px; height: 18px;" alt=""/>
                        </a>
                    </li>
                </ul>
            </div>
        </div>
    </div>
</footer>
<!-- footer section end -->

<!-- jquery -->
<script src="https://perlweeklychallenge.org/plugins/jQurey/jquery.min.js"></script>
<!-- Form Validation -->
<script src="https://perlweeklychallenge.org/plugins/form-validation/jquery.form.min.js"></script>
<script src="https://perlweeklychallenge.org/plugins/form-validation/jquery.validate.min.js"></script>
<!-- slick slider -->
<script src="https://perlweeklychallenge.org/plugins/slick/slick.min.js"></script>
<!-- bootstrap js -->
<script src="https://perlweeklychallenge.org/plugins/bootstrap/bootstrap.min.js"></script>
<!-- chart js -->
<script src="https://perlweeklychallenge.org/plugins/chart/highstock.js"></script>
<script src="https://perlweeklychallenge.org/plugins/chart/drilldown.js"></script>
<script src="https://perlweeklychallenge.org/plugins/chart/data.js"></script>
<script src="https://perlweeklychallenge.org/plugins/chart/chart.js"></script>
<!-- wow js -->
<script src="https://perlweeklychallenge.org/plugins/wow-js/wow.min.js"></script>
<!-- slider js -->
<script src="https://perlweeklychallenge.org/plugins/slider/slider.js"></script>
<!-- Fancybox -->
<script src="https://perlweeklychallenge.org/plugins/facncybox/jquery.fancybox.js"></script>
<!-- template main js -->

<script src="https://perlweeklychallenge.org/js/script.min.js"></script>
<!-- google analitycs -->
<script>
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
    (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
    m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
    ga('create', 'UA-136524905-1', 'auto');
    ga('send', 'pageview');
</script>
</body>

</html>

