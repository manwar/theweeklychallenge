<!DOCTYPE html>
<html class="no-js" lang="en-us">
<head>
    <!-- Basic Page Needs -->

    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta property="og:title"       content="The Weekly Challenge - Perl & Raku"/>
    <meta property="og:type"        content="website"/>
    <meta property="og:url"         content="https://perlweeklychallenge.org/"/>
    <meta property="og:image"       content="https://perlweeklychallenge.org/images/about/about.jpg"/>
    <meta property="og:description" content="You do not have to be an expert."/>
    <meta name="twitter:card"       content="summary" />
    <meta name="twitter:image"      content="https://perlweeklychallenge.org/images/about/about.jpg"/>

    <meta http-equiv="Content-Type" content="text/html; charset=utf-8">

    <meta name="description" content="Ryan Thompson › Perl Weekly Review #053">
    <meta name="author" content="The Weekly Challenge Team">
    <meta name="generator" content="Hugo 0.67.0-DEV" />

    <!-- Mobile Specific Metas -->
    <meta name="format-detection" content="telephone=no">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>Ryan Thompson › Perl Weekly Review #053</title>
    <link rel="icon" href="https://perlweeklychallenge.org/images/favicon.ico">

    
    <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.0/css/bootstrap.min.css"/>

    <!-- Twitter Bootstrs CSS -->
    <link rel="stylesheet" href="https://perlweeklychallenge.org/plugins/bootstrap/bootstrap.min.css">
    <!-- Ionicons Fonts Css -->
    <link rel="stylesheet" href="https://perlweeklychallenge.org/plugins/ionicons/ionicons.min.css">
    <!-- animate css -->
    <link rel="stylesheet" href="https://perlweeklychallenge.org/plugins/animate-css/animate.css">
    <!-- Hero area slider css-->
    <link rel="stylesheet" href="https://perlweeklychallenge.org/plugins/slider/slider.css">
    <!-- slick slider -->
    <link rel="stylesheet" href="https://perlweeklychallenge.org/plugins/slick/slick.css">
    <!-- Fancybox -->
    <link rel="stylesheet" href="https://perlweeklychallenge.org/plugins/facncybox/jquery.fancybox.css">
    <!-- hover -->
    <link rel="stylesheet" href="https://perlweeklychallenge.org/plugins/hover/hover-min.css">
    <!-- Google fonts -->
    <link href='https://fonts.googleapis.com/css?family=Source Code Pro' rel='stylesheet'>
    <!-- template main css file -->
    
    <link rel="stylesheet" href="https://perlweeklychallenge.org/css/style.min.css" integrity="" media="screen">
    <link rel="stylesheet" href="https://perlweeklychallenge.org/css/main.css">

    <style>
        #goTopButton {
            display: none;          
            position: fixed;        
            bottom: 20px;           
            right: 30px;            
            z-index: 99;            
            border: none;           
            outline: none;          
            background-color: red;  
            color: white;           
            cursor: pointer;        
            padding: 15px;          
            border-radius: 10px;    
            font-size: 18px;        
        }

        #goTopButton:hover {
              background-color: #555;
        }
    </style>


</head>

<body>

<button onclick="goTop()" id="goTopButton" title="Go to top">Top</button>

<script>

    topButton = document.getElementById("goTopButton");

    
    window.onscroll = function() { scrollFunction() };

    function scrollFunction() {
        if (document.body.scrollTop > 40 || document.documentElement.scrollTop > 40) {
            topButton.style.display = "block";
        } else {
            topButton.style.display = "none";
        }
    }

    
    function goTop() {
        document.body.scrollTop = 0; 
        document.documentElement.scrollTop = 0; 
    }

</script>

<section class="top-bar animated-header">
    <div class="container">
        <div class="row">
            <div class="col-lg-12">
                <nav class="navbar navbar-expand-lg navbar-light bg-light">
                    <a class="navbar-brand" href="https://perlweeklychallenge.org/">
                        <img src="https://perlweeklychallenge.org/images/logo.svg" alt="logo">
                    </a>
                    <button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navgation" aria-controls="navigation"
                        aria-expanded="false" aria-label="Toggle navigation">
                        <span class="navbar-toggler-icon"></span>
                    </button>

                    <div class="collapse navbar-collapse" id="navigation">
                        <ul class="navbar-nav ml-auto">
                            <li class="nav-item">
                                <a class="nav-link" href="https://perlweeklychallenge.org/">Home</a>
                            </li>
                            
                            <li class="nav-item">
                                <a class="nav-link" href="https://perlweeklychallenge.org/about">About</a>
                            </li>
                            
                            <li class="nav-item">
                                <a class="nav-link" href="https://perlweeklychallenge.org/chart">Chart</a>
                            </li>
                            
                            <li class="nav-item">
                                <a class="nav-link" href="https://perlweeklychallenge.org/champions">Champions</a>
                            </li>
                            
                            <li class="nav-item">
                                <a class="nav-link" href="https://perlweeklychallenge.org/team">Team</a>
                            </li>
                            
                            <li class="nav-item">
                                <a class="nav-link" href="https://perlweeklychallenge.org/challenges">Challenges</a>
                            </li>
                            
                            <li class="nav-item">
                                <a class="nav-link" href="https://perlweeklychallenge.org/p5-reviews">Perl/Review</a>
                            </li>
                            
                            <li class="nav-item">
                                <a class="nav-link" href="https://perlweeklychallenge.org/p6-reviews">Raku/Review</a>
                            </li>
                            
                            <li class="nav-item">
                                <a class="nav-link" href="https://perlweeklychallenge.org/recaps">Recaps</a>
                            </li>
                            
                            <li class="nav-item">
                                <a class="nav-link" href="https://perlweeklychallenge.org/blogs">Blogs</a>
                            </li>
                            
                            <li class="nav-item">
                                <a class="nav-link" href="https://perlweeklychallenge.org/faq">FAQ</a>
                            </li>
                            
                            <li class="nav-item">
                                <a class="nav-link" href="https://perlweeklychallenge.org/contact">Contact</a>
                            </li>
                            
                        </ul>
                    </div>
                </nav>
            </div>
        </div>
    </div>
</section>


<section class="global-page-header">
    <div class="container">
        <div class="row">
            <div class="col-md-12">
                <div class="block">
                    <h2>Ryan Thompson › Perl Weekly Review #053</h2>
                    <div class="portfolio-meta">
                        <span>Monday, Apr 6, 2020</span>|
                        <span> Tags:
                            perl
                        </span>
                    </div>
                </div>
            </div>
        </div>
    </div>
</section>

<section class="single-post">
    <div class="container">
        <div class="row">
            <div class="col-md-12">
                
                <div style="text-align: center" class="post-img">
                    <img class="img-fluid" alt="" src="https://perlweeklychallenge.org/images/blog/p5-review-challenge-053.jpg">
                </div>
                
                <div style="text-align: justify" class="post-content">
                    <p>Continues from <a href="/blog/review-challenge-052/">previous week</a>.</p>
<p>Welcome to the Perl review for Week 053 of the Weekly Challenge! For a quick overview, go through the <a href="/blog/perl-weekly-challenge-053/">original tasks</a> and <a href="/blog/recap-challenge-053/">recap</a> of the weekly challenge.</p>
<h2 id="getting-in-touch">Getting in Touch</h2>
<p><a href="mailto:rjt@cpan.org"><img src="/images/blog/Email.svg" height="50" width="50"> Email</a> › Email me (Ryan) with any feedback about this review.</p>
<p><a href="https://github.com/manwar/perlweeklychallenge"><img src="/images/blog/Github.svg" height="50" width="50"> GitHub</a> › Submit a pull request for any issues you may find with this page.</p>
<p><a href="https://twitter.com/perlwchallenge"><img src="/images/blog/Twitter.svg" height="50" width="50"> Twitter</a> › Join the discussion on Twitter!</p>
<p>We&rsquo;d greatly appreciate any feedback you&rsquo;d like to give.</p>
<h2 id="table-of-contents">Table of Contents</h2>
<h3 id="task-1--rotate-matrixtask1"><a href="#task1">Task 1 › Rotate Matrix</a></h3>
<p>[ <a href="#alicia-bielsa1">Alicia Bielsa</a>  | <a href="#andrezgz1">Andrezgz</a>  | <a href="#athanasius1">Athanasius</a>  | <a href="#cheok-yin-fung1">Cheok-Yin Fung</a>  | <a href="#colin-crain1">Colin Crain</a>  | <a href="#cristian-heredia1">Cristina Heredia</a>  | <a href="#dave-cross1">Dave Cross</a>  | <a href="#dave-jacoby1">Dave Jacoby</a>  | <a href="#duncan-c-white1">Duncan C. White</a>  | <a href="#e-choroba1">E. Choroba</a>  | <a href="#jaldhar-h-vyas1">Jaldhar H. Vyas</a>  | <a href="#javier-luque1">Javier Luque</a>  | <a href="#laurent-rosenfeld1">Laurent Rosenfeld</a>  | <a href="#lubos-kolouch1">Lubos Kolouch</a>  | <a href="#mohammad-anwar1">Mohammad S Anwar</a>  | <a href="#roger-bell-west1">Roger Bell West</a>  | <a href="#ruben-westerberg1">Ruben Westerberg</a>  | <a href="#ryan-thompson1">Ryan Thompson</a>  | <a href="#saiftynet1">Saif Ahmed</a>  | <a href="#user-person1">User Person</a>  | <a href="#wanderdoc1">Wanderdoc</a>  | <a href="#yet-ebreo1">Yet Ebreo</a>  ]</p>
<h3 id="task-2--vowel-stringstask2"><a href="#task2">Task 2 › Vowel Strings</a></h3>
<p>[ <a href="#alicia-bielsa2">Alicia Bielsa</a>  | <a href="#andrezgz2">Andrezgz</a>  | <a href="#athanasius2">Athanasius</a>  | <a href="#cheok-yin-fung2">Cheok-Yin Fung</a>  | <a href="#colin-crain2">Colin Crain</a>  | <a href="#dave-cross2">Dave Cross</a>  | <a href="#dave-jacoby2">Dave Jacoby</a>  | <a href="#duncan-c-white2">Duncan C. White</a>  | <a href="#e-choroba2">E. Choroba</a>  | <a href="#jaldhar-h-vyas2">Jaldhar H. Vyas</a>  | <a href="#javier-luque2">Javier Luque</a>  | <a href="#laurent-rosenfeld2">Laurent Rosenfeld</a>  | <a href="#lubos-kolouch2">Lubos Kolouch</a>  | <a href="#markus-holzer2">Markus Holzer</a>  | <a href="#mohammad-anwar2">Mohammad S Anwar</a>  | <a href="#pete-houston2">Pete Houston</a>  | <a href="#roger-bell-west2">Roger Bell West</a>  | <a href="#ruben-westerberg2">Ruben Westerberg</a>  | <a href="#ryan-thompson2">Ryan Thompson</a>  | <a href="#saiftynet2">Saif Ahmed</a>  | <a href="#user-person2">User Person</a>  | <a href="#wanderdoc2">Wanderdoc</a>  | <a href="#yet-ebreo2">Yet Ebreo</a>  ]</p>
<h3 id="blogsblogs"><a href="#blogs">Blogs</a></h3>
<hr>
<hr>
<h1 id="task1">Task #1 › Rotate Matrix</h1>
<p>The original task description:</p>
<p><em>Write a script to rotate the following matrix by given 90/180/270 degrees clockwise</em></p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-perl" data-lang="perl">[[ <span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">2</span>, <span style="color:#ae81ff">3</span> ],
 [ <span style="color:#ae81ff">4</span>, <span style="color:#ae81ff">5</span>, <span style="color:#ae81ff">6</span> ],
 [ <span style="color:#ae81ff">7</span>, <span style="color:#ae81ff">8</span>, <span style="color:#ae81ff">9</span> ]]
</code></pre></div><hr>
<p>Since the task asks us to rotate the matrix clockwise, what we have isn&rsquo;t quite the same as a matrix transposition (where rows and columns are swapped), but it&rsquo;s also not that far off, and can be solved in much the same way, looping over each cell and placing it in its correct position in the new array.</p>
<p>Most hackers wrote just one rotation subroutine, and then called it one, two, or three times, corresponding to 90, 180, or 270 degrees of rotation. While this is a bit slower, it avoids near-duplicated code.</p>
<h2 id="supported-inputs">Supported Inputs</h2>
<p>There was some variation in what shapes of matrices are supported. There were solutions with the following:</p>
<ul>
<li><strong>Task matrix only:</strong> Some solutions <em>only</em> support the specific matrix as given by the task description, meaning, the values are hard-coded.</li>
<li><strong>3x3 matrices:</strong> Some solutions support any 3x3 matrix, but other sizes are not supported.</li>
<li><strong>NxN square matrices:</strong> Some solutions accept any &ldquo;square&rdquo; matrix (i.e., same number of rows and columns)</li>
<li><strong>MxN matrices:</strong> The most general solutions support any arbitrary number of rows, and columns.</li>
</ul>
<p>If your program accepted an MxN matrix but produced incorrect results, I generally assumed you did not intend to support MxN matrices.</p>
<h2 id="stats">Stats</h2>
<ul>
<li>
<p>Number of submissions: <strong>22</strong></p>
</li>
<li>
<p>Total SLOC: <strong>1287</strong></p>
</li>
<li>
<p>Average SLOC: <strong>58</strong></p>
</li>
</ul>
<h2 id="alicia-bielsa1">Alicia Bielsa</h2>
<p><a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-053/alicia-bielsa/perl/ch-1.pl">Alicia Bielsa&rsquo;s solution</a> supports NxN (square) matrices. She defines a <code>rotateMatrix90Degrees</code> sub that does the hard work:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-perl" data-lang="perl"><span style="color:#66d9ef">sub</span> <span style="color:#a6e22e">rotateMatrix90Degrees</span> {
    <span style="color:#66d9ef">my</span> $refMatrix <span style="color:#f92672">=</span> shift;
    <span style="color:#66d9ef">my</span> @aNewMatrix <span style="color:#f92672">=</span> ();
    <span style="color:#66d9ef">foreach</span> <span style="color:#66d9ef">my</span> $x (<span style="color:#ae81ff">0</span><span style="color:#f92672">..</span>$#{$refMatrix}){
        <span style="color:#66d9ef">foreach</span> <span style="color:#66d9ef">my</span> $y (<span style="color:#ae81ff">0</span><span style="color:#f92672">..</span>$#{$$refMatrix[$x]}){
            $aNewMatrix[$y][$#aMatrix <span style="color:#f92672">-</span> $x]  <span style="color:#f92672">=</span> $$refMatrix[$x][$y]  ;
        }
    }
    <span style="color:#66d9ef">return</span> @aNewMatrix;
}
</code></pre></div><p>She then defines a <code>rotateMatrix</code> sub that accepts the matrix, and a rotation angle in degrees:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-perl" data-lang="perl"><span style="color:#66d9ef">sub</span> <span style="color:#a6e22e">rotateMatrix</span> {
    <span style="color:#66d9ef">my</span> $refMatrix <span style="color:#f92672">=</span> shift;
    <span style="color:#66d9ef">my</span> $degrees <span style="color:#f92672">=</span> shift;
    <span style="color:#66d9ef">my</span> @aMatrixRotating <span style="color:#f92672">=</span>@{$refMatrix};
    <span style="color:#66d9ef">while</span> ( $degrees <span style="color:#f92672">/</span> <span style="color:#ae81ff">90</span> <span style="color:#f92672">&gt;=</span> <span style="color:#ae81ff">1</span>  ) {
        @aMatrixRotating <span style="color:#f92672">=</span> rotateMatrix90Degrees(<span style="color:#f92672">\</span>@aMatrixRotating);
        $degrees <span style="color:#f92672">-=</span> <span style="color:#ae81ff">90</span>;
    }
    <span style="color:#66d9ef">return</span> @aMatrixRotating;
}
</code></pre></div><p>And, finally, <code>drawMatrix</code> is a nice touch:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-perl" data-lang="perl"><span style="color:#66d9ef">sub</span> <span style="color:#a6e22e">drawMatrix</span> {
    <span style="color:#66d9ef">my</span> $refMatrix <span style="color:#f92672">=</span> shift;
    <span style="color:#66d9ef">foreach</span> <span style="color:#66d9ef">my</span> $row (@{$refMatrix}){
        <span style="color:#66d9ef">print</span> <span style="color:#e6db74">&#34;[ &#34;</span><span style="color:#f92672">.</span>join(<span style="color:#e6db74">&#39;, &#39;</span>,@{$row})<span style="color:#f92672">.</span> <span style="color:#e6db74">&#34; ]\n&#34;</span>;
    }
}
</code></pre></div><h2 id="andrezgz1">Andrezgz</h2>
<p><a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-053/andrezgz/perl/ch-1.pl">Andrezgz&rsquo;s solution</a> supports MxN matrices, by calling their 90-degree <code>rotate</code> sub as many times as needed:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-perl" data-lang="perl"><span style="color:#75715e"># Rotate matrix clockwise the number of times specified</span>
$matrix <span style="color:#f92672">=</span> rotate($matrix) <span style="color:#66d9ef">for</span> (<span style="color:#ae81ff">1</span> <span style="color:#f92672">..</span> $rotation);

<span style="color:#75715e"># Rotated matrix is printed</span>
<span style="color:#66d9ef">print</span> <span style="color:#e6db74">&#39;[ &#39;</span>, join(<span style="color:#e6db74">&#39; , &#39;</span>, $matrix<span style="color:#f92672">-&gt;</span>[$_]<span style="color:#f92672">-&gt;</span>@<span style="color:#960050;background-color:#1e0010">*</span>) , <span style="color:#e6db74">&#34; ]\n&#34;</span>
    <span style="color:#66d9ef">for</span> ( <span style="color:#ae81ff">0</span> <span style="color:#f92672">..</span> $matrix<span style="color:#f92672">-&gt;</span>@<span style="color:#960050;background-color:#1e0010">*</span> <span style="color:#960050;background-color:#1e0010">-</span> 1 );

<span style="color:#66d9ef">sub</span> <span style="color:#a6e22e">rotate</span> {
    <span style="color:#66d9ef">my</span> $input <span style="color:#f92672">=</span> shift;

    <span style="color:#66d9ef">my</span> $output <span style="color:#f92672">=</span> <span style="color:#f92672">[]</span>;
    <span style="color:#66d9ef">foreach</span> <span style="color:#66d9ef">my</span> $r ( <span style="color:#ae81ff">0</span> <span style="color:#f92672">..</span> $input<span style="color:#f92672">-&gt;</span>@<span style="color:#960050;background-color:#1e0010">*</span> <span style="color:#960050;background-color:#1e0010">-</span> 1 ){
        <span style="color:#66d9ef">foreach</span> <span style="color:#66d9ef">my</span> $c ( <span style="color:#ae81ff">0</span><span style="color:#f92672">..</span> $input<span style="color:#f92672">-&gt;</span>[<span style="color:#ae81ff">0</span>]<span style="color:#f92672">-&gt;</span>@<span style="color:#960050;background-color:#1e0010">*</span> <span style="color:#960050;background-color:#1e0010">-</span> 1 ){
            <span style="color:#75715e"># Each element of the input matrix is appended to the output matrix</span>
            <span style="color:#75715e"># at the beginning of the row defined by its column from the input matrix</span>
            unshift @{$output<span style="color:#f92672">-&gt;</span>[$c]}, $input<span style="color:#f92672">-&gt;</span>[$r]<span style="color:#f92672">-&gt;</span>[$c];
        }
    }

    <span style="color:#66d9ef">return</span> $output;
}
</code></pre></div><h2 id="athanasius1">Athanasius</h2>
<p><a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-053/athanasius/perl/ch-1.pl">Athanasius&rsquo;s solution</a> supports 3x3 matrices:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-perl" data-lang="perl"><span style="color:#66d9ef">sub</span> <span style="color:#a6e22e">rotate</span> {
    <span style="color:#66d9ef">my</span> ( $degrees, $old_matrix ) <span style="color:#f92672">=</span> @_;

    exists $ROTATIONS{$degrees}
      <span style="color:#f92672">or</span> die <span style="color:#e6db74">&#34;ERROR: Rotation of $degrees° is not supported\n&#34;</span>;

    <span style="color:#66d9ef">my</span> @new_matrix;

    <span style="color:#66d9ef">for</span> <span style="color:#66d9ef">my</span> $r_new ( <span style="color:#ae81ff">0</span> <span style="color:#f92672">..</span> <span style="color:#ae81ff">2</span> )    <span style="color:#75715e"># Rows</span>
    {
        <span style="color:#66d9ef">for</span> <span style="color:#66d9ef">my</span> $c_new ( <span style="color:#ae81ff">0</span> <span style="color:#f92672">..</span> <span style="color:#ae81ff">2</span> )    <span style="color:#75715e"># Columns</span>
        {
            <span style="color:#66d9ef">my</span> ( $r_old, $c_old ) <span style="color:#f92672">=</span> $ROTATIONS{$degrees}<span style="color:#f92672">-&gt;</span>[$r_new][$c_new]<span style="color:#f92672">-&gt;</span>@<span style="color:#960050;background-color:#1e0010">*;</span>

            <span style="color:#960050;background-color:#1e0010">$</span>new_matrix[$r_new]<span style="color:#f92672">-&gt;</span>[$c_new] <span style="color:#f92672">=</span> $old_matrix<span style="color:#f92672">-&gt;</span>[$r_old][$c_old];
        }
    }

    <span style="color:#66d9ef">return</span> <span style="color:#f92672">\</span>@new_matrix;
}
</code></pre></div><h2 id="cheok-yin-fung1">Cheok-Yin Fung</h2>
<p><a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-053/cheok-yin-fung/perl/ch-1.pl">Cheok-Yin Fung&rsquo;s solution</a> gives us <code>rcaqx</code> which is short for &ldquo;Rotation_Clockwise_A_Quarter, x for multiple&rdquo;. Rolls right off the tongue! It supports 3x3 matrices:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-perl" data-lang="perl"><span style="color:#66d9ef">sub</span> <span style="color:#a6e22e">rcaqx</span> {
    <span style="color:#66d9ef">if</span> ($_[<span style="color:#ae81ff">0</span>]<span style="color:#f92672">&gt;=</span><span style="color:#ae81ff">1</span>) {
        <span style="color:#66d9ef">my</span> %nhash;
        <span style="color:#66d9ef">for</span> (<span style="color:#ae81ff">0</span><span style="color:#f92672">..</span><span style="color:#ae81ff">8</span>) {
            <span style="color:#66d9ef">if</span> ( $cp[$_] <span style="color:#f92672">&gt;=</span> <span style="color:#ae81ff">0</span> ) {
                $nhash{ $cp[$_] } <span style="color:#f92672">=</span> $hash{ ($cp[($_ )]<span style="color:#f92672">+</span><span style="color:#ae81ff">2</span>) % 8 };
            }
        }
        $nhash{<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>} <span style="color:#f92672">=</span> $hash{<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>};
        %hash <span style="color:#f92672">=</span> %nhash;
        rcaqx($_[<span style="color:#ae81ff">0</span>]<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>);
    }
}

rcaqx($ANGLE<span style="color:#f92672">/</span><span style="color:#ae81ff">90</span>);
</code></pre></div><hr>
<p>However, that&rsquo;s not all! Cheok Yin submitted a <a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-053/cheok-yin-fung/perl/ch-1a.pl">second solution</a> for Task #1, which is more advanced. It supports any square (NxN) matrix, and makes use of a custom <code>xy</code> class:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-perl" data-lang="perl"><span style="color:#66d9ef">package</span> xy;
<span style="color:#66d9ef">use</span> strict;

<span style="color:#66d9ef">sub</span> <span style="color:#a6e22e">new</span> {
    <span style="color:#66d9ef">my</span> ($class) <span style="color:#f92672">=</span> @_;
    bless{
        _value<span style="color:#f92672">=&gt;</span> $_[<span style="color:#ae81ff">1</span>],
        _x<span style="color:#f92672">=&gt;</span>$_[<span style="color:#ae81ff">2</span>],
        _y<span style="color:#f92672">=&gt;</span>$_[<span style="color:#ae81ff">3</span>],
      }, $class;
}

<span style="color:#66d9ef">sub</span> <span style="color:#a6e22e">x</span>{ $_[<span style="color:#ae81ff">0</span>]<span style="color:#f92672">-&gt;</span>{_x}}
<span style="color:#66d9ef">sub</span> <span style="color:#a6e22e">y</span>{ $_[<span style="color:#ae81ff">0</span>]<span style="color:#f92672">-&gt;</span>{_y}}
<span style="color:#66d9ef">sub</span> <span style="color:#a6e22e">value</span>{ $_[<span style="color:#ae81ff">0</span>]<span style="color:#f92672">-&gt;</span>{_value} }
</code></pre></div><p>The new and improved <code>rcaqx</code> looks like this:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-perl" data-lang="perl"><span style="color:#66d9ef">sub</span> <span style="color:#a6e22e">rcaqx</span> {
    <span style="color:#66d9ef">if</span> ($_[<span style="color:#ae81ff">2</span>]<span style="color:#f92672">&gt;=</span><span style="color:#ae81ff">1</span>) {
        <span style="color:#66d9ef">my</span> ($xcoord, $ycoord) <span style="color:#f92672">=</span> ($_[<span style="color:#ae81ff">0</span>], $_[<span style="color:#ae81ff">1</span>]);
        $_[<span style="color:#ae81ff">0</span>] <span style="color:#f92672">=</span> $ycoord;
        $_[<span style="color:#ae81ff">1</span>] <span style="color:#f92672">=</span> <span style="color:#f92672">-</span>$xcoord;
        <span style="color:#66d9ef">return</span> rcaqx($_[<span style="color:#ae81ff">0</span>], $_[<span style="color:#ae81ff">1</span>], $_[<span style="color:#ae81ff">2</span>]<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>);
    } <span style="color:#66d9ef">else</span> {<span style="color:#66d9ef">return</span> ($_[<span style="color:#ae81ff">0</span>], $_[<span style="color:#ae81ff">1</span>])}
}
</code></pre></div><p>Coordinate translation helpers:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-perl" data-lang="perl"><span style="color:#66d9ef">sub</span> <span style="color:#a6e22e">translation_add_negT</span> {
    $_[<span style="color:#ae81ff">0</span>] <span style="color:#f92672">-=</span> $T<span style="color:#f92672">-&gt;</span>[<span style="color:#ae81ff">0</span>];
    $_[<span style="color:#ae81ff">1</span>] <span style="color:#f92672">-=</span> $T<span style="color:#f92672">-&gt;</span>[<span style="color:#ae81ff">1</span>];
    <span style="color:#66d9ef">return</span> ($_[<span style="color:#ae81ff">0</span>], $_[<span style="color:#ae81ff">1</span>])
}

<span style="color:#66d9ef">sub</span> <span style="color:#a6e22e">translation_add_T</span> {
    $_[<span style="color:#ae81ff">0</span>] <span style="color:#f92672">+=</span> $T<span style="color:#f92672">-&gt;</span>[<span style="color:#ae81ff">0</span>];
    $_[<span style="color:#ae81ff">1</span>] <span style="color:#f92672">+=</span> $T<span style="color:#f92672">-&gt;</span>[<span style="color:#ae81ff">1</span>];
    <span style="color:#66d9ef">return</span> ($_[<span style="color:#ae81ff">0</span>], $_[<span style="color:#ae81ff">1</span>])
}
</code></pre></div><p>And finally, here is how all of the above routines come together to actually perform the rotation:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-perl" data-lang="perl"><span style="color:#66d9ef">for</span> $i (<span style="color:#ae81ff">1</span><span style="color:#f92672">..</span>$N<span style="color:#f92672">*</span>$N) {
    $newmatrix<span style="color:#f92672">-&gt;</span>[$i] <span style="color:#f92672">=</span> xy<span style="color:#f92672">-&gt;</span><span style="color:#66d9ef">new</span>($matrix<span style="color:#f92672">-&gt;</span>[$i]<span style="color:#f92672">-&gt;</span>value,
        translation_add_negT(rcaqx ((translation_add_T(
                        $matrix<span style="color:#f92672">-&gt;</span>[$i]<span style="color:#f92672">-&gt;</span>x, $matrix<span style="color:#f92672">-&gt;</span>[$i]<span style="color:#f92672">-&gt;</span>y) ), $ANGLE<span style="color:#f92672">/</span><span style="color:#ae81ff">90</span> )) );

    $coordinateplane[position( $newmatrix<span style="color:#f92672">-&gt;</span>[$i]<span style="color:#f92672">-&gt;</span>x, $newmatrix<span style="color:#f92672">-&gt;</span>[$i]<span style="color:#f92672">-&gt;</span>y )]
         <span style="color:#f92672">=</span> $newmatrix<span style="color:#f92672">-&gt;</span>[$i]<span style="color:#f92672">-&gt;</span>value;
}
</code></pre></div><p>Cheok Yin is now blogging twice per week about the PWC! (See Cheok Yin&rsquo;s <a href="#cheok-yin-fung2">Task #2 solution</a> for a link to her second blog post.)</p>
<p><strong>Blog</strong> › <a href="http://blogs.perl.org/users/c_y_fung/2020/03/rotation-in-r2---cys-take-on-pwc053-task-1.html">Rotation in R^2 - CY&rsquo;s take on PWC#053 Task 1</a></p>
<h2 id="colin-crain1">Colin Crain</h2>
<p><a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-053/colin-crain/perl/ch-1.pl">Colin Crain&rsquo;s solution</a> went the extra mile and implemented separate routines, optimized for each of the 90, 180, and 270 degree rotations, and his is the first solution we&rsquo;ve seen that supports MxN matrices:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-perl" data-lang="perl"><span style="color:#66d9ef">sub</span> <span style="color:#a6e22e">rotate90</span> {
<span style="color:#75715e">## matrix is an array ref of array refs</span>
<span style="color:#75715e">## zip and reverse subarray elements</span>
    <span style="color:#66d9ef">my</span> $matrix <span style="color:#f92672">=</span> shift;
    <span style="color:#66d9ef">my</span> $output;

    <span style="color:#66d9ef">my</span> $cols <span style="color:#f92672">=</span> scalar $matrix<span style="color:#f92672">-&gt;</span>[<span style="color:#ae81ff">0</span>]<span style="color:#f92672">-&gt;</span>@<span style="color:#960050;background-color:#1e0010">*;</span>     <span style="color:#960050;background-color:#1e0010">##</span> subarray elements, <span style="color:#f92672">or</span> num of cols
    <span style="color:#66d9ef">my</span> $rows <span style="color:#f92672">=</span> scalar $matrix<span style="color:#f92672">-&gt;</span>@<span style="color:#960050;background-color:#1e0010">*;</span>          <span style="color:#960050;background-color:#1e0010">##</span> array elements,    <span style="color:#f92672">or</span> num of rows

    <span style="color:#66d9ef">for</span> <span style="color:#66d9ef">my</span> $idx ( <span style="color:#ae81ff">0</span><span style="color:#f92672">..</span>$cols<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span> ) {            <span style="color:#75715e">## for each index in a row</span>
        <span style="color:#66d9ef">my</span> @newrow;
        <span style="color:#66d9ef">for</span> <span style="color:#66d9ef">my</span> $row ( <span style="color:#ae81ff">0</span><span style="color:#f92672">..</span>$rows<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span> ) {        <span style="color:#75715e">## for each row</span>
            unshift @newrow, $matrix<span style="color:#f92672">-&gt;</span>[$row]<span style="color:#f92672">-&gt;</span>[$idx];        <span style="color:#75715e">## reverse rows</span>
        }
        push $output<span style="color:#f92672">-&gt;</span>@<span style="color:#960050;background-color:#1e0010">*</span>, <span style="color:#f92672">\</span>@newrow;                          <span style="color:#75715e">## forward cols</span>
    }
    <span style="color:#66d9ef">return</span> $output;
}
</code></pre></div><div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-perl" data-lang="perl"><span style="color:#66d9ef">sub</span> <span style="color:#a6e22e">rotate180</span> {
<span style="color:#75715e">## matrix is an array ref of array refs</span>
<span style="color:#75715e">## reverse each subarray, then reverse the outer array</span>
    <span style="color:#66d9ef">my</span> $matrix <span style="color:#f92672">=</span> shift;
    <span style="color:#66d9ef">my</span> $output;

    <span style="color:#66d9ef">for</span> <span style="color:#66d9ef">my</span> $row ( $matrix<span style="color:#f92672">-&gt;</span>@<span style="color:#960050;background-color:#1e0010">*</span> ) {
        <span style="color:#66d9ef">my</span> @newrow <span style="color:#f92672">=</span> reverse $row<span style="color:#f92672">-&gt;</span>@<span style="color:#960050;background-color:#1e0010">*;</span>
        unshift $output<span style="color:#f92672">-&gt;</span>@<span style="color:#960050;background-color:#1e0010">*</span>, <span style="color:#f92672">\</span>@newrow;
    }
    <span style="color:#66d9ef">return</span> $output;

}
</code></pre></div><div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-perl" data-lang="perl"><span style="color:#66d9ef">sub</span> <span style="color:#a6e22e">rotate270</span> {
<span style="color:#75715e">## matrix is an array ref of array refs</span>
<span style="color:#75715e">## zip and reverse subarrays in outer array</span>
    <span style="color:#66d9ef">my</span> $matrix <span style="color:#f92672">=</span> shift;
    <span style="color:#66d9ef">my</span> $output;

    <span style="color:#66d9ef">my</span> $cols <span style="color:#f92672">=</span> scalar $matrix<span style="color:#f92672">-&gt;</span>[<span style="color:#ae81ff">0</span>]<span style="color:#f92672">-&gt;</span>@<span style="color:#960050;background-color:#1e0010">*;</span>     <span style="color:#960050;background-color:#1e0010">##</span> subarray elements, <span style="color:#f92672">or</span> num of cols
    <span style="color:#66d9ef">my</span> $rows <span style="color:#f92672">=</span> scalar $matrix<span style="color:#f92672">-&gt;</span>@<span style="color:#960050;background-color:#1e0010">*;</span>          <span style="color:#960050;background-color:#1e0010">##</span> array elements, <span style="color:#f92672">or</span> num of rows

    <span style="color:#66d9ef">for</span> <span style="color:#66d9ef">my</span> $idx ( <span style="color:#ae81ff">0</span><span style="color:#f92672">..</span>$cols<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span> ) {
        <span style="color:#66d9ef">my</span> @newrow;
        <span style="color:#66d9ef">for</span> <span style="color:#66d9ef">my</span> $row ( <span style="color:#ae81ff">0</span><span style="color:#f92672">..</span>$rows<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span> ) {
            push @newrow, $matrix<span style="color:#f92672">-&gt;</span>[$row]<span style="color:#f92672">-&gt;</span>[$idx];     <span style="color:#75715e">## forward rows</span>
        }
        unshift $output<span style="color:#f92672">-&gt;</span>@<span style="color:#960050;background-color:#1e0010">*</span>, <span style="color:#f92672">\</span>@newrow;                 <span style="color:#75715e">## reverse cols</span>
    }
    <span style="color:#66d9ef">return</span> $output;
}
</code></pre></div><h2 id="cristian-heredia1">Cristina Heredia</h2>
<p><a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-053/cristian-heredia/perl/ch-1.pl">Cristina Heredia&rsquo;s solution</a> has all three allowed rotations for the task&rsquo;s matrix hard-coded:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-perl" data-lang="perl"><span style="color:#66d9ef">sub</span> <span style="color:#a6e22e">rotateMatix</span> {

    <span style="color:#66d9ef">if</span> ($choise <span style="color:#f92672">==</span> <span style="color:#e6db74">&#39;90&#39;</span>) {
        @array <span style="color:#f92672">=</span> (
        [<span style="color:#ae81ff">7</span>, <span style="color:#ae81ff">4</span>, <span style="color:#ae81ff">1</span>],
        [<span style="color:#ae81ff">8</span>, <span style="color:#ae81ff">5</span>, <span style="color:#ae81ff">2</span>],
        [<span style="color:#ae81ff">9</span>, <span style="color:#ae81ff">6</span>, <span style="color:#ae81ff">3</span>]
        );
        printArray();
    }
    <span style="color:#66d9ef">elsif</span> ($choise <span style="color:#f92672">==</span> <span style="color:#e6db74">&#39;180&#39;</span>) {
        @array <span style="color:#f92672">=</span> (
        [<span style="color:#ae81ff">9</span>, <span style="color:#ae81ff">8</span>, <span style="color:#ae81ff">7</span>],
        [<span style="color:#ae81ff">6</span>, <span style="color:#ae81ff">5</span>, <span style="color:#ae81ff">4</span>],
        [<span style="color:#ae81ff">3</span>, <span style="color:#ae81ff">2</span>, <span style="color:#ae81ff">1</span>]
        );
        printArray();
    }
    <span style="color:#66d9ef">elsif</span> ($choise <span style="color:#f92672">==</span> <span style="color:#e6db74">&#39;270&#39;</span>) {
        @array <span style="color:#f92672">=</span> (
        [<span style="color:#ae81ff">3</span>, <span style="color:#ae81ff">6</span>, <span style="color:#ae81ff">9</span>],
        [<span style="color:#ae81ff">2</span>, <span style="color:#ae81ff">5</span>, <span style="color:#ae81ff">8</span>],
        [<span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">4</span>, <span style="color:#ae81ff">7</span>]
        );
        printArray();
    }
    <span style="color:#66d9ef">else</span> {
        <span style="color:#66d9ef">print</span> <span style="color:#e6db74">&#34;The value $choise isn&#39;t valid, please choose between: 90, 180 or 270\n&#34;</span>;
        $choise <span style="color:#f92672">=</span> <span style="color:#f92672">&lt;&gt;</span>;
        $choise <span style="color:#f92672">=~</span> <span style="color:#e6db74">s/^\s+|\s+$//g</span>;
        rotateMatix();
    }
}
</code></pre></div><p>She provides a <code>printArray</code> sub to pretty-print the output matrix:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-perl" data-lang="perl"><span style="color:#66d9ef">sub</span> <span style="color:#a6e22e">printArray</span> {
    <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">my</span> $i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; $i <span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">3</span>; $i<span style="color:#f92672">++</span>) {
        <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">my</span> $j <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; $j <span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">3</span>; $j<span style="color:#f92672">++</span>) {
            <span style="color:#66d9ef">print</span> <span style="color:#e6db74">&#34;$array[$i][$j] &#34;</span>;
        }
        <span style="color:#66d9ef">print</span> <span style="color:#e6db74">&#34;\n&#34;</span>;
    }
}
</code></pre></div><h2 id="dave-cross1">Dave Cross</h2>
<p><a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-053/dave-cross/perl/ch-1.pl">Dave Cross&rsquo;s solution</a> supports square (NxN) matrices. The <code>rotate_matrix</code> sub handles rotations by any of 90, 180, and 270 degrees:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-perl" data-lang="perl"><span style="color:#66d9ef">sub</span> <span style="color:#a6e22e">rotate_matrix</span> {
    <span style="color:#66d9ef">my</span> ( $matrix, $degrees ) <span style="color:#f92672">=</span> @_;

    die <span style="color:#e6db74">&#34;Must give rotation in degrees\n&#34;</span> <span style="color:#66d9ef">unless</span> $degrees;
    die <span style="color:#e6db74">&#34;Must rotate by 90, 180 or 270 degrees\n&#34;</span>
      <span style="color:#66d9ef">if</span> $degrees <span style="color:#f92672">=~</span><span style="color:#e6db74"> /\D/</span>
      <span style="color:#f92672">or</span> $degrees % 90
      <span style="color:#f92672">or</span> $degrees <span style="color:#f92672">&gt;</span> <span style="color:#ae81ff">270</span>;

    <span style="color:#66d9ef">my</span> $rotated_matrix;

    <span style="color:#66d9ef">for</span> ( <span style="color:#ae81ff">1</span> <span style="color:#f92672">..</span> $degrees <span style="color:#f92672">/</span> <span style="color:#ae81ff">90</span> ) {
        $rotated_matrix <span style="color:#f92672">=</span> <span style="color:#f92672">[]</span>;
        <span style="color:#66d9ef">for</span> <span style="color:#66d9ef">my</span> $i ( <span style="color:#ae81ff">0</span> <span style="color:#f92672">..</span> $#$matrix ) {
            <span style="color:#66d9ef">for</span> <span style="color:#66d9ef">my</span> $j ( <span style="color:#ae81ff">0</span> <span style="color:#f92672">..</span> $#{ $matrix<span style="color:#f92672">-&gt;</span>[$i] } ) {
                $rotated_matrix<span style="color:#f92672">-&gt;</span>[$j][ $#{ $matrix<span style="color:#f92672">-&gt;</span>[$i] } <span style="color:#f92672">-</span> $i ] <span style="color:#f92672">=</span>
                  $matrix<span style="color:#f92672">-&gt;</span>[$i][$j];
            }
        }
        $matrix <span style="color:#f92672">=</span> $rotated_matrix;
    }

    <span style="color:#66d9ef">return</span> $rotated_matrix;
}
</code></pre></div><h2 id="dave-jacoby1">Dave Jacoby</h2>
<p><a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-053/dave-jacoby/perl/ch-1.pl">Dave Jacoby&rsquo;s solution</a> supports MxN matrices, and provides separate routines for each rotation amount:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-perl" data-lang="perl"><span style="color:#66d9ef">sub</span> <span style="color:#a6e22e">rotate_90</span>( $array ) {
    <span style="color:#66d9ef">my</span> $x      <span style="color:#f92672">=</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span> <span style="color:#f92672">+</span> scalar $array<span style="color:#f92672">-&gt;</span>@<span style="color:#960050;background-color:#1e0010">*;</span>
    my $y      <span style="color:#f92672">=</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span> <span style="color:#f92672">+</span> scalar $array<span style="color:#f92672">-&gt;</span>[<span style="color:#ae81ff">0</span>]<span style="color:#f92672">-&gt;</span>@<span style="color:#960050;background-color:#1e0010">*;</span>
    my $output <span style="color:#f92672">=</span> <span style="color:#f92672">[]</span>;
    <span style="color:#66d9ef">for</span> <span style="color:#66d9ef">my</span> $i ( <span style="color:#ae81ff">0</span> <span style="color:#f92672">..</span> $x ) {
        <span style="color:#66d9ef">my</span> $jj <span style="color:#f92672">=</span> $i;
        <span style="color:#66d9ef">for</span> <span style="color:#66d9ef">my</span> $j ( <span style="color:#ae81ff">0</span> <span style="color:#f92672">..</span> $y ) {
            <span style="color:#66d9ef">my</span> $ii <span style="color:#f92672">=</span> $y <span style="color:#f92672">-</span> $j;
            $output<span style="color:#f92672">-&gt;</span>[$i][$j] <span style="color:#f92672">=</span> int $array<span style="color:#f92672">-&gt;</span>[$ii][$jj];
        }
    }
    <span style="color:#66d9ef">return</span> $output;
}

<span style="color:#66d9ef">sub</span> <span style="color:#a6e22e">rotate_180</span>( $array ) {
    <span style="color:#66d9ef">my</span> $x      <span style="color:#f92672">=</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span> <span style="color:#f92672">+</span> scalar $array<span style="color:#f92672">-&gt;</span>@<span style="color:#960050;background-color:#1e0010">*;</span>
    my $y      <span style="color:#f92672">=</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span> <span style="color:#f92672">+</span> scalar $array<span style="color:#f92672">-&gt;</span>[<span style="color:#ae81ff">0</span>]<span style="color:#f92672">-&gt;</span>@<span style="color:#960050;background-color:#1e0010">*;</span>
    my $output <span style="color:#f92672">=</span> <span style="color:#f92672">[]</span>;
    <span style="color:#66d9ef">for</span> <span style="color:#66d9ef">my</span> $i ( <span style="color:#ae81ff">0</span> <span style="color:#f92672">..</span> $x ) {
        <span style="color:#66d9ef">my</span> $jj <span style="color:#f92672">=</span> $x <span style="color:#f92672">-</span> $i;
        <span style="color:#66d9ef">for</span> <span style="color:#66d9ef">my</span> $j ( <span style="color:#ae81ff">0</span> <span style="color:#f92672">..</span> $y ) {
            <span style="color:#66d9ef">my</span> $ii <span style="color:#f92672">=</span> $y <span style="color:#f92672">-</span> $j;
            $output<span style="color:#f92672">-&gt;</span>[$i][$j] <span style="color:#f92672">=</span> int $array<span style="color:#f92672">-&gt;</span>[$ii][$jj];
        }
    }
    <span style="color:#66d9ef">return</span> $output;
}

<span style="color:#66d9ef">sub</span> <span style="color:#a6e22e">rotate_270</span>($array) {
    <span style="color:#66d9ef">my</span> $x      <span style="color:#f92672">=</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span> <span style="color:#f92672">+</span> scalar $array<span style="color:#f92672">-&gt;</span>@<span style="color:#960050;background-color:#1e0010">*;</span>
    my $y      <span style="color:#f92672">=</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span> <span style="color:#f92672">+</span> scalar $array<span style="color:#f92672">-&gt;</span>[<span style="color:#ae81ff">0</span>]<span style="color:#f92672">-&gt;</span>@<span style="color:#960050;background-color:#1e0010">*;</span>
    my $output <span style="color:#f92672">=</span> <span style="color:#f92672">[]</span>;
    <span style="color:#66d9ef">for</span> <span style="color:#66d9ef">my</span> $i ( <span style="color:#ae81ff">0</span> <span style="color:#f92672">..</span> $x ) {
        <span style="color:#66d9ef">my</span> $jj <span style="color:#f92672">=</span> $x <span style="color:#f92672">-</span> $i;
        <span style="color:#66d9ef">for</span> <span style="color:#66d9ef">my</span> $j ( <span style="color:#ae81ff">0</span> <span style="color:#f92672">..</span> $y ) {
            <span style="color:#66d9ef">my</span> $ii <span style="color:#f92672">=</span> $j;
            $output<span style="color:#f92672">-&gt;</span>[$i][$j] <span style="color:#f92672">=</span> int $array<span style="color:#f92672">-&gt;</span>[$ii][$jj];
        }
    }
    <span style="color:#66d9ef">return</span> $output;
}
</code></pre></div><p><strong>Blog</strong> › <a href="https://jacoby.github.io/2020/03/23/rotate-your-matrix-and-string-your-vowels.html">Rotate Your Matrix and String Your Vowels</a></p>
<h2 id="duncan-c-white1">Duncan C. White</h2>
<p><a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-053/duncan-c-white/perl/ch-1.pl">Duncan C. White&rsquo;s solution</a> supports 3x3 matrices, but the fun part is his OO implementation which overrides stringification to handle the matrix pretty-printing:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-perl" data-lang="perl"><span style="color:#66d9ef">package</span> Matrix;

<span style="color:#66d9ef">use</span> parent <span style="color:#e6db74">&#34;Clone&#34;</span>;
<span style="color:#66d9ef">use</span> overload <span style="color:#e6db74">&#39;&#34;&#34;&#39;</span> <span style="color:#f92672">=&gt;</span> <span style="color:#f92672">\&amp;</span>as_str;

<span style="color:#66d9ef">sub</span> <span style="color:#a6e22e">as_str</span> ($) {
    <span style="color:#66d9ef">my</span>( $self ) <span style="color:#f92672">=</span> @_;

    <span style="color:#66d9ef">my</span> @r <span style="color:#f92672">=</span> map { join( <span style="color:#e6db74">&#39;, &#39;</span>, @$_ ) } @$self;
    <span style="color:#66d9ef">my</span> $str <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;\n&#34;</span> <span style="color:#f92672">.</span> join( <span style="color:#e6db74">&#34;\n&#34;</span>, @r ) <span style="color:#f92672">.</span> <span style="color:#e6db74">&#34;\n&#34;</span>;
    <span style="color:#75715e">#say &#34;debug: $str&#34;;</span>
    <span style="color:#66d9ef">return</span> $str;
}
</code></pre></div><p>The constructor accepts a string such as <code>1 2 3/4 5 6/7 8 9</code>:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-perl" data-lang="perl">method <span style="color:#66d9ef">new</span>( $class: $matrixstr ) {
    <span style="color:#66d9ef">my</span> $mat <span style="color:#f92672">=</span> <span style="color:#f92672">[]</span>;
    <span style="color:#66d9ef">if</span>( $matrixstr ) {
        <span style="color:#66d9ef">my</span> @row <span style="color:#f92672">=</span> split( m<span style="color:#f92672">|/|</span>, $matrixstr );
        die <span style="color:#e6db74">&#34;Matrix-&gt;new( $matrixstr ): badly formed matrix string, should be 2 &#39;/&#39;s\n&#34;</span>
            <span style="color:#66d9ef">unless</span> @row <span style="color:#f92672">==</span> <span style="color:#ae81ff">3</span>;
        <span style="color:#66d9ef">foreach</span> <span style="color:#66d9ef">my</span> $rowstr (@row) {
            <span style="color:#66d9ef">my</span> @col <span style="color:#f92672">=</span> split(<span style="color:#e6db74"> /\s+/</span>, $rowstr );
            die <span style="color:#e6db74">&#34;Matrix-&gt;new( $matrixstr ): badly formed matrix string, row $rowstr\n&#34;</span>
                <span style="color:#66d9ef">unless</span> @col <span style="color:#f92672">==</span> <span style="color:#ae81ff">3</span>;
            push @$mat, <span style="color:#f92672">\</span>@col;
        }
    }
    <span style="color:#66d9ef">return</span> bless $mat, $class;
}
</code></pre></div><p>And finally the <code>rotate90</code> method does <code>$n</code> clockwise rotation(s):</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-perl" data-lang="perl">method rotate90( $n ) {
    $n %<span style="color:#960050;background-color:#1e0010">=</span> 4;
    <span style="color:#66d9ef">for</span> <span style="color:#66d9ef">my</span> $i (<span style="color:#ae81ff">1</span><span style="color:#f92672">..</span>$n) {
        <span style="color:#66d9ef">my</span> $mat <span style="color:#f92672">=</span> Matrix<span style="color:#f92672">-&gt;</span><span style="color:#66d9ef">new</span>( <span style="color:#e6db74">&#34;&#34;</span> );
        <span style="color:#66d9ef">foreach</span> <span style="color:#66d9ef">my</span> $col (<span style="color:#ae81ff">0</span><span style="color:#f92672">..</span><span style="color:#ae81ff">2</span>) {
            <span style="color:#66d9ef">my</span> @newrow <span style="color:#f92672">=</span> ();
            <span style="color:#66d9ef">foreach</span> <span style="color:#66d9ef">my</span> $row (<span style="color:#ae81ff">2</span>,<span style="color:#ae81ff">1</span>,<span style="color:#ae81ff">0</span>) {
                push @newrow, $self<span style="color:#f92672">-&gt;</span>[$row][$col];
            }
            $mat<span style="color:#f92672">-&gt;</span>[$col] <span style="color:#f92672">=</span> <span style="color:#f92672">\</span>@newrow;
        }
        @$self <span style="color:#f92672">=</span> @$mat;
    }
}
</code></pre></div><p>The package is then used like this:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-perl" data-lang="perl"><span style="color:#75715e"># initial matrix</span>
<span style="color:#66d9ef">my</span> $initmat <span style="color:#f92672">=</span> Matrix<span style="color:#f92672">-&gt;</span><span style="color:#66d9ef">new</span>( <span style="color:#e6db74">&#34;1 2 3/4 5 6/7 8 9&#34;</span> );

say <span style="color:#e6db74">&#34;initmat is $initmat&#34;</span>;

$mat<span style="color:#f92672">-&gt;</span>rotate90( $times );
say <span style="color:#e6db74">&#34;$initmat rotated $times time(s) is $mat&#34;</span>;
</code></pre></div><h2 id="e-choroba1">E. Choroba</h2>
<p><a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-053/e-choroba/perl/ch-1.pl">E. Choroba&rsquo;s solution</a> uses an old favourite, <a href="https://metacpan.org/pod/PDL"><code>PDL</code></a>, to assist with the matrix transposition:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-perl" data-lang="perl"><span style="color:#66d9ef">use</span> PDL;

<span style="color:#66d9ef">my</span> $matrix <span style="color:#f92672">=</span> pdl([<span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">2</span>, <span style="color:#ae81ff">3</span>],
                 [<span style="color:#ae81ff">4</span>, <span style="color:#ae81ff">5</span>, <span style="color:#ae81ff">6</span>],
                 [<span style="color:#ae81ff">7</span>, <span style="color:#ae81ff">8</span>, <span style="color:#ae81ff">9</span>]);

<span style="color:#66d9ef">for</span> <span style="color:#66d9ef">my</span> $rotation (<span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">90</span>, <span style="color:#ae81ff">180</span>, <span style="color:#ae81ff">270</span>) {
    <span style="color:#66d9ef">my</span> $times <span style="color:#f92672">=</span> $rotation <span style="color:#f92672">/</span> <span style="color:#ae81ff">90</span>;
    <span style="color:#66d9ef">my</span> $result <span style="color:#f92672">=</span> $matrix;
    $result <span style="color:#f92672">=</span> $result<span style="color:#f92672">-&gt;</span>transpose<span style="color:#f92672">-&gt;</span>slice([<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">0</span>]) <span style="color:#66d9ef">for</span> <span style="color:#ae81ff">1</span> <span style="color:#f92672">..</span> $times;
    <span style="color:#66d9ef">print</span> <span style="color:#e6db74">&#34;$rotation:$result&#34;</span>;
}
</code></pre></div><p>Since the clockwise rotation we are tasked with is different from a true matrix transposition, Choroba uses PDL&rsquo;s <a href="https://metacpan.org/pod/PDL::Slices#slice"><code>slice</code></a> to flip the matrix and get the correct result.</p>
<p><strong>Blog</strong> › <a href="http://blogs.perl.org/users/e_choroba/2020/03/perl-weekly-challenge-053-rotate-matrix-and-vowel-strings.html">Perl Weekly Challenge 053: Rotate Matrix and Vowel Strings</a></p>
<h2 id="jaldhar-h-vyas1">Jaldhar H. Vyas</h2>
<p><a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-053/jaldhar-h-vyas/perl/ch-1.pl">Jaldhar H. Vyas&rsquo;s solution</a> supports NxN square matrices, specified within the <code>rotate</code> sub:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-perl" data-lang="perl"><span style="color:#66d9ef">sub</span> <span style="color:#a6e22e">rotate</span> {
    <span style="color:#66d9ef">my</span> ($angle) <span style="color:#f92672">=</span> @_;
    <span style="color:#66d9ef">my</span> @matrix <span style="color:#f92672">=</span> (
        [ <span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">2</span>, <span style="color:#ae81ff">3</span> ],
        [ <span style="color:#ae81ff">4</span>, <span style="color:#ae81ff">5</span>, <span style="color:#ae81ff">6</span> ],
        [ <span style="color:#ae81ff">7</span>, <span style="color:#ae81ff">8</span>, <span style="color:#ae81ff">9</span> ],
    );

    <span style="color:#66d9ef">my</span> $side <span style="color:#f92672">=</span> scalar @matrix;

    <span style="color:#66d9ef">for</span> (<span style="color:#ae81ff">1</span> <span style="color:#f92672">..</span> $angle <span style="color:#f92672">/</span> <span style="color:#ae81ff">90</span>) {
        <span style="color:#66d9ef">for</span> <span style="color:#66d9ef">my</span> $row (<span style="color:#ae81ff">0</span> <span style="color:#f92672">..</span> ($side <span style="color:#f92672">/</span> <span style="color:#ae81ff">2</span>) <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>) {
            <span style="color:#66d9ef">for</span> <span style="color:#66d9ef">my</span> $col ($row <span style="color:#f92672">..</span> ($side <span style="color:#f92672">-</span> $row <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>) <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>) {
                <span style="color:#66d9ef">my</span> $temp <span style="color:#f92672">=</span> $matrix[$row][$col];

                $matrix[$row][$col] <span style="color:#f92672">=</span> $matrix[$side <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span> <span style="color:#f92672">-</span> $col][$row];

                $matrix[$side <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span> <span style="color:#f92672">-</span> $col][$row] <span style="color:#f92672">=</span>
                    $matrix[$side <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span> <span style="color:#f92672">-</span> $row][$side <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span> <span style="color:#f92672">-</span> $col];

                $matrix[$side <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span> <span style="color:#f92672">-</span> $row][$side <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span> <span style="color:#f92672">-</span> $col] <span style="color:#f92672">=</span>
                    $matrix[$col][$side <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span> <span style="color:#f92672">-</span> $row];

                $matrix[$col][$side <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span> <span style="color:#f92672">-</span>$row] <span style="color:#f92672">=</span> $temp;
            }
        }
    }

    <span style="color:#66d9ef">return</span> @matrix;
}
</code></pre></div><p>The code operates by spiraling inward from all four corners, in the following order:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-perl" data-lang="perl">[ <span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">1</span>,  <span style="color:#ae81ff">2</span>, <span style="color:#ae81ff">3</span>, <span style="color:#ae81ff">0</span> ]
[ <span style="color:#ae81ff">3</span>, <span style="color:#ae81ff">4</span>,  <span style="color:#ae81ff">5</span>, <span style="color:#ae81ff">4</span>, <span style="color:#ae81ff">1</span> ]
[ <span style="color:#ae81ff">2</span>, <span style="color:#ae81ff">5</span>, <span style="color:#ae81ff">13</span>, <span style="color:#ae81ff">5</span>, <span style="color:#ae81ff">2</span> ]
[ <span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">4</span>,  <span style="color:#ae81ff">5</span>, <span style="color:#ae81ff">4</span>, <span style="color:#ae81ff">3</span> ]
[ <span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">3</span>,  <span style="color:#ae81ff">2</span>, <span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">0</span> ]
</code></pre></div><p>The numbers shown are a simple count of the number of times the inner loop has run. The <code>13</code> in the middle is a side-effect of the loop bounds.</p>
<p><strong>Blog</strong> › <a href="https://www.braincells.com/perl/2020/03/perl_weekly_challenge_week_52.html">Jaldhar&rsquo;s Week #053 Blog</a></p>
<h2 id="javier-luque1">Javier Luque</h2>
<p><a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-053/javier-luque/perl/ch-1.pl">Javier Luque&rsquo;s solution</a> supports NxN square matrices, and is called multiple times to effect rotations in multiples of 90 degrees:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-perl" data-lang="perl"><span style="color:#66d9ef">sub</span> <span style="color:#a6e22e">rotate_matrix</span> {
    <span style="color:#66d9ef">my</span> $m <span style="color:#f92672">=</span> shift;

    <span style="color:#75715e"># Size of the matrix</span>
    <span style="color:#66d9ef">my</span> $n <span style="color:#f92672">=</span> scalar(@$m);

    <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">my</span> $i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; $i <span style="color:#f92672">&lt;</span> int($n <span style="color:#f92672">/</span> <span style="color:#ae81ff">2</span>); $i<span style="color:#f92672">++</span>) {
        <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">my</span> $j <span style="color:#f92672">=</span> $i; $j <span style="color:#f92672">&lt;</span> $n <span style="color:#f92672">-</span> $i <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>; $j<span style="color:#f92672">++</span>) {
            <span style="color:#66d9ef">my</span> $temp <span style="color:#f92672">=</span> $m<span style="color:#f92672">-&gt;</span>[$i]<span style="color:#f92672">-&gt;</span>[$j];
            $m<span style="color:#f92672">-&gt;</span>[$i]<span style="color:#f92672">-&gt;</span>[$j]           <span style="color:#f92672">=</span> $m<span style="color:#f92672">-&gt;</span>[$n<span style="color:#f92672">-</span>$j<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>]<span style="color:#f92672">-&gt;</span>[$i];
            $m<span style="color:#f92672">-&gt;</span>[$n<span style="color:#f92672">-</span>$j<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>]<span style="color:#f92672">-&gt;</span>[$i]      <span style="color:#f92672">=</span> $m<span style="color:#f92672">-&gt;</span>[$n<span style="color:#f92672">-</span>$i<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>]<span style="color:#f92672">-&gt;</span>[$n<span style="color:#f92672">-</span>$j<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>];
            $m<span style="color:#f92672">-&gt;</span>[$n<span style="color:#f92672">-</span>$i<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>]<span style="color:#f92672">-&gt;</span>[$n<span style="color:#f92672">-</span>$j<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>] <span style="color:#f92672">=</span> $m<span style="color:#f92672">-&gt;</span>[$j]<span style="color:#f92672">-&gt;</span>[$n<span style="color:#f92672">-</span>$i<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>];
            $m<span style="color:#f92672">-&gt;</span>[$j]<span style="color:#f92672">-&gt;</span>[$n<span style="color:#f92672">-</span>$i<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>]      <span style="color:#f92672">=</span> $temp;
        }
    }
}
</code></pre></div><p>This rotation also spirals inward.</p>
<p><strong>Blog</strong> › <a href="https://perlchallenges.wordpress.com/2020/03/23/perl-weekly-challenge-053/">053 – Perl Weekly Challenge</a></p>
<h2 id="laurent-rosenfeld1">Laurent Rosenfeld</h2>
<p><a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-053/laurent-rosenfeld/perl/ch-1.pl">Laurent Rosenfeld&rsquo;s solution</a> supports NxN matrices, via repeated calls to <code>rotate_90</code>:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-perl" data-lang="perl"><span style="color:#66d9ef">sub</span> <span style="color:#a6e22e">rotate_90</span> {
    <span style="color:#66d9ef">my</span> $input <span style="color:#f92672">=</span> shift;
    <span style="color:#66d9ef">my</span> @output;
    <span style="color:#66d9ef">for</span> <span style="color:#66d9ef">my</span> $row (<span style="color:#ae81ff">0</span> <span style="color:#f92672">..</span> $#$input) {
        <span style="color:#66d9ef">for</span> <span style="color:#66d9ef">my</span> $col (<span style="color:#ae81ff">0</span> <span style="color:#f92672">..</span> $#{@$input[$row]}) {
            $output[$col][$#{@$input[$row]} <span style="color:#f92672">-</span> $row] <span style="color:#f92672">=</span> $input<span style="color:#f92672">-&gt;</span>[$row][$col];
        }
    }
  <span style="color:#66d9ef">return</span> <span style="color:#f92672">\</span>@output;
}
<span style="color:#66d9ef">sub</span> <span style="color:#a6e22e">rotate_180</span> {rotate_90 rotate_90 @_}
<span style="color:#66d9ef">sub</span> <span style="color:#a6e22e">rotate_270</span> {rotate_90 rotate_180 @_}
</code></pre></div><p><strong>Blog</strong> › <a href="http://blogs.perl.org/users/laurent_r/2020/03/perl-weekly-challenge-53-rotate-matrix-and-vowel-strings.html">Rotate Matrix and Vowel Strings</a></p>
<h2 id="lubos-kolouch1">Lubos Kolouch</h2>
<p><a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-053/lubos-kolouch/perl/ch-1.pl">Lubos Kolouch&rsquo;s
solution</a> also uses <a href="https://metacpan.org/pod/PDL"><code>PDL</code></a>:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-perl" data-lang="perl"><span style="color:#66d9ef">use</span> PDL;

<span style="color:#66d9ef">my</span> $m <span style="color:#f92672">=</span> sequence(<span style="color:#ae81ff">3</span>,<span style="color:#ae81ff">3</span>)<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>;
<span style="color:#66d9ef">print</span>($m);

<span style="color:#66d9ef">for</span> (<span style="color:#ae81ff">0</span><span style="color:#f92672">..</span><span style="color:#ae81ff">2</span>) {
    say(<span style="color:#ae81ff">90</span><span style="color:#f92672">*</span>($_<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>));
    $m <span style="color:#f92672">=</span> $m<span style="color:#f92672">-&gt;</span>transpose<span style="color:#f92672">-&gt;</span>slice([<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>,<span style="color:#ae81ff">0</span>]);
    <span style="color:#66d9ef">print</span>($m);
}
</code></pre></div><p>Lubos credits the StackOverflow question <a href="https://stackoverflow.com/questions/21433364/use-perl-pdl-to-rotate-a-matrix">Use Perl PDL to rotate a matrix</a> for figuring out the rotation, and also credits <a href="#e-choroba1">Choroba&rsquo;s solution</a> for the use of <code>-&gt;slice</code>. Doing the research and crediting sources is the mark of a good programmer, and I really appreciate it.</p>
<h2 id="mohammad-anwar1">Mohammad S Anwar</h2>
<p><a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-053/mohammad-anwar/perl/ch-1.pl">Mohammad S Anwar&rsquo;s solution</a> supports 3x3 matrices only. Mohammad has been doing good work with the <a href="https://perldoc.perl.org/Test.html"><code>Test</code></a> family, providing unit tests for his solutions. Here is how he organized the tests for this task:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-perl" data-lang="perl"><span style="color:#66d9ef">use</span> Test::More;
<span style="color:#66d9ef">use</span> Test::Deep;

<span style="color:#66d9ef">my</span> $unit_tests <span style="color:#f92672">=</span> {
    <span style="color:#ae81ff">90</span> <span style="color:#f92672">=&gt;</span> {
            in  <span style="color:#f92672">=&gt;</span> [ [ <span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">2</span>, <span style="color:#ae81ff">3</span> ], [ <span style="color:#ae81ff">4</span>, <span style="color:#ae81ff">5</span>, <span style="color:#ae81ff">6</span> ], [ <span style="color:#ae81ff">7</span>, <span style="color:#ae81ff">8</span>, <span style="color:#ae81ff">9</span> ] ],
            out <span style="color:#f92672">=&gt;</span> [ [ <span style="color:#ae81ff">7</span>, <span style="color:#ae81ff">4</span>, <span style="color:#ae81ff">1</span> ], [ <span style="color:#ae81ff">8</span>, <span style="color:#ae81ff">5</span>, <span style="color:#ae81ff">2</span> ], [ <span style="color:#ae81ff">9</span>, <span style="color:#ae81ff">6</span>, <span style="color:#ae81ff">3</span> ] ],
          },
   <span style="color:#ae81ff">180</span> <span style="color:#f92672">=&gt;</span> {
            in  <span style="color:#f92672">=&gt;</span> [ [ <span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">2</span>, <span style="color:#ae81ff">3</span> ], [ <span style="color:#ae81ff">4</span>, <span style="color:#ae81ff">5</span>, <span style="color:#ae81ff">6</span> ], [ <span style="color:#ae81ff">7</span>, <span style="color:#ae81ff">8</span>, <span style="color:#ae81ff">9</span> ] ],
            out <span style="color:#f92672">=&gt;</span> [ [ <span style="color:#ae81ff">9</span>, <span style="color:#ae81ff">8</span>, <span style="color:#ae81ff">7</span> ], [ <span style="color:#ae81ff">6</span>, <span style="color:#ae81ff">5</span>, <span style="color:#ae81ff">4</span> ], [ <span style="color:#ae81ff">3</span>, <span style="color:#ae81ff">2</span>, <span style="color:#ae81ff">1</span> ] ],
          },
   <span style="color:#ae81ff">270</span> <span style="color:#f92672">=&gt;</span> {
            in  <span style="color:#f92672">=&gt;</span> [ [ <span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">2</span>, <span style="color:#ae81ff">3</span> ], [ <span style="color:#ae81ff">4</span>, <span style="color:#ae81ff">5</span>, <span style="color:#ae81ff">6</span> ], [ <span style="color:#ae81ff">7</span>, <span style="color:#ae81ff">8</span>, <span style="color:#ae81ff">9</span> ] ],
            out <span style="color:#f92672">=&gt;</span> [ [ <span style="color:#ae81ff">3</span>, <span style="color:#ae81ff">6</span>, <span style="color:#ae81ff">9</span> ], [ <span style="color:#ae81ff">2</span>, <span style="color:#ae81ff">5</span>, <span style="color:#ae81ff">8</span> ], [ <span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">4</span>, <span style="color:#ae81ff">7</span> ] ],
          },
};

<span style="color:#66d9ef">foreach</span> <span style="color:#66d9ef">my</span> $degree (sort { $a <span style="color:#e6db74">&lt;=&gt;</span> $b } keys %$unit_tests) {
    <span style="color:#66d9ef">my</span> $in  <span style="color:#f92672">=</span> $unit_tests<span style="color:#f92672">-&gt;</span>{$degree}<span style="color:#f92672">-&gt;</span>{in};
    <span style="color:#66d9ef">my</span> $out <span style="color:#f92672">=</span> $unit_tests<span style="color:#f92672">-&gt;</span>{$degree}<span style="color:#f92672">-&gt;</span>{out};
    cmp_deeply(rotate_matrix($in, $degree), $out, <span style="color:#e6db74">&#34;rotation by $degree.&#34;</span>);
}

done_testing;
</code></pre></div><p>I can&rsquo;t count the number of times I&rsquo;ve opened up a CPAN distribution and looked at the unit tests, only to see an unorganized mess of individual tests with duplicated code. It&rsquo;s easy to forget that unit tests are code, too.  Mohammad hasn&rsquo;t forgotten that, and took the time to factor out the common code in his tests, for a more maintainable and readable result.</p>
<p>Here is the <code>rotate_matrix</code> that handles any 3x3 matrix:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-perl" data-lang="perl"><span style="color:#66d9ef">sub</span> <span style="color:#a6e22e">rotate_matrix</span> {
    <span style="color:#66d9ef">my</span> ($matrix, $degree) <span style="color:#f92672">=</span> @_;

    <span style="color:#66d9ef">foreach</span> <span style="color:#66d9ef">my</span> $i ( <span style="color:#ae81ff">1</span> <span style="color:#f92672">..</span> int($degree<span style="color:#f92672">/</span><span style="color:#ae81ff">90</span>) ) {
        <span style="color:#66d9ef">my</span> $rows <span style="color:#f92672">=</span> @$matrix;
        <span style="color:#66d9ef">my</span> $cols <span style="color:#f92672">=</span> @{$matrix<span style="color:#f92672">-&gt;</span>[<span style="color:#ae81ff">0</span>]};

        <span style="color:#66d9ef">my</span> $_matrix <span style="color:#f92672">=</span> <span style="color:#f92672">[]</span>;
        <span style="color:#66d9ef">foreach</span> <span style="color:#66d9ef">my</span> $i ( <span style="color:#ae81ff">0</span> <span style="color:#f92672">..</span> $rows<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span> ) {
            <span style="color:#66d9ef">my</span> $k <span style="color:#f92672">=</span> <span style="color:#ae81ff">2</span>;
            <span style="color:#66d9ef">foreach</span> <span style="color:#66d9ef">my</span> $j ( <span style="color:#ae81ff">0</span> <span style="color:#f92672">..</span> $cols<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span> ) {
                $_matrix<span style="color:#f92672">-&gt;</span>[$i][$j] <span style="color:#f92672">=</span> $matrix<span style="color:#f92672">-&gt;</span>[$k][$i];
                $k<span style="color:#f92672">--</span>;
            }
        }
        $matrix <span style="color:#f92672">=</span> $_matrix;
    }

    <span style="color:#66d9ef">return</span> $matrix;
}
</code></pre></div><p><strong>Blog</strong> › <a href="https://perlweeklychallenge.org/blog/weekly-challenge-053">BLOG: The Weekly Challenge #053</a></p>
<h2 id="roger-bell-west1">Roger Bell West</h2>
<p><a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-053/roger-bell-west/perl/ch-1.pl">Roger Bell West&rsquo;s solution</a> works with any NxN (square) matrix:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-perl" data-lang="perl"><span style="color:#66d9ef">sub</span> <span style="color:#a6e22e">rotate</span> {
    <span style="color:#66d9ef">my</span> ( $rotations, @in ) <span style="color:#f92672">=</span> @_;
    <span style="color:#66d9ef">my</span> $xs <span style="color:#f92672">=</span> $#in;
    <span style="color:#66d9ef">foreach</span> <span style="color:#66d9ef">my</span> $ya (@in) {
        <span style="color:#66d9ef">if</span> ( $#{$ya} <span style="color:#f92672">!=</span> $xs ) {
            die <span style="color:#e6db74">&#34;not a square matrix\n&#34;</span>;
        }
    }
    <span style="color:#66d9ef">my</span> @out <span style="color:#f92672">=</span> @in;
    <span style="color:#66d9ef">foreach</span> ( <span style="color:#ae81ff">1</span> <span style="color:#f92672">..</span> $rotations ) {
        <span style="color:#66d9ef">my</span> @im <span style="color:#f92672">=</span> @out;
        <span style="color:#66d9ef">my</span> @tmp;
        <span style="color:#66d9ef">foreach</span> <span style="color:#66d9ef">my</span> $x ( <span style="color:#ae81ff">0</span> <span style="color:#f92672">..</span> $xs ) {
            <span style="color:#66d9ef">foreach</span> <span style="color:#66d9ef">my</span> $y ( <span style="color:#ae81ff">0</span> <span style="color:#f92672">..</span> $xs ) {
                $tmp[$y][ $xs <span style="color:#f92672">-</span> $x ] <span style="color:#f92672">=</span> $im[$x][$y];
            }
        }
        @out <span style="color:#f92672">=</span> @tmp;
    }
    <span style="color:#66d9ef">return</span> @out;
}
</code></pre></div><h2 id="ruben-westerberg1">Ruben Westerberg</h2>
<p><a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-053/ruben-westerberg/perl/ch-1.pl">Ruben Westerberg&rsquo;s solution</a> supports 3x3 matrices only, but does so in style, with trigonometry. I suppose we should have held this task just a little sooner, so it would line up with <a href="https://en.wikipedia.org/wiki/Pi_Day">Pi Day</a>, March 14th!</p>
<p>Ruben uses core module <a href="https://perldoc.perl.org/Math/Trig.html"><code>Math::Trig</code></a> for its <code>pi</code>
routines only, and <a href="https://perldoc.perl.org/POSIX.html"><code>POSIX</code></a>&lsquo;s <code>round</code>:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-perl" data-lang="perl"><span style="color:#66d9ef">use</span> Math::Trig <span style="color:#e6db74">&#39;:pi&#39;</span>;
<span style="color:#66d9ef">use</span> POSIX <span style="color:#e6db74">qw&lt;round&gt;</span>;
</code></pre></div><p>With basic trigonometry, <code>@ir</code> and <code>@ic</code> give the input rows and columns, for a respective 0..7 index into the 3x3 array. (<code>pip4</code> is a <code>Math::Trig</code> equivalent for <code>pi*4</code>.)</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-perl" data-lang="perl"><span style="color:#66d9ef">sub</span> <span style="color:#a6e22e">rotate</span> {
    <span style="color:#66d9ef">my</span> ($input,$angle)<span style="color:#f92672">=</span>@_;
    <span style="color:#75715e">#input indexing</span>
    <span style="color:#66d9ef">my</span> @ip<span style="color:#f92672">=</span>map {pip4 <span style="color:#f92672">*</span>$_} <span style="color:#ae81ff">0</span><span style="color:#f92672">..</span><span style="color:#ae81ff">7</span>;
    <span style="color:#66d9ef">my</span> @ir<span style="color:#f92672">=</span>map {<span style="color:#ae81ff">1</span><span style="color:#f92672">+</span>round sin} @ip;
    <span style="color:#66d9ef">my</span> @ic<span style="color:#f92672">=</span>map {<span style="color:#ae81ff">1</span><span style="color:#f92672">+</span>round cos} @ip;

    <span style="color:#75715e">#output indexing</span>
    <span style="color:#66d9ef">my</span> @polar<span style="color:#f92672">=</span>map {($angle<span style="color:#f92672">/</span><span style="color:#ae81ff">180</span> <span style="color:#f92672">*</span>pi) <span style="color:#f92672">+</span> pip4 <span style="color:#f92672">*</span>$_} <span style="color:#ae81ff">0</span><span style="color:#f92672">..</span><span style="color:#ae81ff">7</span>;
    <span style="color:#66d9ef">my</span> @row<span style="color:#f92672">=</span> map {<span style="color:#ae81ff">1</span><span style="color:#f92672">+</span>round sin} @polar;
    <span style="color:#66d9ef">my</span> @col <span style="color:#f92672">=</span>map {<span style="color:#ae81ff">1</span><span style="color:#f92672">+</span>round cos} @polar;

</code></pre></div><p>For a 90 degree rotation, the arrays look like this:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-perl" data-lang="perl">   @ir <span style="color:#f92672">=</span> ( <span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">2</span>, <span style="color:#ae81ff">2</span>, <span style="color:#ae81ff">2</span>, <span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">0</span> );
   @ic <span style="color:#f92672">=</span> ( <span style="color:#ae81ff">2</span>, <span style="color:#ae81ff">2</span>, <span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">2</span> );
  @row <span style="color:#f92672">=</span> ( <span style="color:#ae81ff">2</span>, <span style="color:#ae81ff">2</span>, <span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">2</span> );
  @col <span style="color:#f92672">=</span> ( <span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">2</span>, <span style="color:#ae81ff">2</span>, <span style="color:#ae81ff">2</span> );
</code></pre></div><p>Thus, each column in the above gives a coordinate mapping from input to output, for a single element in the 3x3 array. For example, the first column gives you a mapping from <strong>[1,2]</strong> to <strong>[2,1]</strong>.</p>
<p>If you were wondering, &ldquo;why index 0..7, instead of 0..8?&quot;, you are right to wonder that. Ruben handles the middle element (1,1) separately:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-perl" data-lang="perl">    <span style="color:#66d9ef">my</span> $out<span style="color:#f92672">=</span>[<span style="color:#f92672">[]</span>,<span style="color:#f92672">[]</span>,<span style="color:#f92672">[]</span>];
    $out<span style="color:#f92672">-&gt;</span>[<span style="color:#ae81ff">1</span>]<span style="color:#f92672">-&gt;</span>[<span style="color:#ae81ff">1</span>]<span style="color:#f92672">=</span>$matrix<span style="color:#f92672">-&gt;</span>[<span style="color:#ae81ff">1</span>]<span style="color:#f92672">-&gt;</span>[<span style="color:#ae81ff">1</span>];
</code></pre></div><p>Meanwhile, here is the line that handles the rest of the assignments from the input array¹ to the output array:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-perl" data-lang="perl">    $out<span style="color:#f92672">-&gt;</span>[$row[$_]]<span style="color:#f92672">-&gt;</span>[$col[$_]]<span style="color:#f92672">=</span>$matrix<span style="color:#f92672">-&gt;</span>[$ir[$_]]<span style="color:#f92672">-&gt;</span>[$ic[$_]] <span style="color:#66d9ef">for</span> (<span style="color:#ae81ff">0</span><span style="color:#f92672">..</span>@col<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>);
</code></pre></div><hr>
<p>¹. <em>Despite taking an <code>$input</code> argument, <code>rotate</code> always uses <code>$matrix</code>. I suspect this is a simple oversight.</em></p>
<h2 id="ryan-thompson1">Ryan Thompson</h2>
<p><a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-053/ryan-thompson/perl/ch-1.pl">My solution</a> handles any MxN matrix:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-perl" data-lang="perl"><span style="color:#66d9ef">sub</span> <span style="color:#a6e22e">rotate90_cw</span> {
    <span style="color:#66d9ef">my</span> @A <span style="color:#f92672">=</span> reverse @{$_[<span style="color:#ae81ff">0</span>]};
    <span style="color:#66d9ef">my</span> @T;
    <span style="color:#66d9ef">for</span> <span style="color:#66d9ef">my</span> $x (<span style="color:#ae81ff">0</span><span style="color:#f92672">..</span>$#A) {
        $T[$_][$x] <span style="color:#f92672">=</span> $A[$x][$_] <span style="color:#66d9ef">for</span> <span style="color:#ae81ff">0</span><span style="color:#f92672">..</span>$#{$A[<span style="color:#ae81ff">0</span>]};
    }
    <span style="color:#f92672">\</span>@T;
}
</code></pre></div><p>You might notice I <code>reverse</code> the rows in the input array first. That&rsquo;s a stylistic choice so the rest of the function could be a simple transpose, much like my Raku submission; I could have instead mirrored the output columns.</p>
<p>The additional rotations are simply defined in terms of <code>rotate90_cw</code>:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-perl" data-lang="perl"><span style="color:#75715e"># Convenience</span>
<span style="color:#66d9ef">sub</span> <span style="color:#a6e22e">rotate180</span>    { rotate90_cw( rotate90_cw (@_) ) }
<span style="color:#66d9ef">sub</span> <span style="color:#a6e22e">rotate_ccw</span>   { rotate90_cw( rotate180(   @_) ) }
</code></pre></div><p>I also provided a number of unit tests, making sure I hit the important edge cases like 1xN, Mx1, and non-numeric cell contents:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-perl" data-lang="perl"><span style="color:#75715e"># 1xN, Nx1</span>
is_deeply rotate90_cw(  [[<span style="color:#ae81ff">1</span>,<span style="color:#ae81ff">2</span>,<span style="color:#ae81ff">3</span>]]),     [[<span style="color:#ae81ff">1</span>],[<span style="color:#ae81ff">2</span>],[<span style="color:#ae81ff">3</span>]];
is_deeply rotate90_cw(  [[<span style="color:#ae81ff">1</span>],[<span style="color:#ae81ff">2</span>],[<span style="color:#ae81ff">3</span>]]), [[<span style="color:#ae81ff">3</span>,<span style="color:#ae81ff">2</span>,<span style="color:#ae81ff">1</span>]];

<span style="color:#75715e"># Non-numeric, because why not</span>
is_deeply rotate90_cw ( [[<span style="color:#e6db74">&#39;a&#39;</span>,<span style="color:#e6db74">&#39;b&#39;</span>,<span style="color:#e6db74">&#39;c&#39;</span>],  [<span style="color:#e6db74">&#39;d&#39;</span>,<span style="color:#e6db74">&#39;e&#39;</span>,<span style="color:#e6db74">&#39;f&#39;</span>]] ),
                        [[<span style="color:#e6db74">&#39;d&#39;</span>,<span style="color:#e6db74">&#39;a&#39;</span>],[<span style="color:#e6db74">&#39;e&#39;</span>,<span style="color:#e6db74">&#39;b&#39;</span>],[<span style="color:#e6db74">&#39;f&#39;</span>,<span style="color:#e6db74">&#39;c&#39;</span>]];
</code></pre></div><p><strong>Blog</strong> › <a href="http://www.ry.ca/2020/03/matrix-rotation/">Matrix Rotation</a></p>
<h2 id="saiftynet1">Saif Ahmed</h2>
<p><a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-053/saiftynet/perl/ch-1.pl">Saif Ahmed&rsquo;s solution</a> works on any MxN matrix, and also does more than just rotate. Here are the supported &ldquo;rotation&rdquo; options:</p>
<ul>
<li><code>0</code>, <code>90</code>, <code>180</code>, <code>270</code>: Clockwise rotation by degrees</li>
<li><code>cw</code>, <code>ht, </code>ccw`: Aliases for above. &ldquo;<strong>Clockwise</strong>&quot;,&quot;<strong>Half Turn</strong>&quot;, &ldquo;<strong>Counter-Clockwise</strong>&rdquo;</li>
<li><code>v</code>, <code>h</code>: Flip <strong>vertically</strong> or <strong>horizontally</strong></li>
<li><code>lr</code>: Flip top left to bottom right diagonal</li>
<li><code>rl</code>: Flip bottom right to top left diagonal</li>
</ul>
<p>Here is the <code>flip</code> sub in its entirety:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-perl" data-lang="perl"><span style="color:#66d9ef">sub</span> <span style="color:#a6e22e">flip</span> {
    <span style="color:#66d9ef">my</span> $arr       <span style="color:#f92672">=</span> shift;
    <span style="color:#66d9ef">my</span> $direction <span style="color:#f92672">=</span> shift;
    <span style="color:#66d9ef">my</span> @flipped   <span style="color:#f92672">=</span> ();
    <span style="color:#66d9ef">return</span> $arr <span style="color:#66d9ef">unless</span> $direction;    <span style="color:#75715e"># return original list for 0 deg trun</span>
    <span style="color:#66d9ef">if</span> ( $direction <span style="color:#f92672">=~</span><span style="color:#e6db74"> /^cw|ccw|lr|rl|90|270$/</span> ) {
        <span style="color:#66d9ef">foreach</span> <span style="color:#66d9ef">my</span> $row ( <span style="color:#ae81ff">0</span> <span style="color:#f92672">..</span> scalar @{ $$arr[<span style="color:#ae81ff">0</span>] } <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span> ) {    <span style="color:#75715e"># for each row</span>
            $flipped[$row] <span style="color:#f92672">=</span> <span style="color:#f92672">[]</span>;    <span style="color:#75715e"># initialise empty row</span>
            <span style="color:#66d9ef">foreach</span> <span style="color:#66d9ef">my</span> $col ( <span style="color:#ae81ff">0</span> <span style="color:#f92672">..</span> scalar @$arr <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span> ) {    <span style="color:#75715e"># for each column</span>
                push @{ $flipped[$row] },
                  $$arr[$col][$row];    <span style="color:#75715e"># this does a diagonal flip</span>
            }
            @{ $flipped[$row] } <span style="color:#f92672">=</span> reverse @{ $flipped[$row] }
              <span style="color:#66d9ef">if</span> $direction <span style="color:#f92672">=~</span><span style="color:#e6db74"> /^cw|90|rl$/</span>;
        }
        @flipped <span style="color:#f92672">=</span> reverse @flipped <span style="color:#66d9ef">if</span> $direction <span style="color:#f92672">=~</span><span style="color:#e6db74"> /^ccw|270|rl$/</span>;
    }
    <span style="color:#66d9ef">elsif</span> ( $direction <span style="color:#f92672">eq</span> <span style="color:#e6db74">&#39;v&#39;</span> ) {
        @flipped <span style="color:#f92672">=</span> reverse(@$arr);
    }
    <span style="color:#66d9ef">elsif</span> ( $direction <span style="color:#f92672">eq</span> <span style="color:#e6db74">&#39;h&#39;</span> ) {
        <span style="color:#66d9ef">my</span> $row <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
        <span style="color:#66d9ef">foreach</span> (@$arr) {
            @{ $flipped[ $row<span style="color:#f92672">++</span> ] } <span style="color:#f92672">=</span> reverse @$_;
        }
    }
    <span style="color:#66d9ef">elsif</span> ( $direction <span style="color:#f92672">=~</span><span style="color:#e6db74"> /^180|ht$/</span> ) {
        @flipped <span style="color:#f92672">=</span> @{ flip( flip( $arr, <span style="color:#e6db74">&#34;v&#34;</span> ), <span style="color:#e6db74">&#34;h&#34;</span> ) };
    }
    <span style="color:#66d9ef">return</span> <span style="color:#f92672">\</span>@flipped;
}
</code></pre></div><p>The factorization of logic for <code>cw|ccw|lr|rl|90|270</code> all into the same block is rather elegant.</p>
<p>The real star of the show, however, has to be Saif&rsquo;s second set of test cases.  While everyone else had me staring at numbers to try and figure out if they all rotated into their proper places, Saif eschewed from such eyestrain-inducing numerals, in favour of this majestic bit of ASCII:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-perl" data-lang="perl"><span style="color:#66d9ef">my</span> $matrix2<span style="color:#f92672">=</span>[[<span style="color:#e6db74">qw{- - - █ - -}</span>],
             [<span style="color:#e6db74">qw{- - - ░ █ -}</span>],
             [<span style="color:#e6db74">qw{█ █ █ ░ ░ █}</span>],
             [<span style="color:#e6db74">qw{- - - ░ █ -}</span>],
             [<span style="color:#e6db74">qw{- - - █ - -}</span>]];
</code></pre></div><p>The output makes it extremely obvious to verify:</p>
<pre><code>Rotating by 0
---█--
---░█-
███░░█
---░█-
---█--

Rotating by 90
--█--
--█--
--█--
█░░░█
-█░█-
--█--

Rotating by 180
--█---
-█░---
█░░███
-█░---
--█---

Rotating by 270
--█--
-█░█-
█░░░█
--█--
--█--
--█--
</code></pre><p>Arrows or not, Saif&rsquo;s solutions are always a joy to review.</p>
<h2 id="user-person1">User Person</h2>
<p><a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-053/user-person/perl/ch-1.pl">User Person&rsquo;s solution</a> works on 3x3 matrices only:</p>
<p>User Person has a recursive array flattener, that they will use:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-perl" data-lang="perl"><span style="color:#66d9ef">sub</span> <span style="color:#a6e22e">flat</span> {
    <span style="color:#66d9ef">return</span> map { ref <span style="color:#f92672">eq</span> <span style="color:#e6db74">&#39;ARRAY&#39;</span> ? flat(@$_) : $_ } @_;
}
</code></pre></div><p>User Person uses this to flatten the input AoA, <code>@matrix</code>, into <code>@rawNums</code>:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-perl" data-lang="perl"><span style="color:#66d9ef">my</span> @rawNums <span style="color:#f92672">=</span> ();

@rawNums <span style="color:#f92672">=</span> flat @matrix;
</code></pre></div><p>Now, depending on the <code>$deg</code> (degrees) input, User Person loops through <code>@newMatrix</code> differently. <code>@rawNums</code> is flat, and is always iterated in order, giving it a row-major traversal every time:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-perl" data-lang="perl"><span style="color:#66d9ef">my</span> @newMatrix <span style="color:#f92672">=</span> ();
<span style="color:#66d9ef">my</span> $i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;

<span style="color:#66d9ef">if</span> ($deg <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>) {

    <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">my</span> $j <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; $j <span style="color:#f92672">&lt;</span> $width; <span style="color:#f92672">++</span>$j) {
        <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">my</span> $k <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; $k <span style="color:#f92672">&lt;</span> $width; <span style="color:#f92672">++</span>$k) {
            $newMatrix[$j][$k] <span style="color:#f92672">=</span> $rawNums[$i<span style="color:#f92672">++</span>];
        }
    }

} <span style="color:#66d9ef">elsif</span> ( $deg <span style="color:#f92672">==</span> <span style="color:#ae81ff">90</span> ) {

    <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">my</span> $j <span style="color:#f92672">=</span> $width<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>; $j <span style="color:#f92672">&gt;=</span> <span style="color:#ae81ff">0</span>; <span style="color:#f92672">--</span>$j) {
        <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">my</span> $k <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; $k <span style="color:#f92672">&lt;</span> $width; <span style="color:#f92672">++</span>$k) {
            $newMatrix[$k][$j] <span style="color:#f92672">=</span> $rawNums[$i<span style="color:#f92672">++</span>];
        }
    }

} <span style="color:#66d9ef">elsif</span> ( $deg <span style="color:#f92672">==</span> <span style="color:#ae81ff">180</span> ) {

    <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">my</span> $j <span style="color:#f92672">=</span> $width<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>; $j <span style="color:#f92672">&gt;=</span> <span style="color:#ae81ff">0</span>; <span style="color:#f92672">--</span>$j) {
        <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">my</span> $k <span style="color:#f92672">=</span> $width<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>; $k <span style="color:#f92672">&gt;=</span> <span style="color:#ae81ff">0</span>; <span style="color:#f92672">--</span>$k) {
            $newMatrix[$j][$k] <span style="color:#f92672">=</span> $rawNums[$i<span style="color:#f92672">++</span>];
        }
    }

} <span style="color:#66d9ef">elsif</span> ( $deg <span style="color:#f92672">==</span> <span style="color:#ae81ff">270</span> ) {

    <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">my</span> $j <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; $j <span style="color:#f92672">&lt;</span> $width; <span style="color:#f92672">++</span>$j) {
        <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">my</span> $k <span style="color:#f92672">=</span> $width<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>; $k <span style="color:#f92672">&gt;=</span> <span style="color:#ae81ff">0</span>; <span style="color:#f92672">--</span>$k) {
            $newMatrix[$k][$j] <span style="color:#f92672">=</span> $rawNums[$i<span style="color:#f92672">++</span>];
        }
    }

}
</code></pre></div><h2 id="wanderdoc1">Wanderdoc</h2>
<p><a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-053/wanderdoc/perl/ch-1.pl">Wanderdoc&rsquo;s solution</a> includes a <code>rotate</code> sub that supports any MxN matrix:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-perl" data-lang="perl"><span style="color:#66d9ef">sub</span> <span style="color:#a6e22e">rotate</span> {
    <span style="color:#66d9ef">my</span> ( $aref, $angle ) <span style="color:#f92672">=</span> @_;
    <span style="color:#66d9ef">my</span> $rotated;
    <span style="color:#66d9ef">for</span> <span style="color:#66d9ef">my</span> $row_idx ( <span style="color:#ae81ff">0</span> <span style="color:#f92672">..</span> $#$aref ) {

        <span style="color:#66d9ef">for</span> <span style="color:#66d9ef">my</span> $col_idx ( <span style="color:#ae81ff">0</span> <span style="color:#f92672">..</span> $#{ $aref<span style="color:#f92672">-&gt;</span>[$row_idx] } ) {
            <span style="color:#66d9ef">if</span> ( <span style="color:#ae81ff">90</span> <span style="color:#f92672">==</span> $angle ) {
                $rotated<span style="color:#f92672">-&gt;</span>[$col_idx][ $#$aref <span style="color:#f92672">-</span> $row_idx ] <span style="color:#f92672">=</span>
                  $aref<span style="color:#f92672">-&gt;</span>[$row_idx][$col_idx];
            }
            <span style="color:#66d9ef">elsif</span> ( <span style="color:#ae81ff">180</span> <span style="color:#f92672">==</span> $angle ) {
                $rotated<span style="color:#f92672">-&gt;</span>[ $#$aref <span style="color:#f92672">-</span> $row_idx ]
                  [ $#{ $aref<span style="color:#f92672">-&gt;</span>[$row_idx] } <span style="color:#f92672">-</span> $col_idx ] <span style="color:#f92672">=</span>
                  $aref<span style="color:#f92672">-&gt;</span>[$row_idx][$col_idx];
            }

            <span style="color:#66d9ef">elsif</span> ( <span style="color:#ae81ff">270</span> <span style="color:#f92672">==</span> $angle ) {
                $rotated<span style="color:#f92672">-&gt;</span>[ $#{ $aref<span style="color:#f92672">-&gt;</span>[$row_idx] } <span style="color:#f92672">-</span> $col_idx ][$row_idx] <span style="color:#f92672">=</span>
                  $aref<span style="color:#f92672">-&gt;</span>[$row_idx][$col_idx];
            }
            <span style="color:#66d9ef">else</span> {
                die
                  <span style="color:#e6db74">&#34;Can only rotate a matrix by 90/180/270 degrees clockwise!$/&#34;</span>;
            }

        }
    }
    <span style="color:#66d9ef">return</span> $rotated;
}
</code></pre></div><p>The sub also directly implements the three different rotation angles, so this is also an optimally efficient solution. Nice!</p>
<h2 id="yet-ebreo1">Yet Ebreo</h2>
<p><a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-053/yet-ebreo/perl/ch-1.pl">Yet Ebreo&rsquo;s solution</a> supports MxN matrices:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-perl" data-lang="perl"><span style="color:#75715e">#Obfuscated routine to rotate array 90cw, because it&#39;s perl. :D</span>
<span style="color:#66d9ef">sub</span> <span style="color:#a6e22e">rotate</span> {@{$_[<span style="color:#ae81ff">0</span>]}<span style="color:#f92672">=</span>map[map$_[<span style="color:#ae81ff">0</span>]<span style="color:#f92672">-&gt;</span>[<span style="color:#f92672">-</span>$_][$&#39;],<span style="color:#e6db74">//</span><span style="color:#f92672">..</span>@{$_[<span style="color:#ae81ff">0</span>]}],<span style="color:#ae81ff">0</span><span style="color:#f92672">..~-</span>@{$_[<span style="color:#ae81ff">0</span>]<span style="color:#f92672">-&gt;</span>[<span style="color:#ae81ff">0</span>]}}
</code></pre></div><p>Again, with a little whitespace:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-perl" data-lang="perl"><span style="color:#75715e"># De-obfuscated [Ryan]</span>
<span style="color:#66d9ef">sub</span> <span style="color:#a6e22e">rotate</span> {
    <span style="color:#66d9ef">my</span> ($matrix) <span style="color:#f92672">=</span> @_;
    @$matrix <span style="color:#f92672">=</span> map [ map $matrix<span style="color:#f92672">-&gt;</span>[ <span style="color:#f92672">-</span>$_ ][ $&#39; ] <span style="color:#f92672">=&gt;</span> <span style="color:#e6db74">//</span> <span style="color:#f92672">..</span> @$matrix ],
        <span style="color:#ae81ff">0</span> <span style="color:#f92672">..</span> $#{ $matrix<span style="color:#f92672">-&gt;</span>[<span style="color:#ae81ff">0</span>] };
}
</code></pre></div><p>We can now clearly see the rotation is done in-place. Once you run it through <code>perltidy</code>, there isn&rsquo;t anything too unusual here. There is one old Perl golf trick, with <code>$'</code> (<a href="https://perldoc.perl.org/perlvar.html#$POSTMATCH"><code>$POSTMATCH</code></a>) and the empty regex (<code>//</code>) as the start of a <code>..</code> range. This is a way to (sort of) access the outer <code>$_</code> loop variable in the inner loop, without having to assign either of them to a different named variable. After <code>//</code>, <code>$'</code> effectively becomes an alias for the outer <code>$_</code>.</p>
<hr>
<hr>
<h1 id="task2">Task #2 › Vowel Strings</h1>
<p>Here is Mohammad&rsquo;s description, abridged:</p>
<p><em>Write a script to accept an integer 1 &lt;= N &lt;= 5 that would print all possible strings of size N formed by using only vowels (a, e, i, o, u).</em></p>
<p><em>The string should follow the following rules:</em></p>
<ul>
<li><code>a</code> can only be followed by <code>e</code> and <code>i</code>.</li>
<li><code>e</code> can only be followed by <code>i</code>.</li>
<li><code>i</code> can only be followed by <code>a</code>, <code>e</code>, <code>o</code>, and <code>u</code>.</li>
<li><code>o</code> can only be followed by <code>a</code> and <code>u</code>.</li>
<li><code>u</code> can only be followed by <code>o</code> and <code>e</code>.</li>
</ul>
<p><em>For example, if the given integer N = 2 then script should print the following strings:</em></p>
<pre><code>ae ai ei ia io iu ie oa ou uo ue
</code></pre><h2 id="solution-types">Solution Types</h2>
<p>This task is a directed graph traversal. The &ldquo;rules,&rdquo; above, define the valid edges. With that in mind, one can implement the graph traversal in any number of ways, or, indeed, go a completely different direction, as we&rsquo;ll see.</p>
<h3 id="dispatch-tables">Dispatch Tables</h3>
<p>Most people used a dispatch table to store the graph edges. The hash key is the current node, and the value is an array of nodes that may be visited from the current node. For example, if <code>$edges{a} = ['e','i']</code>, that means there are directed edges from <code>a</code> to <code>e</code>, and also from <code>a</code> to <code>i</code>.</p>
<h3 id="traversal">Traversal</h3>
<p>Traversing the graph can be done breadth-first or depth-first if you don&rsquo;t care about the ordering (or if you sort at the end). BFS will preserve the ordering.</p>
<p>BFS can be done with a queue, which in Perl is any old array with <code>push</code> and <code>shift</code> (or <code>pop</code> and <code>unshift</code>, if you prefer). You <code>shift</code> a string off the queue, look at the last character, and then <code>push</code> all strings that can be reached from the current string. For example, if you <code>shift</code> the string <code>aei</code> from the array, you would then <code>push</code> <code>aeia</code>, <code>aeie</code>, <code>aeio</code>, and <code>aeiu</code>, because the vowels allowed after <code>i</code> are <code>a, e, o, u</code>.</p>
<p>DFS is done with a stack, which makes it natural for recursive solutions. The operations are very similar, but the stack is implicit with recursion. The strings will be in a depth-first order at the end, but that can be managed with <code>sort</code> (or not at all, if the order is unimportant).</p>
<h3 id="alternatives">Alternatives</h3>
<p>There were a few alternative solutions. Several people used modules like <a href="https://metacpan.org/pod/Algorithm::Combinatorics"><code>Algorithm::Combinatorics</code></a> to generate all variations of the five vowels, and then filter the results with regexps or other means. While these solutions end up throwing out 95-99.5% of strings (it gets worse the longer the strings are), they are fast enough for small inputs.</p>
<hr>
<h2 id="stats-1">Stats</h2>
<ul>
<li>
<p>Number of submissions: <strong>23</strong></p>
</li>
<li>
<p>Total SLOC: <strong>1129</strong></p>
</li>
<li>
<p>Average SLOC: <strong>49</strong></p>
</li>
</ul>
<h2 id="alicia-bielsa2">Alicia Bielsa</h2>
<p><a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-053/alicia-bielsa/perl/ch-2.pl">Alicia Bielsa&rsquo;s solution</a> uses recursion to populate a global list of vowel strings.</p>
<p>She stores the next vowel edges in a hash, and the result vowel strings in <code>@aStrings</code>:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-perl" data-lang="perl"><span style="color:#66d9ef">my</span> %hNodes <span style="color:#f92672">=</span> ();
$hNodes{<span style="color:#e6db74">&#39;a&#39;</span>} <span style="color:#f92672">=</span> [<span style="color:#e6db74">&#39;e&#39;</span>,<span style="color:#e6db74">&#39;i&#39;</span>];
$hNodes{<span style="color:#e6db74">&#39;e&#39;</span>} <span style="color:#f92672">=</span> [<span style="color:#e6db74">&#39;i&#39;</span>];
$hNodes{<span style="color:#e6db74">&#39;i&#39;</span>} <span style="color:#f92672">=</span> [<span style="color:#e6db74">&#39;a&#39;</span>, <span style="color:#e6db74">&#39;e&#39;</span>, <span style="color:#e6db74">&#39;o&#39;</span>, <span style="color:#e6db74">&#39;u&#39;</span>];
$hNodes{<span style="color:#e6db74">&#39;o&#39;</span>} <span style="color:#f92672">=</span> [<span style="color:#e6db74">&#39;a&#39;</span>,<span style="color:#e6db74">&#39;u&#39;</span>];
$hNodes{<span style="color:#e6db74">&#39;u&#39;</span>} <span style="color:#f92672">=</span> [<span style="color:#e6db74">&#39;a&#39;</span>,<span style="color:#e6db74">&#39;e&#39;</span>];

<span style="color:#66d9ef">my</span> @aStrings <span style="color:#f92672">=</span> ();
</code></pre></div><p><code>$hNodes{'u'}</code> should be <code>['o','e']</code>, not <code>['a','e']</code>. When that is changed, Alicia&rsquo;s output is correct.</p>
<p>Alicia calls the recursive <code>addVowel</code> once for each vowel, to start the recursion:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-perl" data-lang="perl"><span style="color:#66d9ef">foreach</span> <span style="color:#66d9ef">my</span> $vowel ( keys(%hNodes)){
    addVowel($size, $vowel,<span style="color:#e6db74">&#39;&#39;</span>);
}

<span style="color:#66d9ef">sub</span> <span style="color:#a6e22e">addVowel</span> {
    <span style="color:#66d9ef">my</span> $currentLevel <span style="color:#f92672">=</span> shift;
    <span style="color:#66d9ef">my</span> $currentVowel <span style="color:#f92672">=</span> shift;
    <span style="color:#66d9ef">my</span> $currentString <span style="color:#f92672">=</span> shift;
    $currentString  <span style="color:#f92672">.=</span> $currentVowel;
    <span style="color:#66d9ef">if</span> ($currentLevel  <span style="color:#f92672">==</span> <span style="color:#ae81ff">1</span>  ){
        push (@aStrings , $currentString);
        <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
    } <span style="color:#66d9ef">else</span> {
        $currentLevel<span style="color:#f92672">--</span>;
    }

    <span style="color:#66d9ef">foreach</span> <span style="color:#66d9ef">my</span> $nextVowel (@{$hNodes{$currentVowel}}){
        addVowel($currentLevel, $nextVowel,$currentString );
    }

    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
}
</code></pre></div><p>This is a solid recursive implementation.</p>
<h2 id="andrezgz2">Andrezgz</h2>
<p><a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-053/andrezgz/perl/ch-2.pl">Andrezgz&rsquo;s solution</a> uses a <code>%vowels</code> hash to store the next vowels:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-perl" data-lang="perl"><span style="color:#66d9ef">my</span> %vowels <span style="color:#f92672">=</span> (
    a <span style="color:#f92672">=&gt;</span> [<span style="color:#e6db74">&#39;e&#39;</span>,<span style="color:#e6db74">&#39;i&#39;</span>],
    e <span style="color:#f92672">=&gt;</span> [<span style="color:#e6db74">&#39;i&#39;</span>],
    i <span style="color:#f92672">=&gt;</span> [<span style="color:#e6db74">&#39;a&#39;</span>, <span style="color:#e6db74">&#39;e&#39;</span>,<span style="color:#e6db74">&#39;o&#39;</span>,<span style="color:#e6db74">&#39;u&#39;</span>],
    o <span style="color:#f92672">=&gt;</span> [<span style="color:#e6db74">&#39;a&#39;</span>,<span style="color:#e6db74">&#39;u&#39;</span>],
    u <span style="color:#f92672">=&gt;</span> [<span style="color:#e6db74">&#39;o&#39;</span>,<span style="color:#e6db74">&#39;e&#39;</span>]
);
</code></pre></div><p>Then things get interesting. Here is the main loop, which initializes a <code>@comb</code> array to the starting five vowels, and then calls <code>add_vowel</code> <code>LENGTH-1</code> times:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-perl" data-lang="perl"><span style="color:#66d9ef">my</span> @comb <span style="color:#f92672">=</span> keys %vowels;
@comb <span style="color:#f92672">=</span> add_vowel(@comb) <span style="color:#66d9ef">for</span> (<span style="color:#ae81ff">2</span><span style="color:#f92672">..</span>$n);
<span style="color:#66d9ef">print</span> $_<span style="color:#f92672">.</span>$/ <span style="color:#66d9ef">for</span> sort @comb;
</code></pre></div><p>And here is the <code>add_vowel</code> sub, which takes a list of strings, and returns a new list of strings:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-perl" data-lang="perl"><span style="color:#66d9ef">sub</span> <span style="color:#a6e22e">add_vowel</span> {
    <span style="color:#66d9ef">my</span> @output;

    <span style="color:#66d9ef">for</span> <span style="color:#66d9ef">my</span> $c (@_) {
        <span style="color:#66d9ef">my</span> $v <span style="color:#f92672">=</span> substr $c, <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>;
        push @output, map { $c <span style="color:#f92672">.</span> $_ } @{$vowels{$v}};
    }

    <span style="color:#66d9ef">return</span> @output
}
</code></pre></div><p>The branching required for this problem happens when <code>add_vowel</code> appends to <code>@output</code>. For each input string, <code>@output</code> gets a copy of that string concatenated with each vowel that may follow the last character in the string.</p>
<p>This is a nice alternative to recursion.</p>
<h2 id="athanasius2">Athanasius</h2>
<p><a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-053/athanasius/perl/ch-2.pl">Athanasius&rsquo;s solution</a> builds up a <code>@temp</code> array using a BFS that becomes the <code>@solution</code>:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-perl" data-lang="perl"><span style="color:#66d9ef">my</span> @solution <span style="color:#f92672">=</span> <span style="color:#e6db74">qw( a e i o u )</span>;    <span style="color:#75715e"># The solution for N = 1</span>

<span style="color:#66d9ef">for</span> ( <span style="color:#ae81ff">2</span> <span style="color:#f92672">..</span> $n ) {
    <span style="color:#66d9ef">my</span> @temp;

    <span style="color:#66d9ef">for</span> <span style="color:#66d9ef">my</span> $string (@solution) {
        <span style="color:#66d9ef">my</span> $last <span style="color:#f92672">=</span> substr $string, <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>;

        push @temp, $string <span style="color:#f92672">.</span> $_ <span style="color:#66d9ef">for</span> $FOLLOWERS{$last}<span style="color:#f92672">-&gt;</span>@<span style="color:#960050;background-color:#1e0010">*;</span>
    <span style="color:#960050;background-color:#1e0010">}</span>

    <span style="color:#960050;background-color:#1e0010">@</span>solution <span style="color:#f92672">=</span> @temp;
}

printf <span style="color:#e6db74">&#34;For N = %d, the %d possible distinct vowel strings are:\n  %s\n&#34;</span>,
  $n, scalar @solution, join <span style="color:#e6db74">&#34;\n  &#34;</span>, @solution;
</code></pre></div><h2 id="cheok-yin-fung2">Cheok-Yin Fung</h2>
<p><a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-053/cheok-yin-fung/perl/ch-2.pl">Cheok-Yin Fung&rsquo;s solution</a> uses the <a href="https://metacpan.org/pod/Tree"><code>Tree</code></a> distribution to create an <a href="https://en.wikipedia.org/wiki/M-ary_tree">m-ary trees</a> of depth <code>$N</code>, where <code>$N</code> is the desired vowel string length.</p>
<p>With <code>Tree</code> (as with most computer science trees, actually), every child node is also a <code>Tree</code>, so the initialization creates a forest of trees and then adds each of those to the root <code>$vowel</code> tree. This is a pattern that will be repeated in the rest of the program:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-perl" data-lang="perl"><span style="color:#66d9ef">my</span> $vowel <span style="color:#f92672">=</span> Tree<span style="color:#f92672">-&gt;</span><span style="color:#66d9ef">new</span>( <span style="color:#e6db74">&#34;&#34;</span> );
$vowel<span style="color:#f92672">-&gt;</span>add_child( Tree<span style="color:#f92672">-&gt;</span><span style="color:#66d9ef">new</span>($_) ) <span style="color:#66d9ef">for</span> <span style="color:#e6db74">qw&lt;a e i o u&gt;</span>; <span style="color:#75715e"># [Simplified for brevity --RyanT]</span>
</code></pre></div><p>Cheok-Yin then calls the following functions:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-perl" data-lang="perl">grow($vowel, <span style="color:#ae81ff">5</span>);
traverse_and_named($vowel, $N, <span style="color:#e6db74">&#34;&#34;</span>);
</code></pre></div><p>The second argument to <code>grow()</code> is apparently the depth, which is hard-coded at 5 for some reason, despite <code>$N</code> being the user-specified depth. I am not sure why <code>grow($vowel, $N)</code> would not suffice, but maybe there is a reason I did not notice.</p>
<p>Here is the recursive <code>grow</code>, and the <code>produce_child</code> sub it calls:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-perl" data-lang="perl"><span style="color:#75715e"># grow : traverse and force the tree nodes produce child(ren)</span>
<span style="color:#66d9ef">sub</span> <span style="color:#a6e22e">grow</span> {
    <span style="color:#66d9ef">my</span> ($t, $d) <span style="color:#f92672">=</span> ($_[<span style="color:#ae81ff">0</span>], $_[<span style="color:#ae81ff">1</span>]);
    produce_child($t);
    <span style="color:#66d9ef">my</span> @t_baby <span style="color:#f92672">=</span> $t<span style="color:#f92672">-&gt;</span>children;
    <span style="color:#66d9ef">foreach</span> (@t_baby) {
        grow($_, $d) <span style="color:#66d9ef">if</span> $_<span style="color:#f92672">-&gt;</span>depth <span style="color:#f92672">&lt;</span> $d;
    }
}

<span style="color:#66d9ef">sub</span> <span style="color:#a6e22e">produce_child</span> {
    <span style="color:#66d9ef">my</span> $t <span style="color:#f92672">=</span> $_[<span style="color:#ae81ff">0</span>];
    <span style="color:#66d9ef">if</span> ($t<span style="color:#f92672">-&gt;</span>size <span style="color:#f92672">==</span> <span style="color:#ae81ff">1</span>) { switch($t<span style="color:#f92672">-&gt;</span>value) {
        <span style="color:#66d9ef">case</span> (<span style="color:#e6db74">&#34;a&#34;</span>) {$t<span style="color:#f92672">-&gt;</span>add_child(Tree<span style="color:#f92672">-&gt;</span><span style="color:#66d9ef">new</span>(<span style="color:#e6db74">&#34;e&#34;</span>)); $t<span style="color:#f92672">-&gt;</span>add_child(Tree<span style="color:#f92672">-&gt;</span><span style="color:#66d9ef">new</span>(<span style="color:#e6db74">&#34;i&#34;</span>));}
        <span style="color:#66d9ef">case</span> (<span style="color:#e6db74">&#34;e&#34;</span>) {$t<span style="color:#f92672">-&gt;</span>add_child(Tree<span style="color:#f92672">-&gt;</span><span style="color:#66d9ef">new</span>(<span style="color:#e6db74">&#34;i&#34;</span>));}
        <span style="color:#66d9ef">case</span> (<span style="color:#e6db74">&#34;i&#34;</span>) {$t<span style="color:#f92672">-&gt;</span>add_child(Tree<span style="color:#f92672">-&gt;</span><span style="color:#66d9ef">new</span>(<span style="color:#e6db74">&#34;a&#34;</span>)); $t<span style="color:#f92672">-&gt;</span>add_child(Tree<span style="color:#f92672">-&gt;</span><span style="color:#66d9ef">new</span>(<span style="color:#e6db74">&#34;e&#34;</span>));
                    $t<span style="color:#f92672">-&gt;</span>add_child(Tree<span style="color:#f92672">-&gt;</span><span style="color:#66d9ef">new</span>(<span style="color:#e6db74">&#34;o&#34;</span>)); $t<span style="color:#f92672">-&gt;</span>add_child(Tree<span style="color:#f92672">-&gt;</span><span style="color:#66d9ef">new</span>(<span style="color:#e6db74">&#34;u&#34;</span>));}
        <span style="color:#66d9ef">case</span> (<span style="color:#e6db74">&#34;o&#34;</span>) {$t<span style="color:#f92672">-&gt;</span>add_child(Tree<span style="color:#f92672">-&gt;</span><span style="color:#66d9ef">new</span>(<span style="color:#e6db74">&#34;a&#34;</span>)); $t<span style="color:#f92672">-&gt;</span>add_child(Tree<span style="color:#f92672">-&gt;</span><span style="color:#66d9ef">new</span>(<span style="color:#e6db74">&#34;u&#34;</span>));}
        <span style="color:#66d9ef">case</span> (<span style="color:#e6db74">&#34;u&#34;</span>) {$t<span style="color:#f92672">-&gt;</span>add_child(Tree<span style="color:#f92672">-&gt;</span><span style="color:#66d9ef">new</span>(<span style="color:#e6db74">&#34;e&#34;</span>)); $t<span style="color:#f92672">-&gt;</span>add_child(Tree<span style="color:#f92672">-&gt;</span><span style="color:#66d9ef">new</span>(<span style="color:#e6db74">&#34;o&#34;</span>));}
    }
    }
}
</code></pre></div><p>Finally, the <code>traverse_and_named</code> function traverses the tree and prints all the nodes at the specified depth:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-perl" data-lang="perl"><span style="color:#66d9ef">sub</span> <span style="color:#a6e22e">traverse_and_named</span> {
    <span style="color:#66d9ef">my</span> ($t, $d, $str) <span style="color:#f92672">=</span> ($_[<span style="color:#ae81ff">0</span>], $_[<span style="color:#ae81ff">1</span>], $_[<span style="color:#ae81ff">2</span>]);
    <span style="color:#66d9ef">print</span> $str<span style="color:#f92672">.</span><span style="color:#e6db74">&#34;\n&#34;</span> <span style="color:#66d9ef">if</span> length($str)<span style="color:#f92672">==</span>$d;
    <span style="color:#66d9ef">my</span> @t_baby <span style="color:#f92672">=</span> $t<span style="color:#f92672">-&gt;</span>children;
    <span style="color:#66d9ef">foreach</span> (@t_baby) {
        traverse_and_named($_, $d, $str<span style="color:#f92672">.</span>$_<span style="color:#f92672">-&gt;</span>value) <span style="color:#66d9ef">if</span> $_<span style="color:#f92672">-&gt;</span>depth<span style="color:#f92672">&lt;=</span>$d;
    }
}
</code></pre></div><p><strong>Blog</strong> › <a href="http://blogs.perl.org/users/c_y_fung/2020/03/tree-as-a-tool-for-enumeration---cys-take-on-pwc053-task-2.html">Tree as a tool for enumeration - CY&rsquo;s take on PWC#053 Task 2</a></p>
<h2 id="colin-crain2">Colin Crain</h2>
<p><a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-053/colin-crain/perl/ch-2.pl">Colin Crain&rsquo;s solution</a> also uses a BFS queue:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-perl" data-lang="perl"><span style="color:#66d9ef">my</span> @output <span style="color:#f92672">=</span> <span style="color:#e6db74">qw( a e i o u )</span>;
<span style="color:#66d9ef">my</span> %following <span style="color:#f92672">=</span> (  a <span style="color:#f92672">=&gt;</span> [ <span style="color:#e6db74">qw( e i     )</span> ],
                   e <span style="color:#f92672">=&gt;</span> [ <span style="color:#e6db74">qw( i       )</span> ],
                   i <span style="color:#f92672">=&gt;</span> [ <span style="color:#e6db74">qw( a e o u )</span> ],
                   o <span style="color:#f92672">=&gt;</span> [ <span style="color:#e6db74">qw( a u     )</span> ],
                   u <span style="color:#f92672">=&gt;</span> [ <span style="color:#e6db74">qw( o e     )</span> ]     );
<span style="color:#66d9ef">my</span> $count <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>;

<span style="color:#66d9ef">while</span> ($count <span style="color:#f92672">&lt;</span> $length)    {
    <span style="color:#66d9ef">my</span> $num_clusters <span style="color:#f92672">=</span> scalar @output;              <span style="color:#75715e">## memoize this now because we will add elements</span>
    <span style="color:#66d9ef">for</span> (<span style="color:#ae81ff">1</span><span style="color:#f92672">..</span>$num_clusters) {
        <span style="color:#66d9ef">my</span> $vowel_cluster <span style="color:#f92672">=</span> shift @output;          <span style="color:#75715e">## shift off a cluster</span>
        <span style="color:#66d9ef">my</span> $vowel <span style="color:#f92672">=</span> substr $vowel_cluster, <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">1</span>;   <span style="color:#75715e">## get the last letter</span>
        <span style="color:#66d9ef">for</span> ($following{$vowel}<span style="color:#f92672">-&gt;</span>@<span style="color:#960050;background-color:#1e0010">*</span>) {              <span style="color:#75715e">## build new combinations from that letter</span>
            push @output, <span style="color:#e6db74">&#34;$vowel_cluster&#34;</span> <span style="color:#f92672">.</span> <span style="color:#e6db74">&#34;$_&#34;</span>;  <span style="color:#75715e">## and add them to the end of the list</span>
        }
    }
    $count<span style="color:#f92672">++</span>;                                       <span style="color:#75715e">## keep track of the cluster length</span>
}
say $_ <span style="color:#66d9ef">for</span> @output;
</code></pre></div><h2 id="dave-cross2">Dave Cross</h2>
<p><a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-053/dave-cross/perl/ch-2.pl">Dave Cross&rsquo;s solution</a> sets up the <code>%strings</code> map, initializes <code>@words</code> with the five starting nodes, and then calls his <code>add_letter</code> function on <code>@words</code> <code>$count-1</code> times to get &ldquo;words&rdquo; of the correct length:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-perl" data-lang="perl"><span style="color:#66d9ef">my</span> $count <span style="color:#f92672">=</span> get_arg();

<span style="color:#66d9ef">my</span> %strings <span style="color:#f92672">=</span> (
  a <span style="color:#f92672">=&gt;</span> [<span style="color:#e6db74">qw[e i]</span>],
  e <span style="color:#f92672">=&gt;</span> [<span style="color:#e6db74">qw[i]</span>],
  i <span style="color:#f92672">=&gt;</span> [<span style="color:#e6db74">qw[a e o u]</span>],
  o <span style="color:#f92672">=&gt;</span> [<span style="color:#e6db74">qw[a u]</span>],
  u <span style="color:#f92672">=&gt;</span> [<span style="color:#e6db74">qw[o e]</span>],
);

<span style="color:#66d9ef">my</span> @words <span style="color:#f92672">=</span> map { [ $_ ] } keys %strings;

@words <span style="color:#f92672">=</span> add_letter(@words) <span style="color:#66d9ef">for</span> <span style="color:#ae81ff">2</span> <span style="color:#f92672">..</span> $count;

say @$_ <span style="color:#66d9ef">for</span> sort { <span style="color:#e6db74">&#34;@$a&#34;</span> <span style="color:#f92672">cmp</span> <span style="color:#e6db74">&#34;@$b&#34;</span> } @words;
</code></pre></div><p>Here is the <code>add_letter</code> function that appends the new word(s) based on the last vowel:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-perl" data-lang="perl"><span style="color:#66d9ef">sub</span> <span style="color:#a6e22e">add_letter</span> {
    <span style="color:#66d9ef">my</span> @input <span style="color:#f92672">=</span> @_;
    <span style="color:#66d9ef">my</span> @output;

    <span style="color:#66d9ef">for</span> <span style="color:#66d9ef">my</span> $in (@input) {
        push @output, map { [ @$in, $_ ] } @{ $strings{ $in<span style="color:#f92672">-&gt;</span>[<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>] } };
    }

    <span style="color:#66d9ef">return</span> @output;
}
</code></pre></div><h2 id="dave-jacoby2">Dave Jacoby</h2>
<p><a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-053/dave-jacoby/perl/ch-2.pl">Dave Jacoby&rsquo;s solution</a> lets his <code>vowel_strings</code> function do all of the heavy lifting:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-perl" data-lang="perl"><span style="color:#66d9ef">my</span> @strings <span style="color:#f92672">=</span> vowel_strings($l);
say join <span style="color:#e6db74">&#34;\n&#34;</span>, @strings;
</code></pre></div><div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-perl" data-lang="perl"><span style="color:#66d9ef">sub</span> <span style="color:#a6e22e">vowel_strings</span> ( $l, $string = &#39;&#39; ) {
    <span style="color:#66d9ef">if</span> ( length $string <span style="color:#f92672">==</span> $l ) {
        <span style="color:#66d9ef">return</span> $string;
    }
    <span style="color:#66d9ef">my</span> @next;
    <span style="color:#66d9ef">my</span> $m <span style="color:#f92672">=</span> length $string <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span> ? <span style="color:#e6db74">&#39;&#39;</span> : substr $string, <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>;
    <span style="color:#66d9ef">if</span> ( $string <span style="color:#f92672">eq</span> <span style="color:#e6db74">&#39;&#39;</span> ) {
        @next <span style="color:#f92672">=</span> <span style="color:#e6db74">qw{ a e i o u}</span>;
    }
    <span style="color:#66d9ef">elsif</span> ( $m <span style="color:#f92672">eq</span> <span style="color:#e6db74">&#39;a&#39;</span> ) {
        @next <span style="color:#f92672">=</span> <span style="color:#e6db74">qw{ e i }</span>;
    }
    <span style="color:#66d9ef">elsif</span> ( $m <span style="color:#f92672">eq</span> <span style="color:#e6db74">&#39;e&#39;</span> ) {
        @next <span style="color:#f92672">=</span> <span style="color:#e6db74">qw{ i }</span>;
    }
    <span style="color:#66d9ef">elsif</span> ( $m <span style="color:#f92672">eq</span> <span style="color:#e6db74">&#39;i&#39;</span> ) {
        @next <span style="color:#f92672">=</span> <span style="color:#e6db74">qw{ a o u e }</span>;
    }
    <span style="color:#66d9ef">elsif</span> ( $m <span style="color:#f92672">eq</span> <span style="color:#e6db74">&#39;o&#39;</span> ) {
        @next <span style="color:#f92672">=</span> <span style="color:#e6db74">qw{ a u }</span>;
    }
    <span style="color:#66d9ef">elsif</span> ( $m <span style="color:#f92672">eq</span> <span style="color:#e6db74">&#39;u&#39;</span> ) {
        @next <span style="color:#f92672">=</span> <span style="color:#e6db74">qw{ o e }</span>;
    }

    <span style="color:#66d9ef">my</span> @output;
    <span style="color:#66d9ef">for</span> <span style="color:#66d9ef">my</span> $n (@next) {
        push @output, vowel_strings( $l, $string <span style="color:#f92672">.</span> $n );
    }
    <span style="color:#66d9ef">return</span> @output;

}
</code></pre></div><p>This is a great recursive DFS implementation. Stylsitically, I might consider using a dispatch table or turnstyle operator to eliminate the <code>if .. elsif .. else</code>, but that&rsquo;s just me. Computationally, I wouldn&rsquo;t change a thing!</p>
<p><strong>Blog</strong> › <a href="https://jacoby.github.io/2020/03/23/rotate-your-matrix-and-string-your-vowels.html">Rotate Your Matrix and String Your Vowels</a></p>
<h2 id="duncan-c-white2">Duncan C. White</h2>
<p><a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-053/duncan-c-white/perl/ch-2.pl">Duncan C. White&rsquo;s solution</a> is also recursive, but uses regexps instead of <code>substr</code> or arrays, to find the last character in each string:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-perl" data-lang="perl"><span style="color:#66d9ef">use</span> Function::Parameters;
die <span style="color:#e6db74">&#34;vowel-strings N\n&#34;</span> <span style="color:#66d9ef">unless</span> @ARGV <span style="color:#f92672">==</span> <span style="color:#ae81ff">1</span>;
<span style="color:#66d9ef">my</span> $n <span style="color:#f92672">=</span> shift;
die <span style="color:#e6db74">&#34;vowel-strings: N ($n) should be 1..5\n&#34;</span> <span style="color:#66d9ef">unless</span> $n <span style="color:#f92672">&gt;=</span> <span style="color:#ae81ff">1</span> <span style="color:#f92672">&amp;&amp;</span> $n <span style="color:#f92672">&lt;=</span> <span style="color:#ae81ff">5</span>;

<span style="color:#66d9ef">my</span> @vow <span style="color:#f92672">=</span> <span style="color:#e6db74">qw(a e i o u)</span>;

<span style="color:#75715e">#</span>
<span style="color:#75715e"># generate( $prefix, $moresteps );</span>
<span style="color:#75715e">#    Generate and print all vowel strings starting with $prefix,</span>
<span style="color:#75715e">#    and taking $moresteps more generative steps, applying</span>
<span style="color:#75715e">#    the above rules at each step to extend the prefix.</span>
<span style="color:#75715e">#</span>
fun generate( $prefix, $moresteps ) {
    <span style="color:#66d9ef">if</span> ( $moresteps <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span> ) {
        say $prefix;
        <span style="color:#66d9ef">return</span>;
    }

    <span style="color:#75715e"># &#39;a&#39; can only be followed by &#39;e&#39; or &#39;i&#39;.</span>
    <span style="color:#66d9ef">if</span> ( $prefix <span style="color:#f92672">=~</span><span style="color:#e6db74"> /a$/</span> ) {
        generate( $prefix <span style="color:#f92672">.</span> <span style="color:#e6db74">&#39;e&#39;</span>, $moresteps <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span> );
        generate( $prefix <span style="color:#f92672">.</span> <span style="color:#e6db74">&#39;i&#39;</span>, $moresteps <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span> );
    }

    <span style="color:#75715e"># &#39;e&#39; can only be followed by &#39;i&#39;.</span>
    <span style="color:#66d9ef">elsif</span> ( $prefix <span style="color:#f92672">=~</span><span style="color:#e6db74"> /e$/</span> ) {
        generate( $prefix <span style="color:#f92672">.</span> <span style="color:#e6db74">&#39;i&#39;</span>, $moresteps <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span> );
    }

    <span style="color:#75715e"># &#39;i&#39; can only be followed by &#39;a&#39;, &#39;e&#39;, &#39;o&#39;, or &#39;u&#39;.</span>
    <span style="color:#66d9ef">elsif</span> ( $prefix <span style="color:#f92672">=~</span><span style="color:#e6db74"> /i$/</span> ) {
        <span style="color:#66d9ef">foreach</span> <span style="color:#66d9ef">my</span> $vowel (@vow) {
            <span style="color:#66d9ef">next</span> <span style="color:#66d9ef">if</span> $vowel <span style="color:#f92672">eq</span> <span style="color:#e6db74">&#39;i&#39;</span>;
            generate( $prefix <span style="color:#f92672">.</span> $vowel, $moresteps <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span> );
        }
    }

    <span style="color:#75715e"># &#39;o&#39; can only be followed by &#39;a&#39; or &#39;u&#39;.</span>
    <span style="color:#66d9ef">elsif</span> ( $prefix <span style="color:#f92672">=~</span><span style="color:#e6db74"> /o$/</span> ) {
        generate( $prefix <span style="color:#f92672">.</span> <span style="color:#e6db74">&#39;a&#39;</span>, $moresteps <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span> );
        generate( $prefix <span style="color:#f92672">.</span> <span style="color:#e6db74">&#39;u&#39;</span>, $moresteps <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span> );
    }

    <span style="color:#75715e"># &#39;u&#39; can only be followed by &#39;o&#39; or &#39;e&#39;.</span>
    <span style="color:#66d9ef">elsif</span> ( $prefix <span style="color:#f92672">=~</span><span style="color:#e6db74"> /u$/</span> ) {
        generate( $prefix <span style="color:#f92672">.</span> <span style="color:#e6db74">&#39;o&#39;</span>, $moresteps <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span> );
        generate( $prefix <span style="color:#f92672">.</span> <span style="color:#e6db74">&#39;e&#39;</span>, $moresteps <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span> );
    }
}

<span style="color:#66d9ef">foreach</span> <span style="color:#66d9ef">my</span> $firstvowel (@vow) {
    generate( $firstvowel, $n <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span> );
}
</code></pre></div><p>Again, a lot of this duplicated code could be eliminated with a dispatch table, but apart from that, I love it.</p>
<h2 id="e-choroba2">E. Choroba</h2>
<p><a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-053/e-choroba/perl/ch-2.pl">E. Choroba&rsquo;s solution</a> ought to look familiar by now (BFS queue):</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-perl" data-lang="perl"><span style="color:#66d9ef">my</span> %next <span style="color:#f92672">=</span> (
    a <span style="color:#f92672">=&gt;</span> [<span style="color:#e6db74">qw[ e i ]</span>],
    e <span style="color:#f92672">=&gt;</span> [<span style="color:#e6db74">qw[ i ]</span>],
    i <span style="color:#f92672">=&gt;</span> [<span style="color:#e6db74">qw[ a e o u ]</span>],
    o <span style="color:#f92672">=&gt;</span> [<span style="color:#e6db74">qw[ a u ]</span>],
    u <span style="color:#f92672">=&gt;</span> [<span style="color:#e6db74">qw[ o e ]</span>]);

<span style="color:#66d9ef">my</span> $n <span style="color:#f92672">=</span> shift;
die <span style="color:#e6db74">&#34;Invalid argument&#34;</span> <span style="color:#66d9ef">unless</span> ($n <span style="color:#e6db74">//</span> <span style="color:#e6db74">&#34;&#34;</span>) <span style="color:#f92672">=~</span><span style="color:#e6db74"> /^[1-5]$/</span>;

<span style="color:#66d9ef">my</span> @agenda <span style="color:#f92672">=</span> sort keys %next;

<span style="color:#66d9ef">while</span> ($n <span style="color:#f92672">&gt;</span> length $agenda[<span style="color:#ae81ff">0</span>]) {
    <span style="color:#66d9ef">my</span> @next;
    <span style="color:#66d9ef">for</span> <span style="color:#66d9ef">my</span> $string (@agenda) {
        <span style="color:#66d9ef">my</span> $last <span style="color:#f92672">=</span> substr $string, <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>;
        push @next, map $string <span style="color:#f92672">.</span> $_, @{ $next{$last} };
    }
    @agenda <span style="color:#f92672">=</span> @next;
}
say <span style="color:#66d9ef">for</span> @agenda;
</code></pre></div><p><strong>Blog</strong> › <a href="http://blogs.perl.org/users/e_choroba/2020/03/perl-weekly-challenge-053-rotate-matrix-and-vowel-strings.html">Rotate Matrix and Vowel Strings</a></p>
<h2 id="jaldhar-h-vyas2">Jaldhar H. Vyas</h2>
<p><a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-053/jaldhar-h-vyas/perl/ch-2.pl">Jaldhar H. Vyas&rsquo;s solution</a> is another good example of a BFS queue:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-perl" data-lang="perl"><span style="color:#66d9ef">sub</span> <span style="color:#a6e22e">generate</span> {
    <span style="color:#66d9ef">my</span> ($n) <span style="color:#f92672">=</span> @_;

    <span style="color:#66d9ef">my</span> %rules <span style="color:#f92672">=</span> (
        a <span style="color:#f92672">=&gt;</span> [<span style="color:#e6db74">qw/ e i /</span>],
        e <span style="color:#f92672">=&gt;</span> [<span style="color:#e6db74">qw/ i /</span>],
        i <span style="color:#f92672">=&gt;</span> [<span style="color:#e6db74">qw/ a e o u /</span>],
        o <span style="color:#f92672">=&gt;</span> [<span style="color:#e6db74">qw/ a u /</span>],
        u <span style="color:#f92672">=&gt;</span> [<span style="color:#e6db74">qw/ e o /</span>]
    );

    <span style="color:#66d9ef">my</span> @generated;
    <span style="color:#66d9ef">for</span> <span style="color:#66d9ef">my</span> $i (<span style="color:#ae81ff">1</span> <span style="color:#f92672">..</span> $n) {
        <span style="color:#66d9ef">if</span> ($i <span style="color:#f92672">==</span> <span style="color:#ae81ff">1</span>) {
            @generated <span style="color:#f92672">=</span> sort keys %rules;
        } <span style="color:#66d9ef">else</span> {
            @generated <span style="color:#f92672">=</span> map {
                <span style="color:#66d9ef">my</span> $e <span style="color:#f92672">=</span> $_;
                map {  $e <span style="color:#f92672">.</span> $_; } @{ $rules{substr $e, <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">1</span>} };
            } @generated;
        }
    }

    <span style="color:#66d9ef">return</span> @generated;
}
</code></pre></div><p><strong>Blog</strong> › <a href="https://www.braincells.com/perl/2020/03/perl_weekly_challenge_week_52.html">Jaldhar&rsquo;s Week #053 Blog</a></p>
<h2 id="javier-luque2">Javier Luque</h2>
<p><a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-053/javier-luque/perl/ch-2.pl">Javier Luque&rsquo;s solution</a> uses <a href="https://metacpan.org/pod/Algorithm::Combinatorics"><code>Algorithm::Combinatorics</code></a>&rsquo; <a href="https://metacpan.org/pod/Algorithm::Combinatorics#variations_with_repetition(@data,-$k)"><code>variations_with_repetition</code></a> function. <code>v_w_r(\@data, $k)</code> returns an iterator that will generate all tuples of length <code>$k</code> from <code>@data</code>. Thus:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-perl" data-lang="perl"><span style="color:#66d9ef">my</span> @vowels <span style="color:#f92672">=</span> (<span style="color:#e6db74">&#39;a&#39;</span>, <span style="color:#e6db74">&#39;e&#39;</span>, <span style="color:#e6db74">&#39;i&#39;</span>, <span style="color:#e6db74">&#39;o&#39;</span>, <span style="color:#e6db74">&#39;u&#39;</span>);
<span style="color:#66d9ef">my</span> $iter <span style="color:#f92672">=</span> variations_with_repetition(<span style="color:#f92672">\</span>@vowels,$size);
<span style="color:#66d9ef">while</span> (<span style="color:#66d9ef">my</span> $v <span style="color:#f92672">=</span> $iter<span style="color:#f92672">-&gt;</span><span style="color:#66d9ef">next</span>) {
    say join <span style="color:#e6db74">&#39;&#39;</span>, @$v
        <span style="color:#66d9ef">if</span> (valid_combination($v));
}
</code></pre></div><p>Javier generates all tuples of <code>$size</code> length of <code>@vowels</code>. Many of these will be invalid, but his <code>valid_combination</code> checks each one in turn to see if it follows the rules of the task:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-perl" data-lang="perl"><span style="color:#66d9ef">sub</span> <span style="color:#a6e22e">valid_combination</span> {
    <span style="color:#66d9ef">my</span> $word <span style="color:#f92672">=</span> shift;

    <span style="color:#75715e"># Faster than a regex</span>
    <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">my</span> $i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; $i <span style="color:#f92672">&lt;</span> scalar(@$word) <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>; $i<span style="color:#f92672">++</span>) {
        <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span> <span style="color:#66d9ef">unless</span>
        _check_letters($word, $i, <span style="color:#e6db74">&#39;a&#39;</span>, <span style="color:#e6db74">&#39;e&#39;</span>, <span style="color:#e6db74">&#39;i&#39;</span>) <span style="color:#f92672">&amp;&amp;</span>
        _check_letters($word, $i, <span style="color:#e6db74">&#39;e&#39;</span>, <span style="color:#e6db74">&#39;i&#39;</span>) <span style="color:#f92672">&amp;&amp;</span>
        _check_letters($word, $i, <span style="color:#e6db74">&#39;i&#39;</span>, <span style="color:#e6db74">&#39;a&#39;</span>, <span style="color:#e6db74">&#39;e&#39;</span>, <span style="color:#e6db74">&#39;o&#39;</span>, <span style="color:#e6db74">&#39;u&#39;</span>) <span style="color:#f92672">&amp;&amp;</span>
        _check_letters($word, $i, <span style="color:#e6db74">&#39;o&#39;</span>, <span style="color:#e6db74">&#39;a&#39;</span>, <span style="color:#e6db74">&#39;u&#39;</span>) <span style="color:#f92672">&amp;&amp;</span>
        _check_letters($word, $i, <span style="color:#e6db74">&#39;u&#39;</span>, <span style="color:#e6db74">&#39;o&#39;</span>, <span style="color:#e6db74">&#39;e&#39;</span>);
    }

    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">1</span>;
}
</code></pre></div><p>The helper <code>_check_letters</code> is called five times per candidate word, once for each vowel, with a list of the allowed vowels that may follow.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-perl" data-lang="perl"><span style="color:#75715e"># Check the folowing letters</span>
<span style="color:#66d9ef">sub</span> <span style="color:#a6e22e">_check_letters</span> {
    <span style="color:#66d9ef">my</span> ($word, $i, $letter, @checks) <span style="color:#f92672">=</span> @_;
    <span style="color:#66d9ef">my</span> $valid <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>;

    <span style="color:#66d9ef">if</span> ($word<span style="color:#f92672">-&gt;</span>[$i] <span style="color:#f92672">eq</span> $letter) {
        $valid <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
        <span style="color:#66d9ef">for</span> <span style="color:#66d9ef">my</span> $check (@checks) {
            $valid <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>
                <span style="color:#66d9ef">if</span> ($word<span style="color:#f92672">-&gt;</span>[$i <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>] <span style="color:#f92672">eq</span> $check);
        }
    }

    <span style="color:#66d9ef">return</span> $valid;
}
</code></pre></div><p>This is a unique solution. Despite the extra looping checking more than 95% invalid solutions at N=5 (99.4% at size 7), it performs better than I would have expected. N=7 takes around 0.7 seconds, vs 0.012 seconds for an iterative BFS solution.</p>
<p><strong>Blog</strong> › <a href="https://perlchallenges.wordpress.com/2020/03/23/perl-weekly-challenge-053/">Perl Weekly Challenge</a></p>
<h2 id="laurent-rosenfeld2">Laurent Rosenfeld</h2>
<p><a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-053/laurent-rosenfeld/perl/ch-2.pl">Laurent Rosenfeld&rsquo;s solution</a> is another recursive DFS example:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-perl" data-lang="perl"><span style="color:#66d9ef">my</span> %successors <span style="color:#f92672">=</span> (
    a <span style="color:#f92672">=&gt;</span> [<span style="color:#e6db74">&#39;e&#39;</span>, <span style="color:#e6db74">&#39;i&#39;</span>],
    e <span style="color:#f92672">=&gt;</span> [<span style="color:#e6db74">&#39;i&#39;</span>],
    i <span style="color:#f92672">=&gt;</span> [<span style="color:#e6db74">qw /a </span>e o u<span style="color:#f92672">/</span>],
    o <span style="color:#f92672">=&gt;</span> [<span style="color:#e6db74">&#39;a&#39;</span>, <span style="color:#e6db74">&#39;u&#39;</span>],
    u <span style="color:#f92672">=&gt;</span> [<span style="color:#e6db74">&#39;e&#39;</span>, <span style="color:#e6db74">&#39;o&#39;</span>]
);
<span style="color:#66d9ef">my</span> @vowels <span style="color:#f92672">=</span> sort keys %successors;
<span style="color:#66d9ef">my</span> $error_msg <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;Please pass a parameter between 1 and 5.&#34;</span>;
<span style="color:#66d9ef">my</span> $str_size <span style="color:#f92672">=</span> shift <span style="color:#f92672">or</span> die $error_msg;
die $error_msg <span style="color:#66d9ef">unless</span> $str_size <span style="color:#f92672">=~</span><span style="color:#e6db74"> /^[1-5]$/</span>;

<span style="color:#66d9ef">for</span> <span style="color:#66d9ef">my</span> $start (@vowels) {
    make_str($str_size <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>, $start, $start);
}

<span style="color:#66d9ef">sub</span> <span style="color:#a6e22e">make_str</span> {
    <span style="color:#66d9ef">my</span> ($left, $last, $string) <span style="color:#f92672">=</span> @_;
    say $string <span style="color:#f92672">and</span> <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">unless</span> $left; <span style="color:#75715e"># Stop the recursion</span>
    <span style="color:#66d9ef">for</span> <span style="color:#66d9ef">my</span> $next (@{$successors{$last}}) {
        <span style="color:#66d9ef">my</span> $new_str <span style="color:#f92672">=</span> $string <span style="color:#f92672">.</span> $next;
        make_str($left <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>, $next, $new_str);
    }
}
</code></pre></div><p><strong>Blog</strong> › <a href="http://blogs.perl.org/users/laurent_r/2020/03/perl-weekly-challenge-53-rotate-matrix-and-vowel-strings.html">Rotate Matrix and Vowel Strings</a></p>
<h2 id="lubos-kolouch2">Lubos Kolouch</h2>
<p><a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-053/lubos-kolouch/perl/ch-2.pl">Lubos Kolouch&rsquo;s solution</a> uses <a href="https://metacpan.org/pod/List::Permute::Limit"><code>List::Permute::Limit</code></a> to generate initial permutations of vowels in his <code>get_permutations</code> sub:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-perl" data-lang="perl"><span style="color:#66d9ef">sub</span> <span style="color:#a6e22e">get_permutations</span> {
    <span style="color:#66d9ef">my</span> $count <span style="color:#f92672">=</span> shift;

    <span style="color:#66d9ef">my</span> @wovels <span style="color:#f92672">=</span> [ <span style="color:#e6db74">&#39;a&#39;</span>, <span style="color:#e6db74">&#39;e&#39;</span>, <span style="color:#e6db74">&#39;i&#39;</span>, <span style="color:#e6db74">&#39;o&#39;</span>, <span style="color:#e6db74">&#39;u&#39;</span> ];

    <span style="color:#66d9ef">my</span> @result;

    <span style="color:#66d9ef">my</span> $iter <span style="color:#f92672">=</span> permute_iter(items<span style="color:#f92672">=&gt;</span>@wovels, nitems<span style="color:#f92672">=&gt;</span>$count);
    <span style="color:#66d9ef">while</span> (<span style="color:#66d9ef">my</span> $ary <span style="color:#f92672">=</span> $iter<span style="color:#f92672">-&gt;</span>()) {
        say @$ary <span style="color:#66d9ef">if</span> check_perm($ary);
    }

}

get_permutations(<span style="color:#ae81ff">2</span>);
</code></pre></div><p>Those permutations are then checked against the task&rsquo;s rules in <code>check_perm</code>:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-perl" data-lang="perl"><span style="color:#66d9ef">my</span> @ok_rules <span style="color:#f92672">=</span> ( <span style="color:#e6db74">&#39;ae&#39;</span>, <span style="color:#e6db74">&#39;ai&#39;</span>, <span style="color:#e6db74">&#39;ei&#39;</span>, <span style="color:#e6db74">&#39;ia&#39;</span>, <span style="color:#e6db74">&#39;ie&#39;</span>, <span style="color:#e6db74">&#39;io&#39;</span>, <span style="color:#e6db74">&#39;iu&#39;</span>, <span style="color:#e6db74">&#39;oa&#39;</span>, <span style="color:#e6db74">&#39;ou&#39;</span>, <span style="color:#e6db74">&#39;uo&#39;</span>, <span style="color:#e6db74">&#39;ue&#39;</span> );
<span style="color:#66d9ef">my</span> %ok_hash <span style="color:#f92672">=</span> map { $_ <span style="color:#f92672">=&gt;</span> <span style="color:#ae81ff">1</span>} @ok_rules;

<span style="color:#66d9ef">sub</span> <span style="color:#a6e22e">check_perm</span> {
    <span style="color:#66d9ef">my</span> $perm <span style="color:#f92672">=</span> shift;

    <span style="color:#66d9ef">my</span> @perm_arr <span style="color:#f92672">=</span> @$perm;

    <span style="color:#66d9ef">for</span> ( <span style="color:#ae81ff">0</span> <span style="color:#f92672">..</span> scalar @perm_arr <span style="color:#f92672">-</span> <span style="color:#ae81ff">2</span> ) {
        <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span> <span style="color:#66d9ef">unless</span> $ok_hash{$perm_arr[$_] <span style="color:#f92672">.</span> $perm_arr[ $_ <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span> ]};
    }

    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">1</span>;
}
</code></pre></div><h2 id="markus-holzer2">Markus Holzer</h2>
<p><a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-053/markus-holzer/perl/ch-2.pl">Markus Holzer&rsquo;s solution</a> revolves around the recursive <code>build_str</code>, called initially with the keys of <code>%rules</code>:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-perl" data-lang="perl"><span style="color:#66d9ef">my</span> %rules <span style="color:#f92672">=</span> (
    a <span style="color:#f92672">=&gt;</span> [ <span style="color:#e6db74">&#39;e&#39;</span>, <span style="color:#e6db74">&#39;i&#39;</span>           ],
    e <span style="color:#f92672">=&gt;</span> [ <span style="color:#e6db74">&#39;i&#39;</span>                ],
    i <span style="color:#f92672">=&gt;</span> [ <span style="color:#e6db74">&#39;a&#39;</span>, <span style="color:#e6db74">&#39;e&#39;</span>, <span style="color:#e6db74">&#39;o&#39;</span>, <span style="color:#e6db74">&#39;u&#39;</span> ],
    o <span style="color:#f92672">=&gt;</span> [ <span style="color:#e6db74">&#39;a&#39;</span>, <span style="color:#e6db74">&#39;u&#39;</span>           ],
    u <span style="color:#f92672">=&gt;</span> [ <span style="color:#e6db74">&#39;e&#39;</span>, <span style="color:#e6db74">&#39;o&#39;</span>           ],
);

main( shift @ARGV <span style="color:#f92672">||</span> <span style="color:#ae81ff">2</span> );

<span style="color:#66d9ef">sub</span> <span style="color:#a6e22e">main</span>( $n ) {
    <span style="color:#66d9ef">my</span> @r;

    build_str( $_, $n, <span style="color:#f92672">\</span>@r ) <span style="color:#66d9ef">for</span> ( sort keys %rules );

    <span style="color:#66d9ef">print</span> join <span style="color:#e6db74">&#34;\n&#34;</span>, @r;
}

<span style="color:#66d9ef">sub</span> <span style="color:#a6e22e">build_str</span> ( $current, $n, $result ) {
    <span style="color:#66d9ef">my</span> $last <span style="color:#f92672">=</span> substr( $current, <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span> );

    <span style="color:#66d9ef">for</span> ( $rules{$last}<span style="color:#f92672">-&gt;</span>@<span style="color:#960050;background-color:#1e0010">*</span> ) {
        given ( $current <span style="color:#f92672">.</span> $_ ) {
            push $result<span style="color:#f92672">-&gt;</span>@<span style="color:#960050;background-color:#1e0010">*</span>, $_ <span style="color:#f92672">and</span> <span style="color:#66d9ef">next</span>
              <span style="color:#66d9ef">if</span> length($_) <span style="color:#f92672">==</span> $n;

            build_str( $_, $n, $result );
        }
    }
}
</code></pre></div><h2 id="mohammad-anwar2">Mohammad S Anwar</h2>
<p><a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-053/mohammad-anwar/perl/ch-2.pl">Mohammad S Anwar&rsquo;s solution</a> uses <a href="https://metacpan.org/pod/Algorithm::Combinatorics"><code>Algorithm::Combinatorics</code></a> to get an iterator that generates <code>$char_sets</code> of the given <code>$count</code> length:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-perl" data-lang="perl"><span style="color:#66d9ef">use</span> Algorithm::Combinatorics <span style="color:#e6db74">qw(combinations)</span>;

<span style="color:#66d9ef">my</span> $chars <span style="color:#f92672">=</span> [<span style="color:#e6db74">qw(a e i o u)</span>];
<span style="color:#66d9ef">my</span> $iter <span style="color:#f92672">=</span> combinations($chars, $count);

<span style="color:#66d9ef">my</span> $char_sets <span style="color:#f92672">=</span> <span style="color:#f92672">[]</span>;
<span style="color:#66d9ef">while</span> (<span style="color:#66d9ef">my</span> $char <span style="color:#f92672">=</span> $iter<span style="color:#f92672">-&gt;</span><span style="color:#66d9ef">next</span>) {
    push @$char_sets, join <span style="color:#e6db74">&#34;&#34;</span>, @$char;
}
</code></pre></div><p>There is a problem with this logic. Using <code>combinations</code> means you are selecting elements without repetition. So, for <code>$count = 5</code>, there is only one possible combination: <code>a e i o u</code>. The results will be incorrect for every count. <code>variations_with_repetition</code> will return all sequences of five vowels, with repetition:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-perl" data-lang="perl"><span style="color:#75715e"># RyanT</span>
<span style="color:#66d9ef">my</span> $char_sets <span style="color:#f92672">=</span> [ map { join <span style="color:#e6db74">&#39;&#39;</span>, @$_ } variations_with_repetition($chars, $count) ];
</code></pre></div><p>Once the list of <code>@$char_sets</code> has been generated, Mohammad then checks each one against the following list of <code>$rules</code> regexps:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-perl" data-lang="perl"><span style="color:#66d9ef">my</span> $rules <span style="color:#f92672">=</span> [
    <span style="color:#e6db74">qr/a(?=[ie])/</span>,
    <span style="color:#e6db74">qr/e(?=[i])/</span>,
    <span style="color:#e6db74">qr/i(?=[aeou])/</span>,
    <span style="color:#e6db74">qr/o(?=[au])/</span>,
    <span style="color:#e6db74">qr/u(?=[oe])/</span>
];

<span style="color:#66d9ef">foreach</span> <span style="color:#66d9ef">my</span> $char_set (@$char_sets) {
    <span style="color:#66d9ef">my</span> $pass <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
    <span style="color:#66d9ef">foreach</span> <span style="color:#66d9ef">my</span> $rule (@$rules) {
        <span style="color:#66d9ef">if</span> ($char_set <span style="color:#f92672">=~</span><span style="color:#e6db74"> /$rule/</span>) {
            $pass <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>;
        }
    }
    <span style="color:#66d9ef">print</span> <span style="color:#e6db74">&#34;$char_set\n&#34;</span> <span style="color:#66d9ef">if</span> ($pass);
}
</code></pre></div><p>Unfortunately, these rules are too permissive, producing invalid words like <code>uuuo</code>. Notice the loop logic: <code>$char_set</code> passes if it matches <em>any</em> of the regexps in <code>@$rules</code>. Each regexp uses a zero-width positive lookahead, but that doesn&rsquo;t matter, as each regexp is applied on its own. The problem is that these rules match valid sequences. There is nothing here to notice an invalid sequence, like <code>uu</code>.</p>
<p>To fix the logic with regexps, you have two basic options: match the <em>entire</em> string, or match <em>in</em>valid segments; i.e., an <code>a</code> must be followed by an <code>i</code> or <code>e</code>, so if it is followed by any other character, the string is invalid. The latter choice is probably easier to do.</p>
<p><strong>Blog</strong> › <a href="https://perlweeklychallenge.org/blog/weekly-challenge-053">BLOG: The Weekly Challenge #053</a></p>
<h2 id="pete-houston2">Pete Houston</h2>
<p><a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-053/pete-houston/perl/ch-2.pl">Pete Houston&rsquo;s solution</a> is a concise recursive implementation:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-perl" data-lang="perl"><span style="color:#66d9ef">my</span> %rules <span style="color:#f92672">=</span> (
    a <span style="color:#f92672">=&gt;</span> [<span style="color:#e6db74">qw/e i/</span>],
    e <span style="color:#f92672">=&gt;</span> [<span style="color:#e6db74">qw/i/</span>],
    i <span style="color:#f92672">=&gt;</span> [<span style="color:#e6db74">qw/a e o u/</span>],
    o <span style="color:#f92672">=&gt;</span> [<span style="color:#e6db74">qw/a u/</span>],
    u <span style="color:#f92672">=&gt;</span> [<span style="color:#e6db74">qw/o e/</span>]
);

<span style="color:#66d9ef">my</span> $n <span style="color:#f92672">=</span> int shift @ARGV;
die <span style="color:#e6db74">&#34;1 &lt;= N &lt;= 5 is the restriction.\n&#34;</span> <span style="color:#66d9ef">unless</span> $n <span style="color:#f92672">&gt;</span> <span style="color:#ae81ff">0</span> <span style="color:#f92672">&amp;&amp;</span> $n <span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">6</span>;

next_str ($_) <span style="color:#66d9ef">for</span> keys %rules;

<span style="color:#66d9ef">sub</span> <span style="color:#a6e22e">next_str</span> {
    <span style="color:#66d9ef">my</span> $string <span style="color:#f92672">=</span> shift;
    <span style="color:#66d9ef">return</span> say $string <span style="color:#66d9ef">if</span> length $string <span style="color:#f92672">==</span> $n;
    <span style="color:#66d9ef">for</span> <span style="color:#66d9ef">my</span> $c (@{$rules{substr ($string, <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">1</span>)}}) {
        next_str (<span style="color:#e6db74">&#34;$string$c&#34;</span>);
    }
}
</code></pre></div><h2 id="roger-bell-west2">Roger Bell West</h2>
<p><a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-053/roger-bell-west/perl/ch-2.pl">Roger Bell West&rsquo;s solution</a> uses a BFS queue, and is decently concise as well:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-perl" data-lang="perl"><span style="color:#66d9ef">my</span> %tree <span style="color:#f92672">=</span> (
    <span style="color:#e6db74">&#39;&#39;</span> <span style="color:#f92672">=&gt;</span> [<span style="color:#e6db74">qw(a e i o u)</span>],
    a  <span style="color:#f92672">=&gt;</span> [<span style="color:#e6db74">qw(e i)</span>],
    e  <span style="color:#f92672">=&gt;</span> [<span style="color:#e6db74">qw(i)</span>],
    i  <span style="color:#f92672">=&gt;</span> [<span style="color:#e6db74">qw(a e o u)</span>],
    o  <span style="color:#f92672">=&gt;</span> [<span style="color:#e6db74">qw(a u)</span>],
    u  <span style="color:#f92672">=&gt;</span> [<span style="color:#e6db74">qw(o e)</span>],
);

<span style="color:#66d9ef">print</span> map { <span style="color:#e6db74">&#34;$_\n&#34;</span> } generate( <span style="color:#ae81ff">2</span>, <span style="color:#f92672">\</span>%tree );

<span style="color:#66d9ef">sub</span> <span style="color:#a6e22e">generate</span> {
    <span style="color:#66d9ef">my</span> ( $len, $tree ) <span style="color:#f92672">=</span> @_;
    <span style="color:#66d9ef">my</span> @list <span style="color:#f92672">=</span> (<span style="color:#e6db74">&#39;&#39;</span>);
    <span style="color:#66d9ef">while</span> (<span style="color:#ae81ff">1</span>) {
        <span style="color:#66d9ef">if</span> ( length( $list[<span style="color:#ae81ff">0</span>] ) <span style="color:#f92672">==</span> $len ) {
            <span style="color:#66d9ef">last</span>;
        }
        <span style="color:#66d9ef">my</span> $r <span style="color:#f92672">=</span> shift @list;
        <span style="color:#66d9ef">my</span> $s <span style="color:#f92672">=</span> substr( $r, <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">1</span> ) <span style="color:#f92672">||</span> <span style="color:#e6db74">&#39;&#39;</span>;
        <span style="color:#66d9ef">foreach</span> <span style="color:#66d9ef">my</span> $extension ( @{ $tree{$s} } ) {
            push @list, $r <span style="color:#f92672">.</span> $extension;
        }
    }
    <span style="color:#66d9ef">return</span> @list;
}
</code></pre></div><h2 id="ruben-westerberg2">Ruben Westerberg</h2>
<p><a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-053/ruben-westerberg/perl/ch-2.pl">Ruben Westerberg&rsquo;s solution</a> has me torn. Ruben supplies his own beautiful <code>combinations</code> sub:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-perl" data-lang="perl"><span style="color:#66d9ef">sub</span> <span style="color:#a6e22e">combinations</span> {
    <span style="color:#66d9ef">my</span> @combinations<span style="color:#f92672">=</span>();
    <span style="color:#66d9ef">my</span> ($data,$size)<span style="color:#f92672">=</span>@_;
    <span style="color:#66d9ef">my</span> @indexes<span style="color:#f92672">=</span>(<span style="color:#ae81ff">0</span>) x ($size<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>);;
    <span style="color:#66d9ef">my</span> $i<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>;
    <span style="color:#66d9ef">until</span> ($indexes[$size]) {
        <span style="color:#66d9ef">my</span> $count<span style="color:#f92672">=</span>List::Util::uniq(@indexes[<span style="color:#ae81ff">0</span><span style="color:#f92672">..</span>$size<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>]);
        <span style="color:#75715e">#print $count,&#34;\n&#34;;;</span>
        push @combinations, [@$data[@indexes[<span style="color:#ae81ff">0</span><span style="color:#f92672">..</span>$size<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>]]] <span style="color:#66d9ef">if</span> $count <span style="color:#f92672">==</span> $size;
        $indexes[<span style="color:#ae81ff">0</span>]<span style="color:#f92672">++</span>;
        <span style="color:#66d9ef">for</span> (<span style="color:#ae81ff">0</span><span style="color:#f92672">..</span>$size<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>) {
            <span style="color:#66d9ef">if</span> ($indexes[$_] <span style="color:#f92672">!=</span> <span style="color:#ae81ff">0</span> <span style="color:#f92672">and</span> <span style="color:#ae81ff">0</span> <span style="color:#f92672">==</span> ($indexes[$_] % <span style="color:#960050;background-color:#1e0010">@$</span>data)) {
                $indexes[$_]<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>;
                $indexes[$_<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>]<span style="color:#f92672">++</span>;
            }
        }
    }
    @combinations;
}
</code></pre></div><p>This <code>combinations</code> sub actually returns permutations, not combinations. Unfortunately, we don&rsquo;t want permutations or combinations, but something like <code>Algorithm::Combinatorics</code>'s <code>variations_with_repetition</code>, which produces correct results when paired with Ruben&rsquo;s loop, below. As written, the <code>combinations</code> sub only produces different orderings of the 5 vowels; it will never repeat them, but it needs to. This is fixable.</p>
<p>Here is Ruben&rsquo;s main loop, which calls <code>combinations</code> and checks the results with regexps:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-perl" data-lang="perl">say <span style="color:#66d9ef">for</span> sort map {join <span style="color:#e6db74">&#34;&#34;</span>,@$_} grep {
    <span style="color:#66d9ef">my</span> $sum<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>;
    <span style="color:#66d9ef">my</span> $s<span style="color:#f92672">=</span>join <span style="color:#e6db74">&#39;&#39;</span>, @$_;
    given ($s) {
        <span style="color:#66d9ef">my</span> @match;            <span style="color:#75715e">#&lt;&lt;Used to force list context</span>
        $sum<span style="color:#f92672">+=</span>@match<span style="color:#f92672">=</span><span style="color:#e6db74">/a/g</span>;        <span style="color:#75715e">#&lt;&lt;Count all a</span>
        $sum<span style="color:#f92672">-=</span>@match<span style="color:#f92672">=</span>(<span style="color:#e6db74">/a[ie]|a$/g</span>);    <span style="color:#75715e">#&lt;&lt;make sure the rules match</span>
                        <span style="color:#75715e">#&lt;&lt;Net sum is 0 for success</span>
        $sum<span style="color:#f92672">+=</span>@match<span style="color:#f92672">=</span><span style="color:#e6db74">/e/g</span>;
        $sum<span style="color:#f92672">-=</span> @match<span style="color:#f92672">=</span>(<span style="color:#e6db74">/ei|e$/g</span>);

        $sum<span style="color:#f92672">+=</span>@match<span style="color:#f92672">=</span><span style="color:#e6db74">/i/g</span>;
        $sum<span style="color:#f92672">-=</span> @match<span style="color:#f92672">=</span><span style="color:#e6db74">/i[aeou]|i$/g</span>;

        $sum<span style="color:#f92672">+=</span>@match<span style="color:#f92672">=</span><span style="color:#e6db74">/o/g</span>;
        $sum<span style="color:#f92672">-=</span>@match<span style="color:#f92672">=</span><span style="color:#e6db74">/o[au]|o$/g</span>;

        $sum<span style="color:#f92672">+=</span>@match<span style="color:#f92672">=</span><span style="color:#e6db74">/u/g</span>;
        $sum<span style="color:#f92672">-=</span>@match<span style="color:#f92672">=</span><span style="color:#e6db74">/u[oe]|u$/g</span>;
    }
    $sum<span style="color:#f92672">==</span><span style="color:#ae81ff">0</span>;
} combinations(<span style="color:#f92672">\</span>@vowels,$n);
</code></pre></div><p>The <code>@match</code> array is used here &ldquo;to force list context&rdquo;. You can do the same thing without the named array using <code>=()=</code>. For example:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-perl" data-lang="perl">$sum<span style="color:#f92672">+=</span>()<span style="color:#f92672">=</span>a<span style="color:#f92672">/</span>g;
</code></pre></div><h2 id="ryan-thompson2">Ryan Thompson</h2>
<p><a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-053/ryan-thompson/perl/ch-2.pl">My solution</a> has two variations, but first the <code>%edges</code> we&rsquo;ll use for both:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-perl" data-lang="perl"><span style="color:#75715e"># Follow rules. Basically graph edges.</span>
<span style="color:#66d9ef">my</span> %edges <span style="color:#f92672">=</span> ( a <span style="color:#f92672">=&gt;</span> [<span style="color:#e6db74">&#39;i&#39;</span>,<span style="color:#e6db74">&#39;e&#39;</span>],  e <span style="color:#f92672">=&gt;</span> [<span style="color:#e6db74">&#39;i&#39;</span>],    i <span style="color:#f92672">=&gt;</span> [<span style="color:#e6db74">&#39;u&#39;</span>,<span style="color:#e6db74">&#39;o&#39;</span>,<span style="color:#e6db74">&#39;e&#39;</span>,<span style="color:#e6db74">&#39;a&#39;</span>],
              o <span style="color:#f92672">=&gt;</span> [<span style="color:#e6db74">&#39;u&#39;</span>,<span style="color:#e6db74">&#39;a&#39;</span>],  u <span style="color:#f92672">=&gt;</span> [<span style="color:#e6db74">&#39;e&#39;</span>,<span style="color:#e6db74">&#39;o&#39;</span>] );
</code></pre></div><p>The first example is a BFS queue implementation:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-perl" data-lang="perl"><span style="color:#66d9ef">sub</span> <span style="color:#a6e22e">vowel_string</span> {
    <span style="color:#66d9ef">my</span> ($len) <span style="color:#f92672">=</span> @_;
    <span style="color:#66d9ef">my</span> @queue <span style="color:#f92672">=</span> sort keys %edges; <span style="color:#75715e"># Pre-load queue</span>

    <span style="color:#66d9ef">my</span> @vstrs;
    <span style="color:#66d9ef">while</span> (<span style="color:#66d9ef">my</span> $str <span style="color:#f92672">=</span> shift @queue) {
        push @vstrs, $str    <span style="color:#f92672">and</span> edges <span style="color:#66d9ef">if</span> $len <span style="color:#f92672">&lt;=</span> length $str;
        push @queue, $str<span style="color:#f92672">.</span>$_ <span style="color:#66d9ef">for</span> @{$edges{ substr $str, <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span> }}
    }
    @vstrs;
}
say <span style="color:#66d9ef">for</span> vowel_string(<span style="color:#ae81ff">6</span>);
</code></pre></div><p>For the second variation, I made an iterator version, which returns a code ref that can be called repeatedly to get the next element in the sequence:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-perl" data-lang="perl"><span style="color:#66d9ef">sub</span> <span style="color:#a6e22e">vowel_iter</span> {
    <span style="color:#66d9ef">my</span> ($len) <span style="color:#f92672">=</span> @_;
    <span style="color:#66d9ef">my</span> @queue <span style="color:#f92672">=</span> sort keys %edges;
    <span style="color:#66d9ef">sub</span> {
        <span style="color:#66d9ef">while</span> (<span style="color:#66d9ef">my</span> $str <span style="color:#f92672">=</span> shift @queue) {
            <span style="color:#66d9ef">return</span> $str <span style="color:#66d9ef">if</span> $len <span style="color:#f92672">&lt;=</span> length $str;
            push @queue, $str<span style="color:#f92672">.</span>$_ <span style="color:#66d9ef">for</span> @{$edges{ substr $str, <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span> }}
        }
    }
}
<span style="color:#66d9ef">my</span> $it <span style="color:#f92672">=</span> vowel_iter(<span style="color:#ae81ff">3</span>);
say <span style="color:#66d9ef">while</span> $_ <span style="color:#f92672">=</span> $it<span style="color:#f92672">-&gt;</span>();
</code></pre></div><p>Both versions have their merits, depending on the application, which is why I included them both.</p>
<p><strong>Blog</strong> › <a href="http://www.ry.ca/2020/03/vowel-strings/">PWC 053 › Vowel Strings</a></p>
<h2 id="saiftynet2">Saif Ahmed</h2>
<p><a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-053/saiftynet/perl/ch-2.pl">Saif Ahmed&rsquo;s solution</a> uses a BFS queue as well:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-perl" data-lang="perl"><span style="color:#66d9ef">sub</span> <span style="color:#a6e22e">vowelStrings</span> {
    <span style="color:#66d9ef">my</span> $target    <span style="color:#f92672">=</span> shift;
    <span style="color:#66d9ef">my</span> %following <span style="color:#f92672">=</span> (        <span style="color:#75715e"># hash containing lists of valid following vowels</span>
        a <span style="color:#f92672">=&gt;</span> [ <span style="color:#e6db74">&#39;e&#39;</span>, <span style="color:#e6db74">&#39;i&#39;</span> ],
        e <span style="color:#f92672">=&gt;</span> [<span style="color:#e6db74">&#39;i&#39;</span>],
        i <span style="color:#f92672">=&gt;</span> [ <span style="color:#e6db74">&#39;a&#39;</span>, <span style="color:#e6db74">&#39;e&#39;</span>, <span style="color:#e6db74">&#39;o&#39;</span>, <span style="color:#e6db74">&#39;u&#39;</span> ],
        o <span style="color:#f92672">=&gt;</span> [ <span style="color:#e6db74">&#39;a&#39;</span>, <span style="color:#e6db74">&#39;u&#39;</span> ],
        u <span style="color:#f92672">=&gt;</span> [ <span style="color:#e6db74">&#39;o&#39;</span>, <span style="color:#e6db74">&#39;e&#39;</span> ],
    );
    <span style="color:#66d9ef">my</span> @list <span style="color:#f92672">=</span> (<span style="color:#e6db74">qw{a e i o u }</span>);    <span style="color:#75715e"># start with list of vowels</span>

    <span style="color:#66d9ef">while</span> ( length $list[<span style="color:#ae81ff">0</span>] <span style="color:#f92672">&lt;</span> $target ) {
        <span style="color:#66d9ef">my</span> $str <span style="color:#f92672">=</span> shift @list;
        push @list, map { $str <span style="color:#f92672">.</span> $_ } @{ $following{ substr( $str, <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">1</span> ) } };
    }
    <span style="color:#66d9ef">return</span> @list,;
}
</code></pre></div><h2 id="user-person2">User Person</h2>
<p><a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-053/user-person/perl/ch-2.pl">User Person&rsquo;s solution</a> does something a little different, with <a href="https://metacpan.org/pod/Math::Int2Base"><code>Math::Int2Base</code></a> (converts to/from arbitrary bases):</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-perl" data-lang="perl"><span style="color:#66d9ef">use</span> Math::Int2Base <span style="color:#e6db74">qw( int2base base2int )</span>;

<span style="color:#66d9ef">my</span> @vowels <span style="color:#f92672">=</span> <span style="color:#e6db74">qw{ a e i o u }</span>;
<span style="color:#66d9ef">my</span> $MAX <span style="color:#f92672">=</span> <span style="color:#e6db74">&#39;4&#39;</span> x $num;

<span style="color:#66d9ef">my</span> $j <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
<span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">my</span> $i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; $j <span style="color:#f92672">&lt;=</span> $MAX; <span style="color:#f92672">++</span>$i) {
    $j <span style="color:#f92672">=</span> int2base($i,<span style="color:#ae81ff">5</span>);
    $j <span style="color:#f92672">=</span> sprintf <span style="color:#e6db74">&#34;%0${num}d&#34;</span>, $j;
    <span style="color:#66d9ef">my</span> $string;
    <span style="color:#66d9ef">foreach</span> (split(<span style="color:#e6db74">//</span>,$j)){
        $string <span style="color:#f92672">.=</span> $vowels[$_];
    }
</code></pre></div><p>In the C-style <code>for</code> loop, the loop variable (<code>$i</code>) is converted to base-5, as there are five vowels. This allows direct indexing within <code>@vowels</code>. All of this is an easy way to emulate the <code>variations_with_repetition</code> function we&rsquo;ve seen previously.</p>
<p>To see whether <code>$string</code> is a valid vowel string, it is checked against five different regexps in turn:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-perl" data-lang="perl">    <span style="color:#66d9ef">if</span> (   $string <span style="color:#f92672">=~</span> <span style="color:#e6db74">m{a[^ei]}</span>
        <span style="color:#f92672">or</span> $string <span style="color:#f92672">=~</span> <span style="color:#e6db74">m{e[^i]}</span>
        <span style="color:#f92672">or</span> $string <span style="color:#f92672">=~</span> <span style="color:#e6db74">m{i[^aeou]}</span>
        <span style="color:#f92672">or</span> $string <span style="color:#f92672">=~</span> <span style="color:#e6db74">m{o[^au]}</span>
        <span style="color:#f92672">or</span> $string <span style="color:#f92672">=~</span> <span style="color:#e6db74">m{u[^oe]}</span> )
    {
        <span style="color:#66d9ef">next</span>;
    } <span style="color:#66d9ef">else</span> {
        <span style="color:#66d9ef">print</span> <span style="color:#e6db74">&#34;$string\n&#34;</span>;
    }
}
</code></pre></div><p>If any of these regexps match, the string is rejected. For example, <code>a[^ei]</code> means that if a string contains an <code>a</code> followed by anything other than an <code>e</code> or an <code>i</code>, it is rejected.</p>
<h2 id="wanderdoc2">Wanderdoc</h2>
<p><a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-053/wanderdoc/perl/ch-2.pl">Wanderdoc&rsquo;s solution</a> uses <a href="https://metacpan.org/pod/Algorithm::Combinatorics"><code>Algorithm::Combinatorics</code></a> again, this time using <code>variations</code>.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-perl" data-lang="perl"><span style="color:#66d9ef">use</span> Algorithm::Combinatorics <span style="color:#e6db74">qw(variations)</span>;
<span style="color:#66d9ef">use</span> Getopt::Std;
<span style="color:#66d9ef">my</span> @vowels <span style="color:#f92672">=</span> <span style="color:#e6db74">qw(a e i o u)</span>;
<span style="color:#66d9ef">my</span> @pos_patterns <span style="color:#f92672">=</span> ( <span style="color:#e6db74">qr/a[ei]/</span> , <span style="color:#e6db74">qr/ei/</span> , <span style="color:#e6db74">qr/i[aeou]/</span>,
                 <span style="color:#e6db74">qr/o[au]/</span>, <span style="color:#e6db74">qr/u[oe]/</span> );
<span style="color:#66d9ef">my</span> @neg_patterns <span style="color:#f92672">=</span> ( <span style="color:#e6db74">qr/a(?=[aou])/</span> , <span style="color:#e6db74">qr/e(?=[aeou])/</span> , <span style="color:#e6db74">qr/i(?=i)/</span>,
                 <span style="color:#e6db74">qr/o(?=[eio])/</span>, <span style="color:#e6db74">qr/u(?=[aiu])/</span> );
<span style="color:#66d9ef">my</span> $iter <span style="color:#f92672">=</span> variations(<span style="color:#f92672">\</span>@vowels, $options{n});
<span style="color:#66d9ef">my</span> %already_found;
</code></pre></div><p>Unfortunately, <code>variations</code> does not include repetitions, and we need repetitions to generate valid strings such as <code>ueiu</code>, so Wanderdoc&rsquo;s program does not generate all valid solutions. The fix is easy, though: just use <code>variations_with_repetition</code> instead.</p>
<p>Here is the loop, which uses the iterator semantics from <code>Algorithm::Combinatorics</code>:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-perl" data-lang="perl">VAR: <span style="color:#66d9ef">while</span> ( <span style="color:#66d9ef">my</span> $c <span style="color:#f92672">=</span> $iter<span style="color:#f92672">-&gt;</span><span style="color:#66d9ef">next</span> ) {
    <span style="color:#66d9ef">my</span> $str <span style="color:#f92672">=</span> join( <span style="color:#e6db74">&#39;&#39;</span>, @$c );

    <span style="color:#66d9ef">for</span> <span style="color:#66d9ef">my</span> $pp (@pos_patterns) {
        <span style="color:#66d9ef">if</span> ( $str <span style="color:#f92672">=~</span><span style="color:#e6db74"> /$pp/</span> ) {
            <span style="color:#66d9ef">for</span> <span style="color:#66d9ef">my</span> $np (@neg_patterns) {
                <span style="color:#66d9ef">next</span> VAR <span style="color:#66d9ef">if</span> $str <span style="color:#f92672">=~</span><span style="color:#e6db74"> /$np/</span>;
            }

            <span style="color:#75715e"># A string with length &gt; 2 can match &gt; 1 patterns.</span>
            $already_found{$str}<span style="color:#f92672">++</span>;
            <span style="color:#66d9ef">print</span> $str, $/ <span style="color:#66d9ef">if</span> <span style="color:#ae81ff">1</span> <span style="color:#f92672">==</span> $already_found{$str};
        }
    }
}
</code></pre></div><p>Note the use of positive and negative patterns (<code>@pos_patterns</code> and <code>@neg_patterns</code>) to reject invalid strings.</p>
<h2 id="yet-ebreo2">Yet Ebreo</h2>
<p><a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-053/yet-ebreo/perl/ch-2.pl">Yet Ebreo&rsquo;s solution</a> is a one-liner based around regexes and <code>glob</code>:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-perl" data-lang="perl"><span style="color:#f92672">!</span>(<span style="color:#e6db74">/a[^ei]/</span> <span style="color:#f92672">||</span> <span style="color:#e6db74">/e[^i]/</span> <span style="color:#f92672">||</span> <span style="color:#e6db74">/i[^aeou]/</span> <span style="color:#f92672">||</span> <span style="color:#e6db74">/o[^au]/</span> <span style="color:#f92672">||</span> <span style="color:#e6db74">/u[^oe]/</span>) <span style="color:#f92672">&amp;&amp;</span> say <span style="color:#66d9ef">for</span> glob <span style="color:#e6db74">&#34;{a,e,i,o,u}&#34;</span> x ($ARGV[<span style="color:#ae81ff">0</span>]<span style="color:#f92672">||</span><span style="color:#ae81ff">1</span>);
</code></pre></div><p>The use of <code>glob</code> here is fantastic.</p>
<hr>
<hr>
<h2 id="blogs">See Also</h2>
<h3 id="blogs-this-week">Blogs this week:</h3>
<p><strong>Cheok-Yin Fung</strong> › <a href="http://blogs.perl.org/users/c_y_fung/2020/03/tree-as-a-tool-for-enumeration---cys-take-on-pwc053-task-2.html">Tree as a tool for enumeration</a> | <a href="http://blogs.perl.org/users/c_y_fung/2020/03/rotation-in-r2---cys-take-on-pwc053-task-1.html">Rotation in R^2</a></p>
<p><strong>Dave Jacoby</strong> › <a href="https://jacoby.github.io/2020/03/23/rotate-your-matrix-and-string-your-vowels.html">Rotate Your Matrix and String Your Vowels</a></p>
<p><strong>E. Choroba</strong> › <a href="http://blogs.perl.org/users/e_choroba/2020/03/perl-weekly-challenge-053-rotate-matrix-and-vowel-strings.html">Perl Weekly Challenge 053: Rotate Matrix and Vowel Strings</a></p>
<p><strong>Jaldhar H. Vyas</strong> › <a href="https://www.braincells.com/perl/2020/03/perl_weekly_challenge_week_52.html">Jaldhar&rsquo;s Week #053 Blog</a></p>
<p><strong>Javier Luque</strong> › <a href="https://perlchallenges.wordpress.com/2020/03/23/perl-weekly-challenge-053/">053 – Perl Weekly Challenge</a></p>
<p><strong>Laurent Rosenfeld</strong> › <a href="http://blogs.perl.org/users/laurent_r/2020/03/perl-weekly-challenge-53-rotate-matrix-and-vowel-strings.html">Rotate Matrix and Vowel Strings</a></p>
<p><strong>Mohammad S Anwar</strong> › <a href="https://perlweeklychallenge.org/blog/weekly-challenge-053">BLOG: The Weekly Challenge #053</a></p>
<p><strong>Ryan Thompson</strong> › <a href="http://www.ry.ca/2020/03/matrix-rotation/">Matrix Rotation</a> | <a href="http://www.ry.ca/2020/03/vowel-strings/">Vowel Strings</a></p>

                </div>
            </div>
        </div>
    </div>
</section>


<!-- Call To Action Section Start -->
<section id="call-to-action">
    <div class="container">
        <div class="row">
            <div class="col-md-12">
                <div class="block">
                    <h2 class="title wow fadeInDown" data-wow-delay=".3s" data-wow-duration="500ms">SO WHAT DO YOU THINK ?</h2>
                    <p class="wow fadeInDown" data-wow-delay=".5s" data-wow-duration="500ms">If you have any suggestions or ideas then please do share with us.</p>
                    <a href="/contact" class="btn btn-default btn-contact wow fadeInDown" data-wow-delay=".7s" data-wow-duration="500ms">Contact with me</a>
                </div>
            </div>

        </div>
    </div>
</section>
<!-- Call To Action Section End -->



<!-- Footer Section Start -->
<footer id="footer">
    <div class="container">
        <div class="row content-justify-between">
            <div class="col-md-8 col-12 text-center text-lg-left text-md-left">
                <p class="copyright">Copyright:
                    <span>
                        2020
                    </span> PerlWeeklyChallenge. Theme Design and Developed by
                    <a href="http://www.Themefisher.com" rel="noreferrer" rel="noreferrer" target="_blank">Themefisher</a>.
                </p>
            </div>
            <div class="col-md-4 col-12">
                <!-- Social Media -->
                <ul class="social text-center text-md-right text-lg-right">
                    <li>
                        <a href="https://twitter.com/PerlWChallenge" class="twitter" rel="noreferrer" target="_blank" title="Follow us">
                            <i class="ion-social-twitter"></i>
                        </a>
                    </li>
                    <li>
                        <a href="/rss.xml" class="rss" target="_blank" title="RSS Feed">
                            <i class="ion-social-rss"></i>
                        </a>
                    </li>
                    <li>
                        <a href="https://www.nomtimes.co.uk/site/shop.do?cref=PerlBooks" title="Free Perl Books" rel="noreferrer" target="_blank">
                            <img src="/images/NomTimes.jpg" style="width:22px; height: 18px;" alt=""/>
                        </a>
                    </li>
                </ul>
            </div>
        </div>
    </div>
</footer>
<!-- footer section end -->

<!-- jquery -->
<script src="https://perlweeklychallenge.org/plugins/jQurey/jquery.min.js"></script>
<!-- Form Validation -->
<script src="https://perlweeklychallenge.org/plugins/form-validation/jquery.form.min.js"></script>
<script src="https://perlweeklychallenge.org/plugins/form-validation/jquery.validate.min.js"></script>
<!-- slick slider -->
<script src="https://perlweeklychallenge.org/plugins/slick/slick.min.js"></script>
<!-- bootstrap js -->
<script src="https://perlweeklychallenge.org/plugins/bootstrap/bootstrap.min.js"></script>
<!-- chart js -->
<script src="https://perlweeklychallenge.org/plugins/chart/highstock.js"></script>
<script src="https://perlweeklychallenge.org/plugins/chart/drilldown.js"></script>
<script src="https://perlweeklychallenge.org/plugins/chart/data.js"></script>
<script src="https://perlweeklychallenge.org/plugins/chart/chart.js"></script>
<script src="https://perlweeklychallenge.org/plugins/chart/pwc-challenge.js"></script>
<script src="https://perlweeklychallenge.org/plugins/chart/gc-challenge.js"></script>
<!-- wow js -->
<script src="https://perlweeklychallenge.org/plugins/wow-js/wow.min.js"></script>
<!-- slider js -->
<script src="https://perlweeklychallenge.org/plugins/slider/slider.js"></script>
<!-- Fancybox -->
<script src="https://perlweeklychallenge.org/plugins/facncybox/jquery.fancybox.js"></script>
<!-- template main js -->

<script src="https://perlweeklychallenge.org/js/script.min.js"></script>
<!-- google analitycs -->
<script>
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
    (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
    m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
    ga('create', 'UA-136524905-1', 'auto');
    ga('send', 'pageview');
</script>
</body>

</html>

