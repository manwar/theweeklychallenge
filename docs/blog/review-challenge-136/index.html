<!DOCTYPE html>
<html class="no-js" lang="en-us">
<head>
    <!-- Basic Page Needs -->

    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta property="og:title"       content="The Weekly Challenge - Perl & Raku"/>
    <meta property="og:type"        content="website"/>
    <meta property="og:url"         content="https://theweeklychallenge.org/"/>
    <meta property="og:image"       content="https://theweeklychallenge.org/images/about/about.jpg"/>
    <meta property="og:description" content="You do not have to be an expert."/>
    <meta name="twitter:card"       content="summary" />
    <meta name="twitter:image"      content="https://theweeklychallenge.org/images/about/about.jpg"/>

    <meta http-equiv="Content-Type" content="text/html; charset=utf-8">

    <meta name="description" content="Colin Crain › Perl Weekly Review #136">
    <meta name="author" content="The Weekly Challenge Team">
    <meta name="generator" content="Hugo 0.67.0-DEV" />

    <!-- Mobile Specific Metas -->
    <meta name="format-detection" content="telephone=no">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>Colin Crain › Perl Weekly Review #136</title>
    <link rel="icon" href="https://theweeklychallenge.org/images/favicon.ico">

    
    <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.0/css/bootstrap.min.css"/>

    <!-- Twitter Bootstrs CSS -->
    <link rel="stylesheet" href="https://theweeklychallenge.org/plugins/bootstrap/bootstrap.min.css">
    <!-- Ionicons Fonts Css -->
    <link rel="stylesheet" href="https://theweeklychallenge.org/plugins/ionicons/ionicons.min.css">
    <!-- animate css -->
    <link rel="stylesheet" href="https://theweeklychallenge.org/plugins/animate-css/animate.css">
    <!-- Hero area slider css-->
    <link rel="stylesheet" href="https://theweeklychallenge.org/plugins/slider/slider.css">
    <!-- slick slider -->
    <link rel="stylesheet" href="https://theweeklychallenge.org/plugins/slick/slick.css">
    <!-- Fancybox -->
    <link rel="stylesheet" href="https://theweeklychallenge.org/plugins/facncybox/jquery.fancybox.css">
    <!-- hover -->
    <link rel="stylesheet" href="https://theweeklychallenge.org/plugins/hover/hover-min.css">
    <!-- Google fonts -->
    <link href='https://fonts.googleapis.com/css?family=Source Code Pro' rel='stylesheet'>
    <!-- template main css file -->
    
    <link rel="stylesheet" href="https://theweeklychallenge.org/css/style.min.css" integrity="" media="screen">
    <link rel="stylesheet" href="https://theweeklychallenge.org/css/main.css">

    <style>
        #goTopButton {
            display: none;          
            position: fixed;        
            bottom: 20px;           
            right: 30px;            
            z-index: 99;            
            border: none;           
            outline: none;          
            background-color: red;  
            color: white;           
            cursor: pointer;        
            padding: 15px;          
            border-radius: 10px;    
            font-size: 18px;        
        }

        #goTopButton:hover {
              background-color: #555;
        }
    </style>


</head>

<body>

<button onclick="goTop()" id="goTopButton" title="Go to top">Top</button>

<script>

    topButton = document.getElementById("goTopButton");

    
    window.onscroll = function() { scrollFunction() };

    function scrollFunction() {
        if (document.body.scrollTop > 40 || document.documentElement.scrollTop > 40) {
            topButton.style.display = "block";
        } else {
            topButton.style.display = "none";
        }
    }

    
    function goTop() {
        document.body.scrollTop = 0; 
        document.documentElement.scrollTop = 0; 
    }

</script>

<section class="top-bar animated-header">
    <div class="container">
        <div class="row">
            <div class="col-lg-12">
                <nav class="navbar navbar-expand-lg navbar-light bg-light">
                    <a class="navbar-brand" href="https://theweeklychallenge.org/">
                        <img src="https://theweeklychallenge.org/images/logo.svg" alt="logo">
                    </a>
                    <button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navgation" aria-controls="navigation"
                        aria-expanded="false" aria-label="Toggle navigation">
                        <span class="navbar-toggler-icon"></span>
                    </button>

                    <div class="collapse navbar-collapse" id="navigation">
                        <ul class="navbar-nav ml-auto">
                            <li class="nav-item">
                                <a class="nav-link" href="https://theweeklychallenge.org/">Home</a>
                            </li>
                            
                            <li class="nav-item">
                                <a class="nav-link" href="https://theweeklychallenge.org/about">About</a>
                            </li>
                            
                            <li class="nav-item">
                                <a class="nav-link" href="https://theweeklychallenge.org/chart">Chart</a>
                            </li>
                            
                            <li class="nav-item">
                                <a class="nav-link" href="https://theweeklychallenge.org/champions">Champions</a>
                            </li>
                            
                            <li class="nav-item">
                                <a class="nav-link" href="https://theweeklychallenge.org/team">Team</a>
                            </li>
                            
                            <li class="nav-item">
                                <a class="nav-link" href="https://theweeklychallenge.org/challenges">Challenges</a>
                            </li>
                            
                            <li class="nav-item">
                                <a class="nav-link" href="https://theweeklychallenge.org/p5-reviews">Perl/Review</a>
                            </li>
                            
                            <li class="nav-item">
                                <a class="nav-link" href="https://theweeklychallenge.org/p6-reviews">Raku/Review</a>
                            </li>
                            
                            <li class="nav-item">
                                <a class="nav-link" href="https://theweeklychallenge.org/recaps">Recaps</a>
                            </li>
                            
                            <li class="nav-item">
                                <a class="nav-link" href="https://theweeklychallenge.org/blogs">Blogs</a>
                            </li>
                            
                            <li class="nav-item">
                                <a class="nav-link" href="https://theweeklychallenge.org/faq">FAQ</a>
                            </li>
                            
                            <li class="nav-item">
                                <a class="nav-link" href="https://theweeklychallenge.org/contact">Contact</a>
                            </li>
                            
                        </ul>
                    </div>
                </nav>
            </div>
        </div>
    </div>
</section>


<section class="global-page-header">
    <div class="container">
        <div class="row">
            <div class="col-md-12">
                <div class="block">
                    <h2>Colin Crain › Perl Weekly Review #136</h2>
                    <div class="portfolio-meta">
                        <span>Monday, Nov 29, 2021</span>|
                        <span> Tags:
                            perl
                        </span>
                    </div>
                </div>
            </div>
        </div>
    </div>
</section>

<section class="single-post">
    <div class="container">
        <div class="row">
            <div class="col-md-12">
                
                <div style="text-align: center" class="post-img">
                    <img class="img-fluid" alt="" src="https://theweeklychallenge.org/images/blog/p5-review-challenge-136.jpg">
                </div>
                
                <div style="text-align: justify" class="post-content">
                    <p>( <em>&hellip;continues from <a href="/blog/review-challenge-135/">previous week</a>.</em> )</p>
<p>Welcome to the Perl review pages for <strong>Week 136</strong> of The Weekly Challenge! Here we will take the time to discuss the  submissions offered up by the team, factor out some common methodologies that came up in those solutions, and highlight some of the unique approaches and unusual code created.</p>
<hr>
<h3 id="why-do-we-do-these-challenges">Why do we do these challenges?</h3>
<p>I suppose any reasonable answers to that question would be as wide ranging and varied as the people who choose to join the team. One thing, though, is clear: it&rsquo;s not a competition, and there are no judges, even if there is a &ldquo;prize&rdquo; of sorts. About that &ndash; I think of it more as an honorarium periodically awarded to acknowledge the efforts we make towards this strange goal. So there&rsquo;s no determination to find the <em>fastest</em>, or the <em>shortest</em>, or even, in some abstract way, the <em>best</em> way to go about things, although I&rsquo;m certain the participants have their own aspirations and personal drives. As Perl is such a wonderfully expressive language, this provides quite a bit of fodder to the core idea of TMTOWTDI, producing a gamut of varied techniques and solutions.</p>
<p>Even the tasks themselves are often open to a certain amount of discretionary interpretation. What we end up with is a situation where each participant is producing something in the manner they find the most interesting or satisfying. Some team members focus on carefully crafted complete applications, thoroughly vetting input data and handling every use case they can think up. Others choose to apply themselves to the logic of the underlying puzzle and making it work in the most elegant way they can. Some eschew modules they would ordinarily reach for, others embrace them, bringing to light wheels perhaps invented years ago that happen to exactly solve the problem in front of them today.</p>
<p>I&rsquo;ve been considering this question for some time and have found one binding commonality between all of us out solving these challenges each week, in that however we normally live our lives, the task in front of us more than likely has nothing to do with any of that. And I think this has great value. We all do what we do, in the real world, and hopefully we do it well. The Weekly Challenge provides us with an opportunity to do something germane to that life yet distinctly different; if we only do the things we already know how to do then we will only do the same things over and over. This is where the &ldquo;challenge&rdquo; aspect comes into play.</p>
<p>So we can consider The Weekly Challenge as providing a problem space outside of our comfort zone, as far out from that comfort as we wish to take things. From those reaches we can gather and learn things, pick and choose and bring what we want back into our lives. Personally, I think that&rsquo;s its greatest value of all.</p>
<hr>
<p>Every week there is an enormous global collective effort made by the team, analyzing and creatively coding the submissions, and that effort deserves credit due.</p>
<p>And that&rsquo;s why I&rsquo;m here, to try and figure out how to do that.</p>
<p>Let&rsquo;s get on with it then, have a look and see what we find.</p>
<hr>
<p><strong><big>For context</big></strong>  before we begin, you may wish to revisit either of the pages for the <a href="/blog/perl-weekly-challenge-136/"><strong>original tasks</strong></a> or the summary <a href="/blog/recap-challenge-136/"><strong>recap</strong></a> of the challenge. But don&rsquo;t worry, the challenges themselves are repeated and presented below as we progress from task by task. Oh, and one more thing before we get started:</p>
<h3 id="getting-in-touch-with-us">Getting in Touch with Us</h3>
<p><a href="mailto:pwc.perfectwave@gmail.com"><img src="/images/blog/Email.svg" height="50" width="50"> Email</a> › Please feel free to email me (Colin) with any feedback, notes, clarifications or whatnot about this review.</p>
<p><a href="https://github.com/manwar/perlweeklychallenge"><img src="/images/blog/Github.svg" height="50" width="50"> GitHub</a> › Submit a pull request to us for any issues you may find with this page.</p>
<p><a href="https://twitter.com/perlwchallenge"><img src="/images/blog/Twitter.svg" height="50" width="50"> Twitter</a> › Join the discussion on Twitter!</p>
<p>I&rsquo;m always curious as to what the people think of these efforts. Everyone here at the PWC would like to hear any feedback you&rsquo;d like to give.</p>
<p><strong>So finally, without further ado&hellip;</strong></p>
<hr>
<h2 id="---nbsp--nbsp--nbsp---task-1pwc136task1-------nbsp--nbsp--nbsp------nbsp--nbsp--nbsp---task-2pwc136task2---nbsp--nbsp--nbsp------nbsp--nbsp--nbsp---blogspwc136blogs----nbsp--nbsp--nbsp---">•             <a href="#PWC136TASK1">Task 1</a>                 •             <a href="#PWC136TASK2">Task 2</a>             	•             <a href="#PWC136BLOGS">BLOGS</a>              	•</h2>
<hr>
<h1 id="PWC136TASK1">TASK 1</h1>
<h1 id="two-friendly">Two Friendly</h1>
<p><em>Submitted by: Mohammad S Anwar</em></p>
<p>You are given 2 positive numbers, $m and $n.</p>
<p>Write a script to find out if the given two numbers are Two Friendly.</p>
<p>Two positive numbers, m and n are two friendly when gcd(m, n) = 2 ^ p where p &gt; 0. The greatest common divisor (gcd) of a set of numbers is the largest positive number that divides all the numbers in the set without remainder.</p>
<p><strong>Example 1</strong></p>
<pre><code>    Input:  $m = 8, $n = 24
    Output: 1

    Reason: gcd(8,24) = 8 =&gt; 2 ^ 3
</code></pre><p><strong>Example 2</strong></p>
<pre><code>    Input:  $m = 26, $n = 39
    Output: 0

    Reason: gcd(26,39) = 13
</code></pre><p><strong>Example 3</strong></p>
<pre><code>    Input:  $m = 4, $n = 10
    Output: 1

    Reason: gcd(4,10) = 2 =&gt; 2 ^ 1
</code></pre><h2 id="about-the-solutions">about the solutions</h2>
<p><a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-136/abigail/perl/ch-1.pl"><strong>Abigail</strong></a>,
<a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-136/adam-russell/perl/ch-1.pl"><strong>Adam Russell</strong></a>,
<a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-136/arne-sommer/perl/ch-1.pl"><strong>Arne Sommer</strong></a>,
<a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-136/athanasius/perl/ch-1.pl"><strong>Athanasius</strong></a>,
<a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-136/bruce-gray/perl/ch-1.pl"><strong>Bruce Gray</strong></a>,
<a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-136/colin-crain/perl/ch-1.pl"><strong>Colin Crain</strong></a>,
<a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-136/dave-jacoby/perl/ch-1.pl"><strong>Dave Jacoby</strong></a>,
<a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-136/duncan-c-white/perl/ch-1.pl"><strong>Duncan C. White</strong></a>,
<a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-136/e-choroba/perl/ch-1.pl"><strong>E. Choroba</strong></a>,
<a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-136/polettix/perl/ch-1.pl"><strong>Flavio Poletti</strong></a>,
<a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-136/jaldhar-h-vyas/perl/ch-1.pl"><strong>Jaldhar H. Vyas</strong></a>,
<a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-136/james-smith/perl/ch-1.pl"><strong>James Smith</strong></a>,
<a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-136/jo-37/perl/ch-1.pl"><strong>Jorg Sommrey</strong></a>,
<a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-136/laurent-rosenfeld/perl/ch-1.pl"><strong>Laurent Rosenfeld</strong></a>,
<a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-136/mattneleigh/perl/ch-1.pl"><strong>Matthew Neleigh</strong></a>,
<a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-136/perlboy1967/perl/ch-1.pl"><strong>Niels van Dijke</strong></a>,
<a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-136/paulo-custodio/perl/ch-1.pl"><strong>Paulo Custodio</strong></a>,
<a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-136/pete-houston/perl/ch-1.pl"><strong>Pete Houston</strong></a>,
<a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-136/robert-dicicco/perl/ch-1.pl"><strong>Robert DiCicco</strong></a>,
<a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-136/roger-bell-west/perl/ch-1.pl"><strong>Roger Bell_West</strong></a>,
<a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-136/sgreen/perl/ch-1.pl"><strong>Simon Green</strong></a>,
<a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-136/ulrich-rieke/perl/ch-1.pl"><strong>Ulrich Rieke</strong></a>, and
<a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-136/wlmb/perl/ch-1.pl"><strong>W. Luis Mochan</strong></a></p>
<p>There were 23 submissions for the first task this past week. The challenge essetially breaks down into two distinct components: one determining the greatest common divisor, and the other deciding whether that value is a power of 2.</p>
<h2 id="a-litany-of-tropes-deducing-a-common-action">A LITANY of TROPES, DEDUCING a COMMON ACTION</h2>
<p><a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-136/wlmb/perl/ch-1.pl"><strong>W. Luis Mochan</strong></a>,
<a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-136/james-smith/perl/ch-1.pl"><strong>James Smith</strong></a>,
<a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-136/mattneleigh/perl/ch-1.pl"><strong>Matthew Neleigh</strong></a>,
<a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-136/athanasius/perl/ch-1.pl"><strong>Athanasius</strong></a>,
<a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-136/colin-crain/perl/ch-1.pl"><strong>Colin Crain</strong></a>,
<a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-136/perlboy1967/perl/ch-1.pl"><strong>Niels van Dijke</strong></a>,
<a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-136/polettix/perl/ch-1.pl"><strong>Flavio Poletti</strong></a>,
<a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-136/sgreen/perl/ch-1.pl"><strong>Simon Green</strong></a>,
<a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-136/laurent-rosenfeld/perl/ch-1.pl"><strong>Laurent Rosenfeld</strong></a>,
<a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-136/duncan-c-white/perl/ch-1.pl"><strong>Duncan C. White</strong></a>,
<a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-136/paulo-custodio/perl/ch-1.pl"><strong>Paulo Custodio</strong></a>, and
<a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-136/roger-bell-west/perl/ch-1.pl"><strong>Roger Bell_West</strong></a></p>
<p>As the analytical requirements to solve the puzzle were clear and separate, we saw a lot of consistency in approach: acquire the GCD, and then determine whether it was a power of 2. It was in the implementations of these parts where we saw all of the differences, specifically leaning into the various schemes to determine its exponential nature or lack thereof. We saw quite a variety of techniques presented to approach this sub-problem.</p>
<p><a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-136/wlmb/perl/ch-1.pl"><strong>W. Luis Mochan</strong></a></p>
<p>  <strong>blog writeup:</strong>
<a href="https://wlmb.github.io/2021/10/25/PWC136/">Perl Weekly Challenge 136 – W. Luis Mochán</a></p>
<p>Luis starts us off with a straightforward breakdown of the parts. Inside a loop over a list of the input candidate values, each is taken in turn and analysed. A <code>gcd</code> function applies Euclid&rsquo;s algorithm to determine that value, and then it&rsquo;s printed to a string using the <code>%b</code> format, as a binary representation. A power of 2 will consist of a single 1 followed by a number of 0s, at least one to satisfy this challenge, continuing to the end of the string. A regular expression is used to match this pattern and there we are.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-perl" data-lang="perl">    <span style="color:#66d9ef">while</span>(defined(<span style="color:#66d9ef">my</span> $x<span style="color:#f92672">=</span>shift @ARGV) <span style="color:#f92672">and</span> defined(<span style="color:#66d9ef">my</span> $y<span style="color:#f92672">=</span>shift @ARGV)){
        <span style="color:#66d9ef">my</span> $d<span style="color:#f92672">=</span>gcd($x, $y);
        <span style="color:#66d9ef">my</span> $b<span style="color:#f92672">=</span>sprintf <span style="color:#e6db74">&#34;%b&#34;</span>, $d;
        <span style="color:#66d9ef">my</span> $output<span style="color:#f92672">=</span>$b<span style="color:#f92672">=~</span><span style="color:#e6db74">/^1(0+)$/</span><span style="color:#f92672">||</span><span style="color:#ae81ff">0</span>;
        <span style="color:#66d9ef">my</span> $power<span style="color:#f92672">=</span>length($1);
        say <span style="color:#e6db74">&#34;Inputs: $x, $y\nOutput: $output\nSince gcd($x,$y)=$d&#34;</span>,
            $power?<span style="color:#e6db74">&#34;=2**$power&#34;</span>:<span style="color:#e6db74">&#34;&#34;</span>;
    }
    <span style="color:#66d9ef">sub</span> <span style="color:#a6e22e">gcd</span> {
        <span style="color:#66d9ef">my</span> ($x,$y)<span style="color:#f92672">=</span>@_;
        $y<span style="color:#f92672">==</span><span style="color:#ae81ff">0</span>?$x:gcd($y,$x%$y);
    }
</code></pre></div><p><a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-136/james-smith/perl/ch-1.pl"><strong>James Smith</strong></a></p>
<p>  <strong>blog writeup:</strong>
<a href="https://github.com/drbaggy/perlweeklychallenge-club/tree/master/challenge-136/james-smith">Perl Weekly Challenge #136</a></p>
<p>James introduces a pre-check that the GCD is not 1 before bothering to continue, as if the two values have absolutely nothing in common they cannot get too friendly. See what I did there? I&rsquo;ll be here all week.</p>
<p>Seriously, I&rsquo;m not going anywhere. Try the fish.</p>
<p>In other news we have an entertaining novel method for determining whether a number is a factor of two. We simply right-shift the value until the rightmost bit is set. Then the number is a power of two if and only if we&rsquo;re equal to 1.</p>
<p>This can only happen if the binary representation is that single 1 followed by a non-specific number of 0s that get shifted off. As we have eliminated 2<sup>0</sup>, the coprime solution, the number of zeroes must be positive and we are two-friendly.</p>
<p>That, my friends, is some seriously artful bit-work.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-perl" data-lang="perl">    <span style="color:#66d9ef">sub</span> <span style="color:#a6e22e">friendly</span> {
      <span style="color:#66d9ef">my</span>($a,$b) <span style="color:#f92672">=</span> @_;
      ($a,$b) <span style="color:#f92672">=</span> ($b,$a%$b) <span style="color:#66d9ef">while</span> $b; <span style="color:#75715e">## Get GCD</span>
      <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span> <span style="color:#66d9ef">if</span> $a <span style="color:#f92672">==</span> <span style="color:#ae81ff">1</span>;           <span style="color:#75715e">## Numbers are co-prime so not friendly</span>
      $a<span style="color:#f92672">&gt;&gt;=</span><span style="color:#ae81ff">1</span> <span style="color:#66d9ef">until</span> $a<span style="color:#f92672">&amp;</span><span style="color:#ae81ff">1</span>;             <span style="color:#75715e">## Remove trailing binary 0 digits</span>
      <span style="color:#66d9ef">return</span> $a <span style="color:#f92672">==</span> <span style="color:#ae81ff">1</span> ? <span style="color:#ae81ff">1</span> : <span style="color:#ae81ff">0</span>;        <span style="color:#75715e">## For powers of two $a == 1</span>
    }
</code></pre></div><p><a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-136/mattneleigh/perl/ch-1.pl"><strong>Matthew Neleigh</strong></a></p>
<p>Matthew brings us yet another method for determining powers of two, by taking the log<sub>2</sub> of the GCD and seeing whether it&rsquo;s a whole number. Ahh, the old invert-exponentiation trick, our good friend the logarithm. As Perl does not have a built-in log-2 operator, we use the identity, from the Perl documentation, of</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-perl" data-lang="perl">    $log2 <span style="color:#f92672">=</span> log($n)<span style="color:#f92672">/</span>log(<span style="color:#ae81ff">2</span>)
</code></pre></div><p>This does, however, by itself just kick the can down the road, as how do we know whether this is whole? A variety of ideas come to mind, but Matthew subtracts the truncated integer from the original and decides whether the result is sufficiently close to 0 to make the call, acknowledging the possible floating-point errors that may arise. Epsilon approximations are always the thorny side of floating-point math. We&rsquo;ll revisit this technique with variant approaches later. There&rsquo;s kind of a lot.</p>
<p>For his GCD function, we have an alternate take on Euclid as well, using recursion to accomplish the necessary looping.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-perl" data-lang="perl">    <span style="color:#66d9ef">sub</span> <span style="color:#a6e22e">two_friendly</span>{
        <span style="color:#66d9ef">my</span> $m <span style="color:#f92672">=</span> int(shift());
        <span style="color:#66d9ef">my</span> $n <span style="color:#f92672">=</span> int(shift());

        <span style="color:#66d9ef">my</span> $power_two;

        <span style="color:#75715e"># Compute the power of two of the greatest</span>
        <span style="color:#75715e"># common divisor</span>
        $power_two <span style="color:#f92672">=</span> log(gcd($m, $n)) <span style="color:#f92672">/</span> log(<span style="color:#ae81ff">2</span>);

        <span style="color:#75715e"># If $power_two looks like an integer</span>
        <span style="color:#75715e"># (accounting for round-off error...) then</span>
        <span style="color:#75715e"># the GCD of $m and $n was a power of two</span>
        <span style="color:#66d9ef">if</span>(abs($power_two <span style="color:#f92672">-</span> int($power_two)) <span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">0.0000000001</span>){
            <span style="color:#66d9ef">return</span>(<span style="color:#ae81ff">1</span>);
        } <span style="color:#66d9ef">else</span>{
            <span style="color:#66d9ef">return</span>(<span style="color:#ae81ff">0</span>);
        }
    }

    <span style="color:#66d9ef">sub</span> <span style="color:#a6e22e">gcd</span>{
        <span style="color:#66d9ef">my</span> $a <span style="color:#f92672">=</span> shift();
        <span style="color:#66d9ef">my</span> $b <span style="color:#f92672">=</span> shift();

        <span style="color:#66d9ef">if</span>($b){
            <span style="color:#66d9ef">return</span>(gcd($b, $a % <span style="color:#960050;background-color:#1e0010">$</span>b));
        } <span style="color:#66d9ef">else</span>{
            <span style="color:#66d9ef">return</span>($a);
        }
    }
</code></pre></div><p><a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-136/athanasius/perl/ch-1.pl"><strong>Athanasius</strong></a></p>
<p>  <strong>additional languages:</strong>
<a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-136/athanasius/raku/ch-1.raku">Raku</a></p>
<p>The monk reaches up on the shelf to the <code>ntheory</code> module, an alias for <code>Math::Prime::Util</code>, to get access to a very fast XS compiled <code>gcd()</code> routine. Why, indeed, reinvent the wheel? Which leaves the remaining question of whether or not the GCD is a power of two. For this they calculate the integer truncation of the log<sub>2</sub> of the GCD plus a rounding factor, 0.5. If 2 raised to the power of  the truncated value  equals the GCD then the original logarithm was whole.</p>
<p>A couple of pockets are made available to take notes on the state: a <code>$friendly</code> variable is a simple 1/0 flag indicating feelings of amiability, and a <code>$reason</code> variable holds an explanitory string set to explain the state of the friendship.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-perl" data-lang="perl">    <span style="color:#66d9ef">my</span> $gcd      <span style="color:#f92672">=</span> gcd( $m, $n );

    <span style="color:#66d9ef">if</span> ($gcd <span style="color:#f92672">==</span> <span style="color:#ae81ff">1</span>)
    {
        $reason <span style="color:#f92672">=</span> <span style="color:#e6db74">&#39;2 ^ 0&#39;</span>;
    }
    <span style="color:#66d9ef">else</span>
    {
        <span style="color:#66d9ef">my</span> $log2 <span style="color:#f92672">=</span> int( (log( $gcd ) <span style="color:#f92672">/</span> log( <span style="color:#ae81ff">2</span> )) <span style="color:#f92672">+</span> <span style="color:#ae81ff">0.5</span> );

        <span style="color:#66d9ef">if</span> ($gcd <span style="color:#f92672">==</span> <span style="color:#ae81ff">2</span> <span style="color:#f92672">**</span> $log2)
        {
            $friendly <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>;
            $reason   <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;2 ^ $log2&#34;</span>;
        }
    }
</code></pre></div><p><a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-136/colin-crain/perl/ch-1.pl"><strong>Colin Crain</strong></a></p>
<p>  <strong>additional languages:</strong>
<a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-136/colin-crain/raku/ch-1.raku">Raku</a></p>
<p>  <strong>blog writeup:</strong>
<a href="https://colincrain.com/2021/10/31/dont-get-too-friendly-its-a-series-of-lies/">Don&rsquo;t Get Too Friendly — It&rsquo;s a Series of Lies - Programming Excursions in Perl and Raku</a></p>
<p>For my own solution, I broke the problem into its two halves and started writing subroutines. I whipped off a quick version of Euclid for the GCD, and started thinking about all the clever ways I could think of to see whether a number was a power of two. I settled of three to implement: dividing out 2s as long as there was no remainder, until we reached either 1 or some other value; taking the log<sub>2</sub> value and examining it for a decimal point; or converting the number to a binary string and counting the incidence of 1s — a homemade <code>popcount</code> function.</p>
<p>When I was done, however, all the sub-solutions were quite compact, so I decided in the end to inline the GCD function and add the dividing down method to make a single routine performing all the steps required. I left the subroutines in for reference, and because they&rsquo;re cool, even unused.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-perl" data-lang="perl">    <span style="color:#66d9ef">sub</span> <span style="color:#a6e22e">is_creepy</span> ( $m, $n ) {
    <span style="color:#75715e">## is $m too friendly towards $n? Does it need to BTFO? Boundaries, people!</span>
        ( $m, $n ) <span style="color:#f92672">=</span> ( $n, $m % <span style="color:#960050;background-color:#1e0010">$</span>n ) <span style="color:#66d9ef">while</span> $n <span style="color:#f92672">&gt;</span> <span style="color:#ae81ff">0</span>;      <span style="color:#75715e">## gcd</span>
        $m <span style="color:#f92672">/=</span> <span style="color:#ae81ff">2</span> <span style="color:#66d9ef">until</span> $m % 2;                           <span style="color:#75715e">## power of 2?</span>
        <span style="color:#66d9ef">return</span> $m <span style="color:#f92672">==</span> <span style="color:#ae81ff">1</span> ? <span style="color:#ae81ff">1</span> : <span style="color:#ae81ff">0</span>;
    }

    <span style="color:#75715e">## the subroutines that form the basis for is_creepy()</span>
    <span style="color:#66d9ef">sub</span> <span style="color:#a6e22e">gcd</span> ( $m, $n ) {
        ( $m, $n ) <span style="color:#f92672">=</span> ( $n, $m % <span style="color:#960050;background-color:#1e0010">$</span>n ) <span style="color:#66d9ef">while</span> $n <span style="color:#f92672">&gt;</span> <span style="color:#ae81ff">0</span>;
        <span style="color:#66d9ef">return</span> $m;
    }

    <span style="color:#66d9ef">sub</span> <span style="color:#a6e22e">power_of_2_div</span> ( $num ) {
        $num <span style="color:#f92672">/=</span> <span style="color:#ae81ff">2</span> <span style="color:#66d9ef">until</span> $num % 2;
        <span style="color:#66d9ef">return</span> $num <span style="color:#f92672">==</span> <span style="color:#ae81ff">1</span> ? <span style="color:#ae81ff">1</span> : <span style="color:#ae81ff">0</span>;
    }

    <span style="color:#66d9ef">sub</span> <span style="color:#a6e22e">power_of_2_log</span> ( $num ) {
        <span style="color:#66d9ef">return</span> ((log($n) <span style="color:#e6db74">/ log(2)) =~ /</span><span style="color:#f92672">\./</span> ? <span style="color:#ae81ff">0</span> : <span style="color:#ae81ff">1</span>);
    }

    <span style="color:#66d9ef">sub</span> <span style="color:#a6e22e">power_of_2_popcount</span> ( $num ) {
        <span style="color:#66d9ef">use</span> List::Util <span style="color:#e6db74">qw(sum)</span>;
        sum( split <span style="color:#e6db74">//</span>, sprintf <span style="color:#e6db74">&#34;%b&#34;</span>, $num ) <span style="color:#f92672">==</span> <span style="color:#ae81ff">1</span> ? <span style="color:#ae81ff">1</span> : <span style="color:#ae81ff">0</span>;
    }
</code></pre></div><p><a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-136/perlboy1967/perl/ch-1.pl"><strong>Niels van Dijke</strong></a></p>
<p>Niels presents us with another compact recursive version of Euclid, and takes the log of the result. If the value is the same as its trunctated integer version, it is whole and thus an even power of the base, in this case 2. I honestly don&rsquo;t think we need to do anything more than this.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-perl" data-lang="perl">    <span style="color:#66d9ef">my</span> $gcd <span style="color:#f92672">=</span> gcd($M,$N);
    <span style="color:#66d9ef">my</span> $exponent <span style="color:#f92672">=</span> log($gcd)<span style="color:#f92672">/</span>log(<span style="color:#ae81ff">2</span>);
    <span style="color:#66d9ef">my</span> $isTwoFriendly <span style="color:#f92672">=</span> (int($exponent) <span style="color:#f92672">==</span> $exponent) <span style="color:#f92672">&amp;&amp;</span> ($exponent <span style="color:#f92672">&gt;</span> <span style="color:#ae81ff">0</span>);

    <span style="color:#66d9ef">sub</span> <span style="color:#a6e22e">gcd</span> ($$) {
      <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span> <span style="color:#f92672">==</span> $_[<span style="color:#ae81ff">1</span>] ? $_[<span style="color:#ae81ff">0</span>] : gcd($_[<span style="color:#ae81ff">1</span>], $_[<span style="color:#ae81ff">0</span>] % <span style="color:#960050;background-color:#1e0010">$</span>_[<span style="color:#ae81ff">1</span>]);
    }
</code></pre></div><p><a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-136/polettix/perl/ch-1.pl"><strong>Flavio Poletti</strong></a></p>
<p>  <strong>additional languages:</strong>
<a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-136/polettix/raku/ch-1.raku">Raku</a></p>
<p>  <strong>blog writeup:</strong>
<a href="https://github.polettix.it/ETOOBUSY/2021/10/27/pwc136-two-friendly/">PWC136 - Two Friendly - ETOOBUSY</a></p>
<p>Flavio presents a set of 4 subroutines, each tackling a single action in the procedure. It really can be viewed as two routines and two wrappers, which might look more familiar conceptually to the other techniques. In four lines:</p>
<ul>
<li>for the GCD, we put Euclid&rsquo;s algorithm in a <code>while</code> lopp until it finishes</li>
<li>for the power of two, we divide down until we get a remainder, in a very interesting manner</li>
<li>we wrap that power of two routine to verify our power raised is greater than 0</li>
<li>we wrap everything in a control structure to hold the logic together to reveal a result</li>
</ul>
<p>The power of 2 routine is particularly interesting, as it bit-shifts right while there is no remaineder and while the function called recursively returns true. It&rsquo;s quite a tightly-wound way to structure that particular logic, which is dividing by 2 as long as there&rsquo;s no remainder, but succeeding if the final value is 1.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-perl" data-lang="perl">    say two_friendly(@ARGV ? @ARGV[<span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">1</span>] : (<span style="color:#ae81ff">8</span>, <span style="color:#ae81ff">24</span>)) ? <span style="color:#ae81ff">1</span> : <span style="color:#ae81ff">0</span>;
    <span style="color:#66d9ef">sub</span> <span style="color:#a6e22e">two_friendly</span> ($m, $n) { positive_power2(gcd($m, $n)) }
    <span style="color:#66d9ef">sub</span> <span style="color:#a6e22e">positive_power2</span> ($x) { $x <span style="color:#f92672">&gt;</span> <span style="color:#ae81ff">1</span> <span style="color:#f92672">&amp;&amp;</span> is_power2($x) }
    <span style="color:#66d9ef">sub</span> <span style="color:#a6e22e">is_power2</span> ($x) { $x <span style="color:#f92672">==</span> <span style="color:#ae81ff">1</span> <span style="color:#f92672">||</span> $x <span style="color:#f92672">&gt;</span> <span style="color:#ae81ff">0</span> <span style="color:#f92672">&amp;&amp;</span> <span style="color:#f92672">!</span>($x % 2) <span style="color:#f92672">&amp;&amp;</span> is_power2($x <span style="color:#f92672">&gt;&gt;</span> <span style="color:#ae81ff">1</span>) }
    <span style="color:#66d9ef">sub</span> <span style="color:#a6e22e">gcd</span> ($A, $B) { ($A, $B) <span style="color:#f92672">=</span> ($B % <span style="color:#960050;background-color:#1e0010">$</span>A, $A) <span style="color:#66d9ef">while</span> $A; $B }
</code></pre></div><p><a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-136/sgreen/perl/ch-1.pl"><strong>Simon Green</strong></a></p>
<p>  <strong>blog writeup:</strong>
<a href="https://dev.to/simongreennet/weekly-challenge-136-12m7">Weekly Challenge 136</a></p>
<p>Simon eschews the taciturn, preferring instead to provide a running commentary for those following along at home. I always find this behavior a welcome respite, and a chance to do a sanity check, to make sure I&rsquo;m explaining things well. His algorithm for finding whether a value is a power of two is quite simple: he simply starts counting up an exponent until the product is either the value or exceeds it. As the number of powers of 2 available is limited by the operating system size of an unsigned int, the number of values to check is relatively  small. This hardly even counts as brute force, but of course it is, after a fashion. We could even hard-code the permissable values into a list, but no one did this.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-perl" data-lang="perl">    <span style="color:#66d9ef">sub</span> <span style="color:#a6e22e">_is_pot</span> {
        <span style="color:#75715e"># Returns whether the number is a power of two.</span>
        <span style="color:#66d9ef">my</span> $n <span style="color:#f92672">=</span> shift;

        <span style="color:#75715e"># Count upwards from 1 until we find a solution or go bust</span>
        <span style="color:#66d9ef">my</span> $i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;

        <span style="color:#66d9ef">while</span> ( <span style="color:#f92672">++</span>$i ) {
            <span style="color:#66d9ef">my</span> $p <span style="color:#f92672">=</span> <span style="color:#ae81ff">2</span><span style="color:#f92672">**</span>$i;
            <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">1</span> <span style="color:#66d9ef">if</span> $p <span style="color:#f92672">==</span> $n;
            <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span> <span style="color:#66d9ef">if</span> $p <span style="color:#f92672">&gt;</span> $n;
        }
    }
</code></pre></div><p><a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-136/laurent-rosenfeld/perl/ch-1.pl"><strong>Laurent Rosenfeld</strong></a></p>
<p>  <strong>additional languages:</strong>
<a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-136/laurent-rosenfeld/raku/ch-1.raku">Raku</a></p>
<p>  <strong>blog writeup:</strong>
<a href="http://blogs.perl.org/users/laurent_r/2021/10/perl-weekly-challenge-136-two-friendly-and-fibonacci-sequence.html">Perl Weekly Challenge 136: Two Friendly and Fibonacci Sequence |aurent_r</a></p>
<p>Laurent provides anopther demonstration of a technique I am quite partial to, that of dividing out 2s as long as there is no remainder. If the final result is 1, we are friendly, if not, then we have an enemy to be feared.</p>
<p>He, um, didn&rsquo;t exactly phrase it like that.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-perl" data-lang="perl">    <span style="color:#66d9ef">sub</span> <span style="color:#a6e22e">is_friendly</span> {
        <span style="color:#66d9ef">my</span> $gcd <span style="color:#f92672">=</span> gcd $_[<span style="color:#ae81ff">0</span>], $_[<span style="color:#ae81ff">1</span>];
        <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span> <span style="color:#66d9ef">if</span> $gcd <span style="color:#f92672">&lt;=</span> <span style="color:#ae81ff">1</span>;
        $gcd <span style="color:#f92672">/=</span> <span style="color:#ae81ff">2</span> <span style="color:#66d9ef">while</span> $gcd % 2 <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>;
        <span style="color:#66d9ef">return</span> $gcd <span style="color:#f92672">==</span> <span style="color:#ae81ff">1</span> ? <span style="color:#ae81ff">1</span> : <span style="color:#ae81ff">0</span>;
    }
</code></pre></div><p><a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-136/duncan-c-white/perl/ch-1.pl"><strong>Duncan C. White</strong></a></p>
<p>Duncan gives us a <code>Function::Parameters</code> function, <code>fun</code>, with a loop implementation of Euclid in a compact, easy-to-read form. For his power-of-two section, he opts to check values until the GCD found is either met or exceeded. I almost wonder whether all of these logarithmic and dividing down solutions are over-thinking the problem, if the number of possible values is limited by the size of the an unsigned int. It is a gracefully simple solution.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-perl" data-lang="perl">    <span style="color:#66d9ef">use</span> Function::Parameters;

    fun gcd( $a, $b )
    {
            <span style="color:#66d9ef">while</span>( $b <span style="color:#f92672">!=</span> <span style="color:#ae81ff">0</span> )
            {
                    ( $a, $b ) <span style="color:#f92672">=</span> ( $b, $a % <span style="color:#960050;background-color:#1e0010">$</span>b );
            }
            <span style="color:#66d9ef">return</span> $a;
    }

    <span style="color:#66d9ef">my</span> $ispower <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
    <span style="color:#66d9ef">for</span>( <span style="color:#66d9ef">my</span> $twop <span style="color:#f92672">=</span> <span style="color:#ae81ff">2</span>; $twop <span style="color:#f92672">&lt;=</span> $gcd; $twop <span style="color:#f92672">*=</span> <span style="color:#ae81ff">2</span> )
    {
        $ispower<span style="color:#f92672">++</span> <span style="color:#66d9ef">if</span> $twop <span style="color:#f92672">==</span> $gcd;
    }
</code></pre></div><p><a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-136/paulo-custodio/perl/ch-1.pl"><strong>Paulo Custodio</strong></a></p>
<p>  <strong>additional languages:</strong>
<a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-136/paulo-custodio/python/ch-1.py">Python</a></p>
<p>Paulo combines importing the <code>gcd()</code> function from <code>ntheory</code> with a further simplification of the already quite straightforward incrementing exponent method, here just multiplying by 2 until we meet or exceed the GCD. This makes for a singularly compact solution.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-perl" data-lang="perl">    <span style="color:#66d9ef">use</span> Modern::Perl;
    <span style="color:#66d9ef">use</span> ntheory <span style="color:#e6db74">&#39;gcd&#39;</span>;

    say is_power_2(gcd(@ARGV));

    <span style="color:#66d9ef">sub</span> <span style="color:#a6e22e">is_power_2</span> {
        <span style="color:#66d9ef">my</span>($n) <span style="color:#f92672">=</span> @_;
        <span style="color:#66d9ef">my</span> $p <span style="color:#f92672">=</span> <span style="color:#ae81ff">2</span>;
        <span style="color:#66d9ef">while</span> ($p <span style="color:#f92672">&lt;=</span> $n) {
            <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">1</span> <span style="color:#66d9ef">if</span> $p<span style="color:#f92672">==</span>$n;
            $p <span style="color:#f92672">*=</span> <span style="color:#ae81ff">2</span>;
        }
        <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
    }
</code></pre></div><p><a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-136/roger-bell-west/perl/ch-1.pl"><strong>Roger Bell_West</strong></a></p>
<p>  <strong>additional languages:</strong>
<a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-136/roger-bell-west/postscript/ch-1.ps">Postscript</a>, <a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-136/roger-bell-west/python/ch-1.py">Python</a>, <a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-136/roger-bell-west/raku/ch-1.p6">Raku</a>, <a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-136/roger-bell-west/ruby/ch-1.rb">Ruby</a>, <a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-136/roger-bell-west/rust/ch-1.rs">Rust</a></p>
<p>  <strong>blog writeup:</strong>
<a href="https://blog.firedrake.org/archive/2021/10/Perl_Weekly_Challenge_136__Fibonacci_Friends.html">RogerBW&rsquo;s Blog: Perl Weekly Challenge 136: Fibonacci Friends</a></p>
<p>And finally, we have Roger, with yet another method for determining whether a number is a power of two. This resembles using a version of <code>popcount</code>, as any power of two in binary will be a single set bit followed by a number of zeros. The popcount version I made sums the digits; the only way the sum can be 1 is if this is the construction. Roger however avoids the trouble of summing, in this case doing something simpler: when we subtract 1 from a power of 2 we will have a sequence of all 1s one less bit in length. So if we perform a bitwise AND on these two values there will be no overlap at all, and the result will be 0. Very clever indeed.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-perl" data-lang="perl">    <span style="color:#66d9ef">sub</span> <span style="color:#a6e22e">ispower2</span> {
      <span style="color:#66d9ef">my</span> $n<span style="color:#f92672">=</span>shift;
      <span style="color:#66d9ef">if</span> ($n<span style="color:#f92672">&lt;</span><span style="color:#ae81ff">2</span>) {
        <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
      }
      <span style="color:#66d9ef">return</span> ($n <span style="color:#f92672">&amp;</span> ($n<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>))<span style="color:#f92672">==</span><span style="color:#ae81ff">0</span>;
    }
</code></pre></div><h2 id="blogs-and-additional-submissions-in-guest-languages-for-task-1">Blogs and Additional Submissions in Guest Languages for Task 1:</h2>
<p><a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-136/abigail/perl/ch-1.pl"><strong>Abigail</strong></a></p>
<p>  <strong>additional languages:</strong>
<a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-136/abigail/awk/ch-1.gawk">Awk</a>, <a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-136/abigail/bash/ch-1.sh">Bash</a>, <a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-136/abigail/bc/ch-1.bc">Bc</a>, <a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-136/abigail/c/ch-1.c">C</a>, <a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-136/abigail/go/ch-1.go">Go</a>, <a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-136/abigail/java/ch-1.java">Java</a>, <a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-136/abigail/lua/ch-1.lua">Lua</a>, <a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-136/abigail/node/ch-1.js">Node</a>, <a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-136/abigail/pascal/ch-1.p">Pascal</a>, <a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-136/abigail/python/ch-1.py">Python</a>, <a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-136/abigail/r/ch-1.r">R</a>, <a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-136/abigail/ruby/ch-1.rb">Ruby</a>, <a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-136/abigail/scheme/ch-1.scm">Scheme</a>, <a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-136/abigail/tcl/ch-1.tcl">Tcl</a></p>
<p>  <strong>blog writeup:</strong>
<a href="https://abigail.github.io/HTML/Perl-Weekly-Challenge/week-136-1.html">Perl Weekly Challenge 136: Two Friendly</a></p>
<p><a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-136/adam-russell/perl/ch-1.pl"><strong>Adam Russell</strong></a></p>
<p>  <strong>additional languages:</strong>
<a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-136/adam-russell/prolog/ch-1.p">Prolog</a></p>
<p>  <strong>blog writeup:</strong>
<a href="http://www.rabbitfarm.com/cgi-bin/blosxom/2021/10/31/perl">Friendly Fibonacci Summands — Perl — RabbitFarm</a></p>
<p>  <strong>blog writeup:</strong>
<a href="http://www.rabbitfarm.com/cgi-bin/blosxom/2021/10/31/prolog">Friendly Fibonacci Summands — Prolog — RabbitFarm</a></p>
<p><a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-136/arne-sommer/perl/ch-1.pl"><strong>Arne Sommer</strong></a></p>
<p>  <strong>additional languages:</strong>
<a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-136/arne-sommer/raku/ch-1.raku">Raku</a></p>
<p>  <strong>blog writeup:</strong>
<a href="https://raku-musings.com/friendly-fibonacci.html">Friendly Fibonacci with Raku and Perl</a></p>
<p><a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-136/bruce-gray/perl/ch-1.pl"><strong>Bruce Gray</strong></a></p>
<p>  <strong>additional languages:</strong>
<a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-136/bruce-gray/raku/ch-1.raku">Raku</a></p>
<p><a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-136/dave-jacoby/perl/ch-1.pl"><strong>Dave Jacoby</strong></a></p>
<p>  <strong>blog writeup:</strong>
<a href="https://jacoby.github.io/2021/10/25/the-sequential-friendly-book-the-weekly-challenge-136.html">The Sequential Friendly Book: The Weekly Challenge #136 | Committed to Memory</a></p>
<p><a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-136/jaldhar-h-vyas/perl/ch-1.pl"><strong>Jaldhar H. Vyas</strong></a></p>
<p>  <strong>additional languages:</strong>
<a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-136/jaldhar-h-vyas/raku/ch-1.sh">Raku</a></p>
<p>  <strong>blog writeup:</strong>
<a href="https://www.braincells.com/perl/2021/10/perl_weekly_challenge_week_136.html">Perl Weekly Challenge: Week 136</a></p>
<p><a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-136/ulrich-rieke/perl/ch-1.pl"><strong>Ulrich Rieke</strong></a></p>
<p>  <strong>additional languages:</strong>
<a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-136/ulrich-rieke/cpp/ch-1.cpp">C++</a>, <a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-136/ulrich-rieke/haskell/ch-1.hs">Haskell</a>, <a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-136/ulrich-rieke/raku/ch-1.raku">Raku</a></p>
<hr>
<hr>
<h1 id="PWC136TASK2">TASK 2</h1>
<h1 id="fibonacci-sequence">Fibonacci Sequence</h1>
<p><em>Submitted by: Mohammad S Anwar</em>
You are given a positive number $n.</p>
<p>Write a script to find how many different sequences you can create using Fibonacci numbers where the sum of unique numbers in each sequence are the same as the given number.</p>
<p>Fibonacci Numbers: 1,2,3,5,8,13,21,34,55,89, …</p>
<p><strong>Example 1</strong></p>
<pre><code>    Input:  $n = 16
    Output: 4

    Reason: There are 2 possible sequences that can be created
            using Fibonacci numbers
              (3 + 13), (1 + 2 + 13),
              (3 + 5 + 8) and (1 + 2 + 5 + 8)
</code></pre><p><strong>Example 2</strong></p>
<pre><code>    Input:  $n = 9
    Output: 2

    Reason: There are 2 possible sequences that can be created
            using Fibonacci numbers
              (1 + 3 + 5) and (1 + 8)
</code></pre><p><strong>Example 3</strong></p>
<pre><code>    Input:  $n = 15
    Output: 2

    Reason: There are 2 possible sequences that can be created
            using Fibonacci numbers
              (2 + 5 + 8) and (2 + 13)
</code></pre><h2 id="about-the-solutions-1">about the solutions</h2>
<p><a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-136/abigail/perl/ch-2.pl"><strong>Abigail</strong></a>,
<a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-136/adam-russell/perl/ch-2.pl"><strong>Adam Russell</strong></a>,
<a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-136/arne-sommer/perl/ch-2.pl"><strong>Arne Sommer</strong></a>,
<a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-136/athanasius/perl/ch-2.pl"><strong>Athanasius</strong></a>,
<a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-136/bruce-gray/perl/ch-2.pl"><strong>Bruce Gray</strong></a>,
<a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-136/cheok-yin-fung/perl/ch-2.pl"><strong>Cheok-Yin Fung</strong></a>,
<a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-136/colin-crain/perl/ch-2.pl"><strong>Colin Crain</strong></a>,
<a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-136/dave-jacoby/perl/ch-2.pl"><strong>Dave Jacoby</strong></a>,
<a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-136/duncan-c-white/perl/ch-2.pl"><strong>Duncan C. White</strong></a>,
<a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-136/e-choroba/perl/ch-2.pl"><strong>E. Choroba</strong></a>,
<a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-136/polettix/perl/ch-2.pl"><strong>Flavio Poletti</strong></a>,
<a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-136/jaldhar-h-vyas/perl/ch-2.pl"><strong>Jaldhar H. Vyas</strong></a>,
<a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-136/james-smith/perl/ch-2.pl"><strong>James Smith</strong></a>,
<a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-136/jo-37/perl/ch-2.pl"><strong>Jorg Sommrey</strong></a>,
<a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-136/laurent-rosenfeld/perl/ch-2.pl"><strong>Laurent Rosenfeld</strong></a>,
<a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-136/mohammad-anwar/perl/ch-2.pl"><strong>Mohammad S Anwar</strong></a>,
<a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-136/perlboy1967/perl/ch-2.pl"><strong>Niels van Dijke</strong></a>,
<a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-136/paulo-custodio/perl/ch-2.pl"><strong>Paulo Custodio</strong></a>,
<a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-136/pete-houston/perl/ch-2.pl"><strong>Pete Houston</strong></a>,
<a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-136/roger-bell-west/perl/ch-2.pl"><strong>Roger Bell_West</strong></a>,
<a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-136/sgreen/perl/ch-2.pl"><strong>Simon Green</strong></a>,
<a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-136/ulrich-rieke/perl/ch-2.pl"><strong>Ulrich Rieke</strong></a>,
<a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-136/wlmb/perl/ch-2.pl"><strong>W. Luis Mochan</strong></a>, and
<a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-136/wanderdoc/perl/ch-2.pl"><strong>Wanderdoc</strong></a></p>
<p>There were 24 submissions for the second task this past week. As Mohammad noted, this task was very similar to <a href="/blog/review-challenge-077/">PWC 077</a>, which I also reviewed, so interested parties may find further reading there. But read this first; there was some overlap, but also some novel and very interesting approaches presented. Generally the construction of the Fibonacci sequences weren&rsquo;t terribly interesting (with a few notable exceptions), and the principle focus was on the arrangements to obtain the desired sum.</p>
<h2 id="there-are-many-roads-to-ascend-the-mountain">there are MANY ROADS to ASCEND THE MOUNTAIN&hellip;</h2>
<p><a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-136/mohammad-anwar/perl/ch-2.pl"><strong>Mohammad S Anwar</strong></a>,
<a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-136/laurent-rosenfeld/perl/ch-2.pl"><strong>Laurent Rosenfeld</strong></a>,
<a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-136/bruce-gray/perl/ch-2.pl"><strong>Bruce Gray</strong></a>,
<a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-136/dave-jacoby/perl/ch-2.pl"><strong>Dave Jacoby</strong></a>,
<a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-136/abigail/perl/ch-2.pl"><strong>Abigail</strong></a>,
<a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-136/arne-sommer/perl/ch-2.pl"><strong>Arne Sommer</strong></a>,
<a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-136/pete-houston/perl/ch-2.pl"><strong>Pete Houston</strong></a>,
<a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-136/jo-37/perl/ch-2.pl"><strong>Jorg Sommrey</strong></a>,
<a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-136/cheok-yin-fung/perl/ch-2.pl"><strong>Cheok-Yin Fung</strong></a>,
<a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-136/e-choroba/perl/ch-2.pl"><strong>E. Choroba</strong></a>,
<a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-136/adam-russell/perl/ch-2.pl"><strong>Adam Russell</strong></a>, and
<a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-136/wanderdoc/perl/ch-2.pl"><strong>Wanderdoc</strong></a></p>
<p>&hellip; as there are streams descending. Select your waterfall.</p>
<p><a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-136/mohammad-anwar/perl/ch-2.pl"><strong>Mohammad S Anwar</strong></a></p>
<p>  <strong>additional languages:</strong>
<a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-136/mohammad-anwar/python/ch-2.py">Python</a>, <a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-136/mohammad-anwar/raku/ch-2.raku">Raku</a>, <a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-136/mohammad-anwar/swift/ch-2.swift">Swift</a></p>
<p>We&rsquo;ll start the discussion today with Mohammad&rsquo;s submission, who starts out noting immediately the similarities between this task and task #1 from week 77, which also dealt with summing unique Fibonacci numbers. As such he draws on that answer, as any reasonable person might.</p>
<p>The root idea here is to create a list of all possible values in the Fibonacci sequence less than the target, then assemble and sum unique combinations of these values and find the ones that fit. Mohammad imports <code>Algorithm::Combinatorics</code> for its <code>combinations</code> function, a class favorite around here.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-perl" data-lang="perl">    <span style="color:#66d9ef">sub</span> <span style="color:#a6e22e">fibonacci_sequence</span> {
        <span style="color:#66d9ef">my</span> ($sum) <span style="color:#f92672">=</span> @_;

        <span style="color:#66d9ef">my</span> $fibonacci     <span style="color:#f92672">=</span> fibonacci_series_upto($sum);
        <span style="color:#66d9ef">my</span> $fibonacci_sum <span style="color:#f92672">=</span> <span style="color:#f92672">[]</span>;
        <span style="color:#66d9ef">foreach</span> <span style="color:#66d9ef">my</span> $i (<span style="color:#ae81ff">1</span> <span style="color:#f92672">..</span> $sum) {
            <span style="color:#66d9ef">last</span> <span style="color:#66d9ef">if</span> ($i <span style="color:#f92672">&gt;</span> @$fibonacci);
            <span style="color:#66d9ef">foreach</span> <span style="color:#66d9ef">my</span> $comb (combinations($fibonacci, $i)) {
                <span style="color:#66d9ef">my</span> $_sum <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
                $_sum <span style="color:#f92672">+=</span> $_ <span style="color:#66d9ef">for</span> @$comb;
                push @$fibonacci_sum, $comb <span style="color:#66d9ef">if</span> ($_sum <span style="color:#f92672">==</span> $sum);
            }
        }

        <span style="color:#66d9ef">return</span> scalar @$fibonacci_sum;
    }
</code></pre></div><p><a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-136/laurent-rosenfeld/perl/ch-2.pl"><strong>Laurent Rosenfeld</strong></a></p>
<p>  <strong>additional languages:</strong>
<a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-136/laurent-rosenfeld/raku/ch-2.raku">Raku</a></p>
<p>  <strong>blog writeup:</strong>
<a href="http://blogs.perl.org/users/laurent_r/2021/10/perl-weekly-challenge-136-two-friendly-and-fibonacci-sequence.html">Perl Weekly Challenge 136: Two Friendly and Fibonacci Sequence |aurent_r</a></p>
<p>Laurent also takes an exhaustive approach to summing all subsequence combinations and selecting the matching values. He does, however, use his own recursive routine to generate the combinations. Matching selections from the sequence are selected, and those exceeding are rejected, and those that can be still augmented are run through again.</p>
<p>As a little lagniappe, we print out the lists that sum correctly.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-perl" data-lang="perl">    <span style="color:#66d9ef">sub</span> <span style="color:#a6e22e">combine</span> {
        <span style="color:#66d9ef">my</span> $target <span style="color:#f92672">=</span> shift;
        <span style="color:#66d9ef">my</span> $count <span style="color:#f92672">=</span> shift;
        <span style="color:#66d9ef">my</span> @out <span style="color:#f92672">=</span> @{$_[<span style="color:#ae81ff">0</span>]};
        <span style="color:#66d9ef">my</span> @in  <span style="color:#f92672">=</span> @{$_[<span style="color:#ae81ff">1</span>]};
        <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">if</span> sum @out <span style="color:#f92672">&gt;</span> $target;
        push @comb, [@out] <span style="color:#f92672">and</span> <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">if</span> sum(@out) <span style="color:#f92672">==</span> $target;
        <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">if</span> $count <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>;
        <span style="color:#66d9ef">for</span> <span style="color:#66d9ef">my</span> $i (<span style="color:#ae81ff">0</span><span style="color:#f92672">..</span>$#in) {
            combine ($target, $count <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>, [@out, $in[$i]], [@in[$i<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span><span style="color:#f92672">..</span>$#in]]);
        }
    }
</code></pre></div><p><a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-136/bruce-gray/perl/ch-2.pl"><strong>Bruce Gray</strong></a></p>
<p>  <strong>additional languages:</strong>
<a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-136/bruce-gray/raku/ch-2.raku">Raku</a></p>
<p>The Fibonacci sequence, of course, has a long and storied, mysterious history full of unexpected quirks and mathematical oddities that has kept it at the forefront of number theory explorations for centuries.</p>
<p>In other words, for those so inclined, there&rsquo;s a lot of meat to be had.</p>
<p>There is, for instance, a known integer sequence in the Online Encyclopedia of Integer Sequences, <a href="https://oeis.org/A000119">A000119</a>, described as &ldquo;Number of representations of n as a sum of distinct Fibonacci numbers&rdquo;. Astute observers will also note that this is only sequence number 119 of some 350,000 entries in a continually growing database, evidence of the importance given the sequence in these pursuits.</p>
<p>By it&rsquo;s description, the data from this sequence seems to be exactly what is being requested. A function is provided, credited to Reinhard Zumkeller:</p>
<pre><code>    a(n) = f(n,1,1) with f(x,y,z) = if x&lt;y then 0^x else f(x-y,y+z,y)+f(x,y+z,y)
</code></pre><p>This impressively compact solution implements that function:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-perl" data-lang="perl">    <span style="color:#66d9ef">sub</span> <span style="color:#a6e22e">f</span> ( $x, $y, $z ) {
        <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span> <span style="color:#f92672">**</span> $x <span style="color:#66d9ef">if</span> $x <span style="color:#f92672">&lt;</span> $y;

        <span style="color:#66d9ef">return</span> f( $x <span style="color:#f92672">-</span> $y, $y <span style="color:#f92672">+</span> $z, $y )
             <span style="color:#f92672">+</span> f( $x     , $y <span style="color:#f92672">+</span> $z, $y );
    }
    <span style="color:#66d9ef">sub</span> <span style="color:#a6e22e">Fibonacci_partitions</span> ( $n ) { <span style="color:#66d9ef">return</span> f($n, <span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">1</span>) }
</code></pre></div><p><a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-136/dave-jacoby/perl/ch-2.pl"><strong>Dave Jacoby</strong></a></p>
<p>  <strong>blog writeup:</strong>
<a href="https://jacoby.github.io/2021/10/25/the-sequential-friendly-book-the-weekly-challenge-136.html">The Sequential Friendly Book: The Weekly Challenge #136 | Committed to Memory</a></p>
<p>Dave &ldquo;Recursion&rdquo; Jacoby, in his repeatedly-cursed heart, plays the recursion card.</p>
<p>It is very effective.</p>
<p>In fact he plays it twice, as what&rsquo;s a good Fibonacci generation algorithm without a nip of recursion to lighten the mood? Now you&rsquo;re getting in the holiday spirit!</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-perl" data-lang="perl">    <span style="color:#66d9ef">sub</span> <span style="color:#a6e22e">recursion</span> ( $n, $ref, $x = [] ) {
        <span style="color:#66d9ef">my</span> @output;
        <span style="color:#66d9ef">my</span> $depth   <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span> <span style="color:#f92672">+</span> scalar $x<span style="color:#f92672">-&gt;</span>@<span style="color:#960050;background-color:#1e0010">*;</span>
        my $sum     <span style="color:#f92672">=</span> sum0 $x<span style="color:#f92672">-&gt;</span>@<span style="color:#960050;background-color:#1e0010">*;</span>
        my $nex<span style="color:#f92672">-&gt;</span>@<span style="color:#960050;background-color:#1e0010">*</span> <span style="color:#960050;background-color:#1e0010">=</span> sort $ref<span style="color:#f92672">-&gt;</span>@<span style="color:#960050;background-color:#1e0010">*;</span>

        return undef <span style="color:#66d9ef">if</span> $sum <span style="color:#f92672">&gt;</span> $n;

        <span style="color:#66d9ef">if</span> ( $sum <span style="color:#f92672">==</span> $n ) {
            $x<span style="color:#f92672">-&gt;</span>@<span style="color:#960050;background-color:#1e0010">*</span> <span style="color:#960050;background-color:#1e0010">=</span> sort { $a <span style="color:#e6db74">&lt;=&gt;</span> $b } map { int $_ } $x<span style="color:#f92672">-&gt;</span>@<span style="color:#960050;background-color:#1e0010">*;</span>
            my $answer <span style="color:#f92672">=</span> join <span style="color:#e6db74">&#39; + &#39;</span>, $x<span style="color:#f92672">-&gt;</span>@<span style="color:#960050;background-color:#1e0010">*;</span>
            return $answer;
        }

        <span style="color:#66d9ef">for</span> <span style="color:#66d9ef">my</span> $i ( <span style="color:#ae81ff">1</span> <span style="color:#f92672">..</span> scalar $nex<span style="color:#f92672">-&gt;</span>@<span style="color:#960050;background-color:#1e0010">*</span> ) {
            <span style="color:#66d9ef">my</span> $v <span style="color:#f92672">=</span> shift $nex<span style="color:#f92672">-&gt;</span>@<span style="color:#960050;background-color:#1e0010">*;</span>
            my $y<span style="color:#f92672">-&gt;</span>@<span style="color:#960050;background-color:#1e0010">*</span> <span style="color:#960050;background-color:#1e0010">=</span> <span style="color:#960050;background-color:#1e0010">$</span>x<span style="color:#f92672">-&gt;</span>@<span style="color:#960050;background-color:#1e0010">*;</span>
            push $y<span style="color:#f92672">-&gt;</span>@<span style="color:#960050;background-color:#1e0010">*</span>, $v;

            <span style="color:#66d9ef">my</span> @return <span style="color:#f92672">=</span> recursion( $n, $nex, $y );
            push @output, @return;
            push $nex<span style="color:#f92672">-&gt;</span>@<span style="color:#960050;background-color:#1e0010">*</span>, $v;
        }
        <span style="color:#66d9ef">return</span> uniq sort grep { defined } @output;
    }
</code></pre></div><p><a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-136/abigail/perl/ch-2.pl"><strong>Abigail</strong></a></p>
<p>  <strong>additional languages:</strong>
<a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-136/abigail/awk/ch-2.awk">Awk</a>, <a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-136/abigail/bash/ch-2.sh">Bash</a>, <a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-136/abigail/bc/ch-2.bc">Bc</a>, <a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-136/abigail/c/ch-2.c">C</a>, <a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-136/abigail/go/ch-2.go">Go</a>, <a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-136/abigail/java/ch-2.java">Java</a>, <a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-136/abigail/lua/ch-2.lua">Lua</a>, <a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-136/abigail/node/ch-2.js">Node</a>, <a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-136/abigail/pascal/ch-2.p">Pascal</a>, <a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-136/abigail/python/ch-2.py">Python</a>, <a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-136/abigail/r/ch-2.r">R</a>, <a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-136/abigail/ruby/ch-2.rb">Ruby</a>, <a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-136/abigail/scheme/ch-2.scm">Scheme</a>, <a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-136/abigail/tcl/ch-2.tcl">Tcl</a></p>
<p>  <strong>blog writeup:</strong>
<a href="https://abigail.github.io/HTML/Perl-Weekly-Challenge/week-136-2.html">Perl Weekly Challenge 136: Fibonacci Sequence</a></p>
<p>Abigail presents us with a compact implementation of a recursive solution, as they explain in their notes:</p>
<ul>
<li>If <code>$this_fib</code> is larger than <code>$target</code>, we have no way to make the target number, so we return 0</li>
<li>If <code>$this_fib</code> is equal to <code>$target</code>, we can only make the target in one way, so we return 1</li>
<li>Else, we recurse. First, we count the number of ways to make <code>$target - $this_fib</code> with Fibonnaci numbers larger than <code>$this_fib</code>, then we count the number of ways making <code>$target</code> with Fibonnaci numbers larger than <code>$this_fib</code>. We return the sum of these counts.</li>
</ul>
<p>Of note a <code>state</code> variable is added to the subroutine to hold a cache for results, avoiding excessive recursive calls. Using the <code>state</code> declaration this way allows one to place the cache within the subroutine itself, instead of using a global value, which encapsulates everything quite nicely.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-perl" data-lang="perl">    <span style="color:#66d9ef">sub</span> <span style="color:#a6e22e">count</span>;
    <span style="color:#66d9ef">sub</span> <span style="color:#a6e22e">count</span> ($target, $this_fib = 1, $prev_fib = 1) {
          state $cache <span style="color:#f92672">=</span> {};
          $$cache {$target, $this_fib} <span style="color:#e6db74">//</span><span style="color:#f92672">=</span>
              $this_fib <span style="color:#f92672">&gt;</span>  $target ? <span style="color:#ae81ff">0</span>
            : $this_fib <span style="color:#f92672">==</span> $target ? <span style="color:#ae81ff">1</span>
            : count ($target <span style="color:#f92672">-</span> $this_fib, $this_fib <span style="color:#f92672">+</span> $prev_fib, $this_fib) <span style="color:#f92672">+</span>
              count ($target,             $this_fib <span style="color:#f92672">+</span> $prev_fib, $this_fib)
    }
</code></pre></div><p><a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-136/arne-sommer/perl/ch-2.pl"><strong>Arne Sommer</strong></a></p>
<p>  <strong>additional languages:</strong>
<a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-136/arne-sommer/raku/ch-2.raku">Raku</a></p>
<p>  <strong>blog writeup:</strong>
<a href="https://raku-musings.com/friendly-fibonacci.html">Friendly Fibonacci with Raku and Perl</a></p>
<p>The most common way to approach the problem was to use some form of combinatorics to examine all possible or plausible combinations from the sequence. Here Arne gives us another solution using <code>Algorithm::Combinatorics</code> for its <code>combinations</code> function.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-perl" data-lang="perl">    <span style="color:#66d9ef">for</span> <span style="color:#66d9ef">my</span> $size (<span style="color:#ae81ff">1</span> <span style="color:#f92672">..</span> @fib)
    {
      <span style="color:#66d9ef">for</span> <span style="color:#66d9ef">my</span> $perm (combinations(<span style="color:#f92672">\</span>@fib, $size))
      {
        <span style="color:#66d9ef">my</span> $sum <span style="color:#f92672">=</span> sum(@$perm);

        <span style="color:#66d9ef">print</span> <span style="color:#e6db74">&#34;: Sequence: &#34;</span>, join(<span style="color:#e6db74">&#34;, &#34;</span>, @$perm), <span style="color:#e6db74">&#34; = $sum&#34;</span> <span style="color:#66d9ef">if</span> $verbose;

        <span style="color:#66d9ef">if</span> ($sum <span style="color:#f92672">==</span> $n)
        {
          $count<span style="color:#f92672">++</span>;
          say <span style="color:#e6db74">&#34; match&#34;</span> <span style="color:#66d9ef">if</span> $verbose;
        }
        <span style="color:#66d9ef">else</span>
        {
          say <span style="color:#e6db74">&#34;&#34;</span> <span style="color:#66d9ef">if</span> $verbose;
        }
      }
    }
</code></pre></div><p><a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-136/pete-houston/perl/ch-2.pl"><strong>Pete Houston</strong></a></p>
<p>Pete presents the problem as a special case of the more general Knapsack Problem, where given a number of items of various weights and values, we are asked to fill a backpack with a set maximum weight to the highest value. In this case the value is set equal to its weight, so we are looking for subsets of items that sum to less than the maximum, optimized to approach that maximum. As the <em>best</em> solution to this problem might leave extra space available, and hence sum to less than the maximum allowed, we need to check the presented solutions to actually equal the target number.</p>
<p>The module <code>Algorithm::Knapsack</code> provides a routine to solve this specific case of the problem. We need only to create a list of Fibonacci numbers less than or equal to the target, and feed it to the Knapsack object thingy, and all the best results will be computed. These may be multiple in the case of a tie. Those solutions that sum to the correct amount are counted.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-perl" data-lang="perl">    <span style="color:#66d9ef">use</span> Algorithm::Knapsack;
    <span style="color:#66d9ef">use</span> List::Util <span style="color:#e6db74">&#39;sum&#39;</span>;

    <span style="color:#66d9ef">my</span> $tot <span style="color:#f92672">=</span> shift;

    <span style="color:#75715e"># Construct a big enough Fibonacci sequence. No duplicates!</span>
    <span style="color:#66d9ef">my</span> @fib <span style="color:#f92672">=</span> (<span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">2</span>);
    push @fib, $fib[<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>] <span style="color:#f92672">+</span> $fib[<span style="color:#f92672">-</span><span style="color:#ae81ff">2</span>] <span style="color:#66d9ef">while</span> $fib[<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>] <span style="color:#f92672">+</span> $fib[<span style="color:#f92672">-</span><span style="color:#ae81ff">2</span>] <span style="color:#f92672">&lt;=</span> $tot;

    <span style="color:#75715e"># Process</span>
    <span style="color:#66d9ef">my</span> $sack <span style="color:#f92672">=</span> Algorithm::Knapsack<span style="color:#f92672">-&gt;</span><span style="color:#66d9ef">new</span> (
        capacity <span style="color:#f92672">=&gt;</span> $tot,
        weights  <span style="color:#f92672">=&gt;</span> <span style="color:#f92672">\</span>@fib,
    );
    $sack<span style="color:#f92672">-&gt;</span>compute;

    <span style="color:#66d9ef">my</span> $combos <span style="color:#f92672">=</span> grep { sum (@fib[@$_]) <span style="color:#f92672">==</span> $tot } $sack<span style="color:#f92672">-&gt;</span>solutions;

    <span style="color:#75715e"># Output</span>
    <span style="color:#66d9ef">print</span> <span style="color:#e6db74">&#34;$combos\n&#34;</span>;
</code></pre></div><p><a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-136/jo-37/perl/ch-2.pl"><strong>Jorg Sommrey</strong></a></p>
<p>Jorg presents us a with a brace of solutions, a sophisticated mathematical analysis and a brute-force method to check it.</p>
<p>The Fibonacci sequence can be considered a special case of a more general set of sequences holding the same recurrence relations, specifically that the type-1 case of Lucas numbers,
<strong>U</strong>(1,-1) is equivalent to the Fibonacci sequence. He can then use a function from the impressive <code>Math::Prime::Util</code> library, <code>lucas_u()</code>, to produce Fibonacci numbers extremely quickly, while aggregating a count of solution sets, recursively adding another value to various partial sequences and recursively calling the function again to fill the remainder.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-perl" data-lang="perl">    <span style="color:#66d9ef">sub</span> <span style="color:#a6e22e">count_fib_seq</span> ($n, $k = 2) {
        <span style="color:#66d9ef">my</span> $count <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
        <span style="color:#66d9ef">while</span> () {
            <span style="color:#66d9ef">my</span> $fib <span style="color:#f92672">=</span> lucasu <span style="color:#ae81ff">1</span>, <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>, $k;
            <span style="color:#66d9ef">return</span> $count <span style="color:#f92672">+</span> ($fib <span style="color:#f92672">==</span> $n) <span style="color:#66d9ef">if</span> $fib <span style="color:#f92672">&gt;=</span> $n;
            $count <span style="color:#f92672">+=</span> count_fib_seq($n <span style="color:#f92672">-</span> $fib, <span style="color:#f92672">++</span>$k);
        }
    }
</code></pre></div><p>For the checking function he uses a very interesting variation of using individual set bits of a binary number as flags to select individual Fibonacci numbers from the sequence for inclusion in a given combination. This is all well and good, but here Jorg brings us the <code>todigits()</code> function from the aforementioned module to facilitate the whole breaking-apart action, where the bits are multiplied by their matching Fibonacci number and the list reduced to compute a sum.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-perl" data-lang="perl">    <span style="color:#66d9ef">sub</span> <span style="color:#a6e22e">scan_fib_seq</span> ($n) {
        <span style="color:#66d9ef">my</span> (@fib, $f) <span style="color:#f92672">=</span> (<span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">1</span>);
        push @fib, $f <span style="color:#66d9ef">while</span> ($f <span style="color:#f92672">=</span> $fib[<span style="color:#f92672">-</span><span style="color:#ae81ff">2</span>] <span style="color:#f92672">+</span> $fib[<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>]) <span style="color:#f92672">&lt;=</span> $n;
        shift @fib;

        scalar grep {
            $n <span style="color:#f92672">==</span> reduce_0 {$a <span style="color:#f92672">+=</span> $fib[$_] <span style="color:#f92672">*</span> $b} todigits($_, <span style="color:#ae81ff">2</span>, @fib)
        } <span style="color:#ae81ff">1</span> <span style="color:#f92672">..</span> <span style="color:#ae81ff">2</span> <span style="color:#f92672">**</span> @fib <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>;
    }
</code></pre></div><p><a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-136/cheok-yin-fung/perl/ch-2.pl"><strong>Cheok-Yin Fung</strong></a></p>
<p>CY brings us another formula from OEIS <a href="https://oeis.org/A000119">A000119</a>, this one <a href="http://www-igm.univ-mlv.fr/~berstel/Articles/2001ExerciceAldo.pdf">an analysis by one J. Berstel</a> on using matrices to resolve transformative substitutions of equivalent representations of the same integer value in a the Fibonacci Number System.</p>
<p>The <em>wh-what?</em> you might well say. Oh, that. Right. The Fibonacci Number System is a representational place system where the position of a digit represents not a fixed power multiple of a base, but rather the Fibonacci value at that numerical index. Which, if you think about it, albeit truly weird, is exactly what we&rsquo;re doing here: building numbers from Fibonacci numbers. The equivalence in question is that because of the Fibonacci recurrence relation, F(<em>n</em>) = F(<em>n</em>-1) + F(<em>n</em>-2), and that positional systems work ascending from right to left, in the FNS the two values 100 and 011 are the same. Thus if we represent an integer value in the system, we can enact a system of transformations on the representation to count all the ways to express it.</p>
<p>Sounds easy when you put it like that, doesn&rsquo;t it?</p>
<p>Practically it&rsquo;s a bit of a mess, which is where Berstel&rsquo;s work comes in.</p>
<p>CY&rsquo;s implementation is fast and hard to summarize; Berstel analyses the problem in terms of matrices. Examine the code and the source, it&rsquo;s kind of amazing.</p>
<p>Note <code>@FIBSEQ</code> is a large precomputed section of the Fibonacci sequence.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-perl" data-lang="perl">    say num_of_fib_repr($ARGV[<span style="color:#ae81ff">0</span>]) <span style="color:#66d9ef">if</span> defined($ARGV[<span style="color:#ae81ff">0</span>]);

    <span style="color:#66d9ef">sub</span> <span style="color:#a6e22e">num_of_fib_repr</span> {
        <span style="color:#66d9ef">my</span> $num <span style="color:#f92672">=</span> $_[<span style="color:#ae81ff">0</span>];
        <span style="color:#66d9ef">my</span> @zff <span style="color:#f92672">=</span> zeckendorff_index($num)<span style="color:#f92672">-&gt;</span>@<span style="color:#960050;background-color:#1e0010">*;</span>
        push @zff, <span style="color:#ae81ff">0</span>;
        <span style="color:#66d9ef">my</span> @arr <span style="color:#f92672">=</span> map {  $zff[$_] <span style="color:#f92672">-</span> $zff[$_<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>] <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span> } <span style="color:#ae81ff">0</span><span style="color:#f92672">..</span>$#zff<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>;
        <span style="color:#66d9ef">my</span> $matrix <span style="color:#f92672">=</span> reduce {multi_sq($a,$b)} map {mat($_)} @arr;
        <span style="color:#66d9ef">return</span> $matrix<span style="color:#f92672">-&gt;</span>[<span style="color:#ae81ff">0</span>][<span style="color:#ae81ff">0</span>] <span style="color:#f92672">+</span> $matrix<span style="color:#f92672">-&gt;</span>[<span style="color:#ae81ff">1</span>][<span style="color:#ae81ff">0</span>];
    }

    <span style="color:#66d9ef">sub</span> <span style="color:#a6e22e">mat</span> {
        <span style="color:#66d9ef">my</span> $d <span style="color:#f92672">=</span> $_[<span style="color:#ae81ff">0</span>];
        <span style="color:#66d9ef">return</span> [ [<span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">1</span>], [ int($d<span style="color:#e6db74">/2), int(($d+1)/</span><span style="color:#ae81ff">2</span>) ] ];
    }

    <span style="color:#66d9ef">sub</span> <span style="color:#a6e22e">multi_sq</span> {
        <span style="color:#66d9ef">my</span> $mat0 <span style="color:#f92672">=</span> $_[<span style="color:#ae81ff">0</span>];
        <span style="color:#66d9ef">my</span> $mat1 <span style="color:#f92672">=</span> $_[<span style="color:#ae81ff">1</span>];
        <span style="color:#66d9ef">return</span> [
          [
            $mat0<span style="color:#f92672">-&gt;</span>[<span style="color:#ae81ff">0</span>][<span style="color:#ae81ff">0</span>] <span style="color:#f92672">*</span> $mat1<span style="color:#f92672">-&gt;</span>[<span style="color:#ae81ff">0</span>][<span style="color:#ae81ff">0</span>] <span style="color:#f92672">+</span> $mat0<span style="color:#f92672">-&gt;</span>[<span style="color:#ae81ff">0</span>][<span style="color:#ae81ff">1</span>] <span style="color:#f92672">*</span> $mat1<span style="color:#f92672">-&gt;</span>[<span style="color:#ae81ff">1</span>][<span style="color:#ae81ff">0</span>],
            $mat0<span style="color:#f92672">-&gt;</span>[<span style="color:#ae81ff">0</span>][<span style="color:#ae81ff">0</span>] <span style="color:#f92672">*</span> $mat1<span style="color:#f92672">-&gt;</span>[<span style="color:#ae81ff">0</span>][<span style="color:#ae81ff">1</span>] <span style="color:#f92672">+</span> $mat0<span style="color:#f92672">-&gt;</span>[<span style="color:#ae81ff">0</span>][<span style="color:#ae81ff">1</span>] <span style="color:#f92672">*</span> $mat1<span style="color:#f92672">-&gt;</span>[<span style="color:#ae81ff">1</span>][<span style="color:#ae81ff">1</span>]
          ],
          [
            $mat0<span style="color:#f92672">-&gt;</span>[<span style="color:#ae81ff">1</span>][<span style="color:#ae81ff">0</span>] <span style="color:#f92672">*</span> $mat1<span style="color:#f92672">-&gt;</span>[<span style="color:#ae81ff">0</span>][<span style="color:#ae81ff">0</span>] <span style="color:#f92672">+</span> $mat0<span style="color:#f92672">-&gt;</span>[<span style="color:#ae81ff">1</span>][<span style="color:#ae81ff">1</span>] <span style="color:#f92672">*</span> $mat1<span style="color:#f92672">-&gt;</span>[<span style="color:#ae81ff">1</span>][<span style="color:#ae81ff">0</span>],
            $mat0<span style="color:#f92672">-&gt;</span>[<span style="color:#ae81ff">1</span>][<span style="color:#ae81ff">0</span>] <span style="color:#f92672">*</span> $mat1<span style="color:#f92672">-&gt;</span>[<span style="color:#ae81ff">0</span>][<span style="color:#ae81ff">1</span>] <span style="color:#f92672">+</span> $mat0<span style="color:#f92672">-&gt;</span>[<span style="color:#ae81ff">1</span>][<span style="color:#ae81ff">1</span>] <span style="color:#f92672">*</span> $mat1<span style="color:#f92672">-&gt;</span>[<span style="color:#ae81ff">1</span>][<span style="color:#ae81ff">1</span>]
          ]
        ]
    }

    <span style="color:#66d9ef">sub</span> <span style="color:#a6e22e">zeckendorff_index</span> {
        <span style="color:#66d9ef">my</span> $num <span style="color:#f92672">=</span> $_[<span style="color:#ae81ff">0</span>];
        <span style="color:#66d9ef">my</span> @arr <span style="color:#f92672">=</span> ();
        <span style="color:#66d9ef">my</span> $s <span style="color:#f92672">=</span> get_largest_fib_ind($num);
        <span style="color:#66d9ef">while</span> ($num <span style="color:#f92672">!=</span> <span style="color:#ae81ff">0</span>) {
            <span style="color:#66d9ef">if</span> ($num <span style="color:#f92672">&gt;=</span> $FIBSEQ[$s]) {
                $num <span style="color:#f92672">=</span> $num <span style="color:#f92672">-</span> $FIBSEQ[$s];
                push @arr, $s;
            }
            $s<span style="color:#f92672">--</span>;
        }
        <span style="color:#66d9ef">return</span> [@arr];
    }

    <span style="color:#66d9ef">sub</span> <span style="color:#a6e22e">get_largest_fib_ind</span> {
        <span style="color:#66d9ef">my</span> $num <span style="color:#f92672">=</span> $_[<span style="color:#ae81ff">0</span>];
        <span style="color:#66d9ef">my</span> $i <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>;
        <span style="color:#66d9ef">while</span> ($num <span style="color:#f92672">&gt;</span> $FIBSEQ[$i]) {
            $i<span style="color:#f92672">++</span>;
        }
        <span style="color:#66d9ef">return</span> $i;
    }
</code></pre></div><p><a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-136/e-choroba/perl/ch-2.pl"><strong>E. Choroba</strong></a></p>
<p>Choroba presents us with not one but two solutions to the task, both impressive it their way. In the first, an incrementing interator is used to produce sequential binary number strings, and the bits of these numbers are used to indicate whether a given index of a list of Fibonacci numbers is selected in a combination. Although we&rsquo;ve seen this idea before, this is a quite novel implementation.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-perl" data-lang="perl">    <span style="color:#66d9ef">my</span> @F <span style="color:#f92672">=</span> (<span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">2</span>);
    <span style="color:#66d9ef">sub</span> <span style="color:#a6e22e">fibonacci_sequence_indicator</span> {
        <span style="color:#66d9ef">my</span> ($n) <span style="color:#f92672">=</span> @_;
        <span style="color:#66d9ef">my</span> $count <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
        <span style="color:#66d9ef">my</span> $indicator <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>;
        <span style="color:#66d9ef">my</span> $bin <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>;
        <span style="color:#66d9ef">while</span> ($F[ length($bin) <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span> ] <span style="color:#f92672">&lt;=</span> $n) {
            push @F, $F[<span style="color:#f92672">-</span><span style="color:#ae81ff">2</span>] <span style="color:#f92672">+</span> $F[<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>] <span style="color:#66d9ef">if</span> @F <span style="color:#f92672">&lt;=</span> length $bin;
            <span style="color:#66d9ef">my</span> $sum <span style="color:#f92672">=</span> sum(@F[ grep substr($bin, <span style="color:#f92672">-</span>$_ <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">1</span>),
                                   <span style="color:#ae81ff">0</span> <span style="color:#f92672">..</span> length($bin) <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span> ]);

            <span style="color:#f92672">++</span>$count <span style="color:#66d9ef">if</span> $sum <span style="color:#f92672">==</span> $n;
            <span style="color:#f92672">++</span>$indicator;
            $bin <span style="color:#f92672">=</span> sprintf <span style="color:#e6db74">&#39;%b&#39;</span>, $indicator;
        }
        <span style="color:#66d9ef">return</span> $count
    }
</code></pre></div><p>In the second solution, we are presented with a unique take on the problem, using dynamic programming to build up a hash of partial solutions: starting with a kernal of the keys &ldquo;1&rdquo; and &ldquo;2&rdquo;, each key points to an array of arrays containing all Fibonacci constructions summing to that key. The dynamic part is that as new keys are constructed these arrays can be substituted for components in the breakdown of the new number instead of recomputing the combinations, so bit by bit the hash is expanded from those parts already computed. When the hash reaches the desired value we will have computed the matching combinations.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-perl" data-lang="perl">    <span style="color:#66d9ef">my</span> %fs <span style="color:#f92672">=</span> (<span style="color:#ae81ff">1</span> <span style="color:#f92672">=&gt;</span> [[<span style="color:#ae81ff">1</span>]], <span style="color:#ae81ff">2</span> <span style="color:#f92672">=&gt;</span> [[<span style="color:#ae81ff">2</span>]]);
    <span style="color:#66d9ef">sub</span> <span style="color:#a6e22e">fs_dynamic</span> {
        <span style="color:#66d9ef">my</span> ($n) <span style="color:#f92672">=</span> @_;
        <span style="color:#66d9ef">return</span> @{ $fs{$n} } <span style="color:#66d9ef">if</span> exists $fs{$n};

        push @F, $F[<span style="color:#f92672">-</span><span style="color:#ae81ff">2</span>] <span style="color:#f92672">+</span> $F[<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>] <span style="color:#66d9ef">while</span> $F[<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>] <span style="color:#f92672">&lt;</span> $n;
        <span style="color:#66d9ef">my</span> @result;
        <span style="color:#66d9ef">for</span> <span style="color:#66d9ef">my</span> $f (grep $_ <span style="color:#f92672">&lt;=</span> $n, @F) {
            <span style="color:#66d9ef">no</span> warnings <span style="color:#e6db74">&#39;recursion&#39;</span>;
            <span style="color:#66d9ef">my</span> @without <span style="color:#f92672">=</span> grep { <span style="color:#f92672">!</span> grep $_ <span style="color:#f92672">==</span> $f, @$_ } fs_dynamic($n <span style="color:#f92672">-</span> $f);
            <span style="color:#66d9ef">next</span> <span style="color:#66d9ef">if</span> @without <span style="color:#f92672">&amp;&amp;</span> $f <span style="color:#f92672">&lt;</span> $without[<span style="color:#ae81ff">0</span>][<span style="color:#ae81ff">0</span>];

            push @result, map [$f, @$_], @without;
            push @result, [$f] <span style="color:#66d9ef">if</span> $n <span style="color:#f92672">==</span> $f;
        }
        <span style="color:#66d9ef">return</span> @{ $fs{$n} <span style="color:#f92672">=</span> <span style="color:#f92672">\</span>@result }
    }
</code></pre></div><p><a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-136/adam-russell/perl/ch-2.pl"><strong>Adam Russell</strong></a></p>
<p>  <strong>additional languages:</strong>
<a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-136/adam-russell/prolog/ch-2.p">Prolog</a></p>
<p>  <strong>blog writeup:</strong>
<a href="http://www.rabbitfarm.com/cgi-bin/blosxom/2021/10/31/perl">Friendly Fibonacci Summands — Perl — RabbitFarm</a></p>
<p>  <strong>blog writeup:</strong>
<a href="http://www.rabbitfarm.com/cgi-bin/blosxom/2021/10/31/prolog">Friendly Fibonacci Summands — Prolog — RabbitFarm</a></p>
<p>In Set Theory, a <em>powerset</em> is the set of all subsets of a set. Which. practically speaking, is the set of all possible selection groups from a given set, including selecting no memebers at all. Exhaustively, considering the set of Fibonacci numbers less than a certain value, this will of course include every combination of values that sum to the target, as it includes all combinations of items. The ones we want will certainly be mixed in, and all we need do it find them.</p>
<p>The module <code>Data::PowerSet</code> provides a handy <code>powerset()</code> routine to provide this functionality. A an array of arrays is returned, and a <code>grep</code> function is used to filter for those lists that sum to the given value.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-perl" data-lang="perl">    <span style="color:#66d9ef">use</span> Data::PowerSet <span style="color:#e6db74">q/powerset/</span>;

    <span style="color:#66d9ef">sub</span> <span style="color:#a6e22e">fibonacci_sum</span>{
        <span style="color:#66d9ef">my</span>($n) <span style="color:#f92672">=</span> @_;
        <span style="color:#66d9ef">my</span> $powerset <span style="color:#f92672">=</span> powerset(fibonacci_below_n($n));
        say <span style="color:#e6db74">&#34;@$_&#34;</span> <span style="color:#66d9ef">for</span> @$powerset ;
        <span style="color:#66d9ef">my</span> @summands <span style="color:#f92672">=</span> grep {
            <span style="color:#66d9ef">my</span> $fibonaccis <span style="color:#f92672">=</span> $_;
            <span style="color:#66d9ef">my</span> $sum <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
            map{
                $sum <span style="color:#f92672">+=</span> $_;
            } @{$fibonaccis};
            $sum <span style="color:#f92672">==</span> $n;
        } @{$powerset};
        <span style="color:#66d9ef">return</span> @summands;
    }
</code></pre></div><p><a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-136/wanderdoc/perl/ch-2.pl"><strong>Wanderdoc</strong></a></p>
<p>Finally our itinerant doctor gives us a fine example of the closed-form method for constructing Fibonacci numbers from the sequence, known as Binet&rsquo;s formula. In this example they are using, when we substitute in some constants:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-perl" data-lang="perl">    int( (( ((<span style="color:#ae81ff">1</span> <span style="color:#f92672">+</span> sqrt(<span style="color:#ae81ff">5</span>)) <span style="color:#e6db74">/ 2 )** $n) /</span> sqrt(<span style="color:#ae81ff">5</span>)) <span style="color:#f92672">+</span> <span style="color:#ae81ff">0.5</span> )
</code></pre></div><p>It looks a bit of a mess here but that&rsquo;s mostly because linear text is quite lacking in the ability to express formulae. Of note, (I&rsquo;ll spell it out) one plus the square root of five over two is commonly referred to by the Greek letter phi, or φ. This is the &ldquo;golden ratio&rdquo; of lore.</p>
<p>For the practical solving portion of the solution, we have a recursive technique where we grow solutions up from seeds, adding Fibonacci values to a budding sequence fragment and applying the by-now familiar set of rules with regards to the sum: if we&rsquo;re over we&rsquo;re busted, it we match we have a winner, and if are less than the total we send the partial solution recursively around again.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-perl" data-lang="perl">    <span style="color:#66d9ef">use</span> constant {ROOT5 <span style="color:#f92672">=&gt;</span> sqrt(<span style="color:#ae81ff">5</span>)};
    <span style="color:#66d9ef">use</span> constant { GR <span style="color:#f92672">=&gt;</span> (<span style="color:#ae81ff">1</span> <span style="color:#f92672">+</span> ROOT5) <span style="color:#f92672">/</span> <span style="color:#ae81ff">2</span> };

    <span style="color:#66d9ef">sub</span> <span style="color:#a6e22e">solve</span>
    {
         <span style="color:#66d9ef">no</span> warnings <span style="color:#e6db74">&#39;recursion&#39;</span>;
         <span style="color:#66d9ef">my</span> ($solution, $remain, @arr) <span style="color:#f92672">=</span> @_;


         <span style="color:#66d9ef">if</span> ( $remain <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span> )
         {
              <span style="color:#66d9ef">my</span> $s <span style="color:#f92672">=</span> deep_copy($solution);
              push @SOLS, $s;
         }

         <span style="color:#66d9ef">for</span> <span style="color:#66d9ef">my</span> $idx ( <span style="color:#ae81ff">0</span> <span style="color:#f92672">..</span> $#arr )
         {

              <span style="color:#66d9ef">next</span> <span style="color:#66d9ef">if</span> ( $arr[$idx] <span style="color:#f92672">&gt;</span> $remain );
              <span style="color:#66d9ef">next</span> <span style="color:#66d9ef">if</span> ( $solution<span style="color:#f92672">-&gt;</span>[<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>] <span style="color:#f92672">and</span> $solution<span style="color:#f92672">-&gt;</span>[<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>] <span style="color:#f92672">==</span> $arr[$idx] );
              push @{$solution}, $arr[$idx];
              $remain <span style="color:#f92672">-=</span> $arr[$idx];
              <span style="color:#66d9ef">my</span> $next <span style="color:#f92672">=</span> $idx <span style="color:#f92672">==</span> $#arr ? $#arr : $idx <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>;
              <span style="color:#66d9ef">if</span> ( solve($solution, $remain, @arr[$next <span style="color:#f92672">..</span> $#arr] ) )
              {
                   <span style="color:#66d9ef">return</span> $solution;

              }
              $remain <span style="color:#f92672">+=</span> pop @{$solution};
         }
         <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
    }

    <span style="color:#66d9ef">sub</span> <span style="color:#a6e22e">fib</span>
    {
         <span style="color:#66d9ef">my</span> $n <span style="color:#f92672">=</span> $_[<span style="color:#ae81ff">0</span>];
         die <span style="color:#e6db74">&#34;Need a positive integer!$/&#34;</span> <span style="color:#66d9ef">unless</span> ($n <span style="color:#f92672">&gt;</span> <span style="color:#ae81ff">0</span> <span style="color:#f92672">and</span> $n <span style="color:#f92672">==</span> int($n));
         <span style="color:#66d9ef">return</span> int( ((GR <span style="color:#f92672">**</span> $n) <span style="color:#f92672">/</span> ROOT5) <span style="color:#f92672">+</span> <span style="color:#ae81ff">0.5</span> );
    }
</code></pre></div><h2 id="blogs-and-additional-submissions-in-guest-languages-for-task-2">Blogs and Additional Submissions in Guest Languages for Task 2:</h2>
<p><a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-136/athanasius/perl/ch-2.pl"><strong>Athanasius</strong></a></p>
<p>  <strong>additional languages:</strong>
<a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-136/athanasius/raku/ch-2.raku">Raku</a></p>
<p><a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-136/colin-crain/perl/ch-2.pl"><strong>Colin Crain</strong></a></p>
<p>  <strong>additional languages:</strong>
<a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-136/colin-crain/raku/ch-2.raku">Raku</a></p>
<p>  <strong>blog writeup:</strong>
<a href="https://colincrain.com/2021/10/31/dont-get-too-friendly-its-a-series-of-lies/">Don&rsquo;t Get Too Friendly — It&rsquo;s a Series of Lies - Programming Excursions in Perl and Raku</a></p>
<p><a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-136/polettix/perl/ch-2.pl"><strong>Flavio Poletti</strong></a></p>
<p>  <strong>additional languages:</strong>
<a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-136/polettix/raku/ch-2.raku">Raku</a></p>
<p>  <strong>blog writeup:</strong>
<a href="https://github.polettix.it/ETOOBUSY/2021/10/28/pwc136-fibonacci-sequence/">PWC136 - Fibonacci Sequence - ETOOBUSY</a></p>
<p><a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-136/jaldhar-h-vyas/perl/ch-2.pl"><strong>Jaldhar H. Vyas</strong></a></p>
<p>  <strong>additional languages:</strong>
<a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-136/jaldhar-h-vyas/raku/ch-2.raku">Raku</a></p>
<p>  <strong>blog writeup:</strong>
<a href="https://www.braincells.com/perl/2021/10/perl_weekly_challenge_week_136.html">Perl Weekly Challenge: Week 136</a></p>
<p><a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-136/james-smith/perl/ch-2.pl"><strong>James Smith</strong></a></p>
<p>  <strong>blog writeup:</strong>
<a href="https://github.com/drbaggy/perlweeklychallenge-club/tree/master/challenge-136/james-smith">Perl Weekly Challenge #136</a></p>
<p><a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-136/laurent-rosenfeld/perl/ch-2.pl"><strong>Laurent Rosenfeld</strong></a></p>
<p>  <strong>additional languages:</strong>
<a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-136/laurent-rosenfeld/raku/ch-2.raku">Raku</a></p>
<p>  <strong>blog writeup:</strong>
<a href="http://blogs.perl.org/users/laurent_r/2021/10/perl-weekly-challenge-136-two-friendly-and-fibonacci-sequence.html">Perl Weekly Challenge 136: Two Friendly and Fibonacci Sequence |aurent_r</a></p>
<p><a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-136/paulo-custodio/perl/ch-2.pl"><strong>Paulo Custodio</strong></a></p>
<p>  <strong>additional languages:</strong>
<a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-136/paulo-custodio/python/ch-2.py">Python</a></p>
<p><a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-136/roger-bell-west/perl/ch-2.pl"><strong>Roger Bell_West</strong></a></p>
<p>  <strong>additional languages:</strong>
<a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-136/roger-bell-west/postscript/ch-2.ps">Postscript</a>, <a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-136/roger-bell-west/python/ch-2.py">Python</a>, <a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-136/roger-bell-west/raku/ch-2.p6">Raku</a>, <a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-136/roger-bell-west/ruby/ch-2.rb">Ruby</a>, <a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-136/roger-bell-west/rust/ch-2.rs">Rust</a></p>
<p>  <strong>blog writeup:</strong>
<a href="https://blog.firedrake.org/archive/2021/10/Perl_Weekly_Challenge_136__Fibonacci_Friends.html">RogerBW&rsquo;s Blog: Perl Weekly Challenge 136: Fibonacci Friends</a></p>
<p><a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-136/sgreen/perl/ch-2.pl"><strong>Simon Green</strong></a></p>
<p>  <strong>blog writeup:</strong>
<a href="https://dev.to/simongreennet/weekly-challenge-136-12m7">Weekly Challenge 136</a></p>
<p><a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-136/ulrich-rieke/perl/ch-2.pl"><strong>Ulrich Rieke</strong></a></p>
<p>  <strong>additional languages:</strong>
<a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-136/ulrich-rieke/haskell/ch-2.hs">Haskell</a>, <a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-136/ulrich-rieke/raku/ch-2.raku">Raku</a></p>
<p><a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-136/wlmb/perl/ch-2.pl"><strong>W. Luis Mochan</strong></a></p>
<p>  <strong>blog writeup:</strong>
<a href="https://wlmb.github.io/2021/10/25/PWC136/">Perl Weekly Challenge 136 – W. Luis Mochán</a></p>
<hr>
<h1 id="PWC136BLOGS">BLOGS</h1>
<hr>
<p><strong>That’s it for me this week, people! Warped by the rain, driven by the snow, resolute and unbroken by the torrential influx, by some miracle I somehow continue to maintain my bearings.</strong></p>
<p><strong>Looking forward to next wave, the perfect wave, I am: <em>your humble servant</em>.</strong></p>
<h1 id="PWC136BLOGS">But if Your Unquenchable <em>THIRST</em> for <em>KNOWLEDGE</em> is not <em>SLAKED</em>,</h1>
<h1 id="then-run-dont-walk-to-the-watering-hole">then <em>RUN</em> <em>(dont walk!)</em> to the <em>WATERING HOLE</em></h1>
<h1 id="and-follow-these-blog-links">and <em>FOLLOW</em> these <em>BLOG</em> <em>LINKS</em>:</h1>
<p><strong>( &hellip;<em>don&rsquo;t think, trust your training, you&rsquo;re in the zone, just do it &hellip;</em> )</strong></p>
<p><strong>Abigail</strong></p>
<ul>
<li><a href="https://abigail.github.io/HTML/Perl-Weekly-Challenge/week-136-1.html">Perl Weekly Challenge 136: Two Friendly</a> ( <em>Perl</em> )</li>
<li><a href="https://abigail.github.io/HTML/Perl-Weekly-Challenge/week-136-2.html">Perl Weekly Challenge 136: Fibonacci Sequence</a> ( <em>Perl</em> )</li>
</ul>
<p><strong>Adam Russell</strong></p>
<ul>
<li><a href="http://www.rabbitfarm.com/cgi-bin/blosxom/2021/10/31/perl">Friendly Fibonacci Summands — Perl — RabbitFarm</a> ( <em>Perl</em> )</li>
<li><a href="http://www.rabbitfarm.com/cgi-bin/blosxom/2021/10/31/prolog">Friendly Fibonacci Summands — Prolog — RabbitFarm</a> ( <em>Prolog</em> )</li>
</ul>
<p><strong>Arne Sommer</strong></p>
<ul>
<li><a href="https://raku-musings.com/friendly-fibonacci.html">Friendly Fibonacci with Raku and Perl</a> ( <em>Perl &amp; Raku</em> )</li>
</ul>
<p><strong>Colin Crain</strong></p>
<ul>
<li><a href="https://colincrain.com/2021/10/31/dont-get-too-friendly-its-a-series-of-lies/">Don&rsquo;t Get Too Friendly — It&rsquo;s a Series of Lies - Programming Excursions in Perl and Raku</a> ( <em>Perl &amp; Raku</em> )</li>
</ul>
<p><strong>Dave Jacoby</strong></p>
<ul>
<li><a href="https://jacoby.github.io/2021/10/25/the-sequential-friendly-book-the-weekly-challenge-136.html">The Sequential Friendly Book: The Weekly Challenge #136 | Committed to Memory</a> ( <em>Perl</em> )</li>
</ul>
<p><strong>Flavio Poletti</strong></p>
<ul>
<li><a href="https://github.polettix.it/ETOOBUSY/2021/10/27/pwc136-two-friendly/">PWC136 - Two Friendly - ETOOBUSY</a> ( <em>Perl &amp; Raku</em> )</li>
<li><a href="https://github.polettix.it/ETOOBUSY/2021/10/28/pwc136-fibonacci-sequence/">PWC136 - Fibonacci Sequence - ETOOBUSY</a> ( <em>Perl &amp; Raku</em> )</li>
</ul>
<p><strong>Jaldhar H. Vyas</strong></p>
<ul>
<li><a href="https://www.braincells.com/perl/2021/10/perl_weekly_challenge_week_136.html">Perl Weekly Challenge: Week 136</a> ( <em>Perl &amp; Raku</em> )</li>
</ul>
<p><strong>James Smith</strong></p>
<ul>
<li><a href="https://github.com/drbaggy/perlweeklychallenge-club/tree/master/challenge-136/james-smith">Perl Weekly Challenge #136</a> ( <em>Perl</em> )</li>
</ul>
<p><strong>Laurent Rosenfeld</strong></p>
<ul>
<li><a href="http://blogs.perl.org/users/laurent_r/2021/10/perl-weekly-challenge-136-two-friendly-and-fibonacci-sequence.html">Perl Weekly Challenge 136: Two Friendly and Fibonacci Sequence |aurent_r</a> ( <em>Perl &amp; Raku</em> )</li>
</ul>
<p><strong>Luca Ferrari</strong></p>
<ul>
<li><a href="https://fluca1978.github.io/2021/10/25/PerlWeeklyChallenge136.html#task1">Perl Weekly Challenge 136: not too hard – Luca Ferrari – Open Source advocate, humaneing</a> ( <em>Raku</em> )</li>
<li><a href="https://fluca1978.github.io/2021/10/29/PerlWeeklyChallenge136PostgreSQL.html#task1">Perl Weekly Challenge 136: PostgreSQL Solutions – Luca Ferrari – Open Source advocate, humaneing</a> ( <em>PostgreSQL</em> )</li>
</ul>
<p><strong>Roger Bell_West</strong></p>
<ul>
<li><a href="https://blog.firedrake.org/archive/2021/10/Perl_Weekly_Challenge_136__Fibonacci_Friends.html">RogerBW&rsquo;s Blog: Perl Weekly Challenge 136: Fibonacci Friends</a> ( <em>Perl &amp; Raku</em> )</li>
</ul>
<p><strong>Simon Green</strong></p>
<ul>
<li><a href="https://dev.to/simongreennet/weekly-challenge-136-12m7">Weekly Challenge 136</a> ( <em>Perl</em> )</li>
</ul>
<p><strong>W. Luis Mochan</strong></p>
<ul>
<li><a href="https://wlmb.github.io/2021/10/25/PWC136/">Perl Weekly Challenge 136 – W. Luis Mochán</a> ( <em>Perl</em> )</li>
</ul>

                </div>
            </div>
        </div>
    </div>
</section>


<!-- Call To Action Section Start -->
<section id="call-to-action">
    <div class="container">
        <div class="row">
            <div class="col-md-12">
                <div class="block">
                    <h2 class="title wow fadeInDown" data-wow-delay=".3s" data-wow-duration="500ms">SO WHAT DO YOU THINK ?</h2>
                    <p class="wow fadeInDown" data-wow-delay=".5s" data-wow-duration="500ms">If you have any suggestions or ideas then please do share with us.</p>
                    <a href="/contact" class="btn btn-default btn-contact wow fadeInDown" data-wow-delay=".7s" data-wow-duration="500ms">Contact with me</a>
                </div>
            </div>

        </div>
    </div>
</section>
<!-- Call To Action Section End -->



<!-- Footer Section Start -->
<footer id="footer">
    <div class="container">
        <div class="row content-justify-between">
            <div class="col-md-8 col-12 text-center text-lg-left text-md-left">
                <p class="copyright">Copyright:
                    <span>
                        2019 - 2021
                    </span> The Weekly Challenge. Theme Design and Developed by
                    <a href="http://www.Themefisher.com" rel="noreferrer" rel="noreferrer" target="_blank">Themefisher</a>.
                </p>
            </div>
            <div class="col-md-4 col-12">
                <!-- Social Media -->
                <ul class="social text-center text-md-right text-lg-right">
                    <li>
                        <a href="https://twitter.com/PerlWChallenge" class="twitter" rel="noreferrer" target="_blank" title="Follow us">
                            <i class="ion-social-twitter"></i>
                        </a>
                    </li>
                    <li>
                        <a href="/rss.xml" class="rss" target="_blank" title="RSS Feed">
                            <i class="ion-social-rss"></i>
                        </a>
                    </li>
                    <li>
                        <a href="https://www.nomtimes.co.uk/site/shop.do?cref=PerlBooks" title="Free Perl Books" rel="noreferrer" target="_blank">
                            <img src="/images/NomTimes.jpg" style="width:22px; height: 18px;" alt=""/>
                        </a>
                    </li>
                </ul>
            </div>
        </div>
    </div>
</footer>
<!-- footer section end -->

<!-- jquery -->
<script src="https://theweeklychallenge.org/plugins/jQurey/jquery.min.js"></script>
<!-- Form Validation -->
<script src="https://theweeklychallenge.org/plugins/form-validation/jquery.form.min.js"></script>
<script src="https://theweeklychallenge.org/plugins/form-validation/jquery.validate.min.js"></script>
<!-- slick slider -->
<script src="https://theweeklychallenge.org/plugins/slick/slick.min.js"></script>
<!-- bootstrap js -->
<script src="https://theweeklychallenge.org/plugins/bootstrap/bootstrap.min.js"></script>
<!-- chart js -->
<script src="https://theweeklychallenge.org/plugins/chart/highstock.js"></script>
<script src="https://theweeklychallenge.org/plugins/chart/drilldown.js"></script>
<script src="https://theweeklychallenge.org/plugins/chart/data.js"></script>
<script src="https://theweeklychallenge.org/plugins/chart/chart.js"></script>
<script src="https://theweeklychallenge.org/plugins/chart/pwc-challenge.js"></script>
<script src="https://theweeklychallenge.org/plugins/chart/gc-challenge.js"></script>
<!-- wow js -->
<script src="https://theweeklychallenge.org/plugins/wow-js/wow.min.js"></script>
<!-- slider js -->
<script src="https://theweeklychallenge.org/plugins/slider/slider.js"></script>
<!-- Fancybox -->
<script src="https://theweeklychallenge.org/plugins/facncybox/jquery.fancybox.js"></script>
<!-- template main js -->

<script src="https://theweeklychallenge.org/js/script.min.js"></script>
<!-- google analitycs -->
<script>
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
    (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
    m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
    ga('create', 'UA-136524905-1', 'auto');
    ga('send', 'pageview');
</script>
</body>

</html>

