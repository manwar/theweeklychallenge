<!DOCTYPE html>
<html class="no-js" lang="en-us">
<head>
    <!-- Basic Page Needs -->

    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta property="og:title"       content="The Weekly Challenge - Perl & Raku"/>
    <meta property="og:type"        content="website"/>
    <meta property="og:url"         content="https://perlweeklychallenge.org/"/>
    <meta property="og:image"       content="https://perlweeklychallenge.org/images/about/about.jpg"/>
    <meta property="og:description" content="You do not have to be an expert."/>
    <meta name="twitter:card"       content="summary" />
    <meta name="twitter:image"      content="https://perlweeklychallenge.org/images/about/about.jpg"/>

    <meta http-equiv="Content-Type" content="text/html; charset=utf-8">

    <meta name="description" content="Laurent Rosenfeld Weekly Review: Challenge - #015.">
    <meta name="author" content="The Weekly Challenge Team">
    <meta name="generator" content="Hugo 0.67.0-DEV" />

    <!-- Mobile Specific Metas -->
    <meta name="format-detection" content="telephone=no">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>Laurent Rosenfeld Weekly Review: Challenge - 015</title>
    <link rel="icon" href="https://perlweeklychallenge.org/images/favicon.ico">

    
    <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.0/css/bootstrap.min.css"/>

    <!-- Twitter Bootstrs CSS -->
    <link rel="stylesheet" href="https://perlweeklychallenge.org/plugins/bootstrap/bootstrap.min.css">
    <!-- Ionicons Fonts Css -->
    <link rel="stylesheet" href="https://perlweeklychallenge.org/plugins/ionicons/ionicons.min.css">
    <!-- animate css -->
    <link rel="stylesheet" href="https://perlweeklychallenge.org/plugins/animate-css/animate.css">
    <!-- Hero area slider css-->
    <link rel="stylesheet" href="https://perlweeklychallenge.org/plugins/slider/slider.css">
    <!-- slick slider -->
    <link rel="stylesheet" href="https://perlweeklychallenge.org/plugins/slick/slick.css">
    <!-- Fancybox -->
    <link rel="stylesheet" href="https://perlweeklychallenge.org/plugins/facncybox/jquery.fancybox.css">
    <!-- hover -->
    <link rel="stylesheet" href="https://perlweeklychallenge.org/plugins/hover/hover-min.css">
    <!-- Google fonts -->
    <link href='https://fonts.googleapis.com/css?family=Source Code Pro' rel='stylesheet'>
    <!-- template main css file -->
    
    <link rel="stylesheet" href="https://perlweeklychallenge.org/css/style.min.css" integrity="" media="screen">
    <link rel="stylesheet" href="https://perlweeklychallenge.org/css/main.css">

    <style>
        #goTopButton {
            display: none;          
            position: fixed;        
            bottom: 20px;           
            right: 30px;            
            z-index: 99;            
            border: none;           
            outline: none;          
            background-color: red;  
            color: white;           
            cursor: pointer;        
            padding: 15px;          
            border-radius: 10px;    
            font-size: 18px;        
        }

        #goTopButton:hover {
              background-color: #555;
        }
    </style>


</head>

<body>

<button onclick="goTop()" id="goTopButton" title="Go to top">Top</button>

<script>

    topButton = document.getElementById("goTopButton");

    
    window.onscroll = function() { scrollFunction() };

    function scrollFunction() {
        if (document.body.scrollTop > 40 || document.documentElement.scrollTop > 40) {
            topButton.style.display = "block";
        } else {
            topButton.style.display = "none";
        }
    }

    
    function goTop() {
        document.body.scrollTop = 0; 
        document.documentElement.scrollTop = 0; 
    }

</script>

<section class="top-bar animated-header">
    <div class="container">
        <div class="row">
            <div class="col-lg-12">
                <nav class="navbar navbar-expand-lg navbar-light bg-light">
                    <a class="navbar-brand" href="https://perlweeklychallenge.org/">
                        <img src="https://perlweeklychallenge.org/images/logo.svg" alt="logo">
                    </a>
                    <button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navgation" aria-controls="navigation"
                        aria-expanded="false" aria-label="Toggle navigation">
                        <span class="navbar-toggler-icon"></span>
                    </button>

                    <div class="collapse navbar-collapse" id="navigation">
                        <ul class="navbar-nav ml-auto">
                            <li class="nav-item">
                                <a class="nav-link" href="https://perlweeklychallenge.org/">Home</a>
                            </li>
                            
                            <li class="nav-item">
                                <a class="nav-link" href="https://perlweeklychallenge.org/about">About</a>
                            </li>
                            
                            <li class="nav-item">
                                <a class="nav-link" href="https://perlweeklychallenge.org/chart">Chart</a>
                            </li>
                            
                            <li class="nav-item">
                                <a class="nav-link" href="https://perlweeklychallenge.org/champions">Champions</a>
                            </li>
                            
                            <li class="nav-item">
                                <a class="nav-link" href="https://perlweeklychallenge.org/team">Team</a>
                            </li>
                            
                            <li class="nav-item">
                                <a class="nav-link" href="https://perlweeklychallenge.org/challenges">Challenges</a>
                            </li>
                            
                            <li class="nav-item">
                                <a class="nav-link" href="https://perlweeklychallenge.org/p5-reviews">Perl/Review</a>
                            </li>
                            
                            <li class="nav-item">
                                <a class="nav-link" href="https://perlweeklychallenge.org/p6-reviews">Raku/Review</a>
                            </li>
                            
                            <li class="nav-item">
                                <a class="nav-link" href="https://perlweeklychallenge.org/recaps">Recaps</a>
                            </li>
                            
                            <li class="nav-item">
                                <a class="nav-link" href="https://perlweeklychallenge.org/blogs">Blogs</a>
                            </li>
                            
                            <li class="nav-item">
                                <a class="nav-link" href="https://perlweeklychallenge.org/faq">FAQ</a>
                            </li>
                            
                            <li class="nav-item">
                                <a class="nav-link" href="https://perlweeklychallenge.org/contact">Contact</a>
                            </li>
                            
                        </ul>
                    </div>
                </nav>
            </div>
        </div>
    </div>
</section>


<section class="global-page-header">
    <div class="container">
        <div class="row">
            <div class="col-md-12">
                <div class="block">
                    <h2>Laurent Rosenfeld Weekly Review: Challenge - 015</h2>
                    <div class="portfolio-meta">
                        <span>Wednesday, Oct 9, 2019</span>|
                        <span> Tags:
                            Raku
                        </span>
                    </div>
                </div>
            </div>
        </div>
    </div>
</section>

<section class="single-post">
    <div class="container">
        <div class="row">
            <div class="col-md-12">
                
                <div style="text-align: center" class="post-img">
                    <img class="img-fluid" alt="" src="https://perlweeklychallenge.org/images/blog/p6-review-challenge-015.jpg">
                </div>
                
                <div style="text-align: justify" class="post-content">
                    <hr>
<h1 id="raku-solutions-weekly-review">Raku Solutions Weekly Review</h1>
<hr>
<h2 id="task-1-vigenère-cipher">Task #1: Vigenère Cipher</h2>
<p>This is derived in part from my <a href="http://blogs.perl.org/users/laurent_r/2019/07/perl-weekly-challenge-15-strong-and-weak-primes-and-vigenere-encryption.html">blog post</a> made in answer to the <a href="https://perlweeklychallenge.org/blog/perl-weekly-challenge-015/">Week 15 of the Perl Weekly Challenge</a> organized by  <a href="http://blogs.perl.org/users/mohammad_s_anwar/">Mohammad S. Anwar</a> as well as answers made by others to the same challenge.</p>
<p>The challenge reads as follows:</p>
<p><em>Write a script to implement Vigenère cipher. The script should be able encode and decode. Checkout <a href="https://en.wikipedia.org/wiki/Vigen%C3%A8re_cipher">wiki page</a> for more information.</em></p>
<p>The Vigenère cipher is actually a misnomer: in the nineteenth century, it has been mis-attributed to French diplomat and cryptographer Blaise de Vigenère, who published the method in 1586, and this is how it acquired its present name. But the method usually associated with Vigenère&rsquo;s name had been described more than three decades earlier (in 1553) by Italian cryptanalyst Giovan Battista Bellaso. It essentially resisted all attempts to break it until 1863, three centuries later. This being said, Vigenère is certainly a great figure in the history of cryptography, since he invented a very significant enhancement of that method that is not usually associated with Vigenère&rsquo;s name, but is usually named <a href="https://en.wikipedia.org/wiki/Autokey_cipher">autokey cypher</a>, but that&rsquo;s another story.</p>
<p>To understand the Vigenère cipher, we can first consider what is known as the <em>Caesar cipher</em>, in which each letter of the alphabet is shifted along some number of places. For example, in a Caesar cipher of shift 3, A would become D, B would become E, Y would become B and so on. So, for instance, &ldquo;cheer&rdquo; rotated by 7 places is &ldquo;jolly&rdquo; and &ldquo;melon&rdquo; rotated by -10 (or + 16) is &ldquo;cubed&rdquo;. In the movie <em>A Space Odyssey</em>, the ship&rsquo;s computer is called HAL, which is IBM rotated by -1. One famous such cipher is <em>ROT13</em>, which is a Caesar cipher with rotation 13. Since 13 is half the number of letters in our alphabet, applying rotation 13 twice returns the original message, so that the same routine can be used for both encoding and decoding in rotation 13. Rotation 13 has been used very commonly on the Internet to hide potentially offensive jokes or to weakly hide the solution to a puzzle.</p>
<p>A Caesar cipher is very easy to break through letter frequency analysis.</p>
<p>In Edgar Allan Poe’s short story <em>The Gold Bug</em>, one of the characters, William Legrand, uses letter frequencies to crack a cipher. He explains:</p>
<blockquote>
<p>Now, in English, the letter which most frequently occurs is e. Afterwards, the succession runs thus: a o i d h n r s t u y c f g l m w b k p q x z. E however predominates so remarkably that an individual sentence of any length is rarely seen, in which it is not the prevailing character.</p>
</blockquote>
<p>Edgar Poe&rsquo;s character is slightly wrong on part of the succession of letters: for example, he grossly underestimated the frequency of letter t, which is the second most common letter in English. But what he says about letter E is correct.</p>
<p>So, if you want to decipher a message encoded with a Caesar cipher in English, one way is to find out the most common letter in the encoded text, and that most common letter is likely to be an E. From there, you can figure out by which value each letter has shifted and decipher the whole message. If you were unlucky, just give a try with the second most common letter, and then the third. You&rsquo;re very likely to quickly succeed. Another possibility is brute force attack by trying all 26 possible values by which the letter are shifted. This is easy by hand, and very fast with a computer. A Caesar cipher is a very weak encryption system.</p>
<p>The idea of the Vigenère cipher is to shift each of the letters of the message by a different number of places. For example, if your encryption code is 1452, you rotate the first letter by one place, the second one by 4 places, the third by 5 places, the fourth by 2 places; if you have more letters to encode in your message, then your start again with the beginning of the code, and so on. For example, if you want to encode the word &ldquo;peace,&rdquo; you get:</p>
<pre><code>p + 1 =&gt; q
e + 4 =&gt; i
a + 5 =&gt; f
c + 2 =&gt; e
e + 1 =&gt; f
Encoded message: qifef.
</code></pre>
<p>In brief, a Vigenère cipher is using a series of interwoven Caesar ciphers. With such a system, frequency analysis becomes extremely difficult because, as we can see in the example above, the letter E is encoded into I in the first instance, and into F in the second instance. In fact, if the encryption key is a series of truly random bytes and is at least as long as the message to be encoded (and is thus used only once), the code is essentially unbreakable. In practice, a Vigenère cipher is usually not using a number as encryption key, but generally a password or a pass-phrase: the letters of the password are converted to a series of numbers according to their rank in the alphabet and those numbers are used as above to rotate the letters of the message to be encoded. Since the encryption code is no longer truly random, it becomes theoretically possible to break the code, but this is still very difficult, and that&rsquo;s the reason the Vigenère cipher has been considered unbreakable for about three centuries.</p>
<h2 id="my-solution">My Solution</h2>
<p>For this challenge, we will use the built-in functions <code>ord</code>, which converts a character to a numeric code (Unicode code point), and <code>chr</code> which converts such numeric code back to a characters. Letters of the alphabet are encoded in alphabetic order, so that, for example, testing under the Perl 6 REPL:</p>
<pre><code>&gt; say ord('c') - ord('a');
2
</code></pre>
<p>because &lsquo;c&rsquo; is the second letter after &lsquo;a&rsquo;.</p>
<p>Originally, I kept letters within the <code>a..z</code> range (folding the input message to lowercase), because the numeric codes for uppercase letters are different, in order to keep as close as possible to the original Vigenère cipher. But the original cipher was limited to this range only because of the way encoding was done manually at the time. With a computer, there is no reason to limit ourselves to such range. So, the script below use the full range of an octet (0..255), i.e. the full extended ASCII range. This way we can also encode spaces, punctuation symbols, etc. Of course, this implies that the partner uses the same alphabet and scheme.</p>
<p>In this script, the bulk of the work is done in the <code>rotate-msg</code> and <code>rotate-one-letter</code> subroutines. The <code>encode</code> and <code>decode</code> subroutines are only calling them with the proper arguments. And the <code>create-code</code> subroutine is used to transform the password into an array of numeric values.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-Perl6" data-lang="Perl6"><span style="color:#66d9ef">use</span> v6;

subset Letter of Str where <span style="color:#f92672">.</span>chars <span style="color:#f92672">==</span> <span style="color:#ae81ff">1</span>;

<span style="color:#66d9ef">sub</span> <span style="color:#a6e22e">create</span>-code (Str $passwd) {
    <span style="color:#75715e"># Converts password to a list of numeric codes</span>
    <span style="color:#75715e"># where &#39;a&#39; corresponds to a shift of 1, etc.</span>
    <span style="color:#66d9ef">return</span> $passwd<span style="color:#f92672">.</span>comb(<span style="color:#ae81ff">1</span>)<span style="color:#f92672">.</span>map: {<span style="color:#f92672">.</span>ord <span style="color:#f92672">-</span> <span style="color:#e6db74">&#39;a&#39;</span><span style="color:#f92672">.</span>ord <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>}
}
<span style="color:#66d9ef">sub</span> <span style="color:#a6e22e">rotate</span>-one-letter (Letter $letter, Int $shift) {
    <span style="color:#75715e"># Converts a single letter and deals with cases</span>
    <span style="color:#75715e"># where applying the shift would get out of range</span>
    constant $max <span style="color:#f92672">=</span> <span style="color:#ae81ff">255</span>;
    <span style="color:#66d9ef">my</span> $shifted <span style="color:#f92672">=</span> $letter<span style="color:#f92672">.</span>ord <span style="color:#f92672">+</span> $shift;
    $shifted <span style="color:#f92672">=</span> $shifted <span style="color:#f92672">&gt;</span> $max ?? $shifted <span style="color:#f92672">-</span> $max <span style="color:#f92672">!!</span>
        $shifted <span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">0</span> ?? $shifted <span style="color:#f92672">+</span> $max <span style="color:#f92672">!!</span>
        $shifted;
    <span style="color:#66d9ef">return</span> $shifted<span style="color:#f92672">.</span>chr;
}
<span style="color:#66d9ef">sub</span> <span style="color:#a6e22e">rotate</span>-msg (Str $msg, @code) {
    <span style="color:#75715e"># calls rotate-one-letter for each letter of the input message</span>
    <span style="color:#75715e"># and passes the right shift value for that letter</span>
    <span style="color:#66d9ef">my</span> $i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
    <span style="color:#66d9ef">my</span> $result <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;&#34;</span>;
    <span style="color:#66d9ef">for</span> $msg<span style="color:#f92672">.</span>comb(<span style="color:#ae81ff">1</span>) <span style="color:#f92672">-&gt;</span> $letter {
        <span style="color:#66d9ef">my</span> $shift <span style="color:#f92672">=</span> @code[$i];
        $result <span style="color:#f92672">~=</span> rotate<span style="color:#f92672">-</span>one<span style="color:#f92672">-</span>letter $letter, $shift;
        $i<span style="color:#f92672">++</span>;
        $i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span> <span style="color:#66d9ef">if</span> $i <span style="color:#f92672">&gt;=</span> @code<span style="color:#f92672">.</span>elems;
    }
    <span style="color:#66d9ef">return</span> $result;
}
<span style="color:#66d9ef">sub</span> <span style="color:#a6e22e">encode</span> (Str $message, @key) {
    rotate<span style="color:#f92672">-</span>msg $message, @key;
}
<span style="color:#66d9ef">sub</span> <span style="color:#a6e22e">decode</span> (Str $message, @key) {
    <span style="color:#66d9ef">my</span> @back<span style="color:#f92672">-</span>key <span style="color:#f92672">=</span> map {<span style="color:#f92672">-</span> $_}, @key;
    rotate<span style="color:#f92672">-</span>msg $message, @back<span style="color:#f92672">-</span>key;
}
multi MAIN (Str $message, Str $password) {
    <span style="color:#66d9ef">my</span> @code <span style="color:#f92672">=</span> create<span style="color:#f92672">-</span>code $password;
    <span style="color:#66d9ef">my</span> $ciphertext <span style="color:#f92672">=</span> encode $message, @code;
    say <span style="color:#e6db74">&#34;Encoded cyphertext: $ciphertext&#34;</span>;
    say <span style="color:#e6db74">&#34;Roundtrip to decoded message: {decode $ciphertext, @code}&#34;</span>;
}
multi MAIN (<span style="color:#e6db74">&#34;test&#34;</span>) {
    <span style="color:#66d9ef">use</span> Test; <span style="color:#75715e"># Minimal tests for providing an example</span>
    plan <span style="color:#ae81ff">6</span>;
    <span style="color:#66d9ef">my</span> $code <span style="color:#f92672">=</span> join <span style="color:#e6db74">&#34;&#34;</span>, create<span style="color:#f92672">-</span>code(<span style="color:#e6db74">&#34;abcde&#34;</span>);
    is $code, <span style="color:#ae81ff">12345</span>, <span style="color:#e6db74">&#34;Testing create-code&#34;</span>;
    <span style="color:#66d9ef">my</span> @c <span style="color:#f92672">=</span> create<span style="color:#f92672">-</span>code <span style="color:#e6db74">&#34;password&#34;</span>;
    <span style="color:#66d9ef">for</span> <span style="color:#f92672">&lt;</span>foo bar hello world<span style="color:#f92672">&gt;</span> <span style="color:#f92672">-&gt;</span> $word {
        is decode( encode($word, @c), @c), $word,
            <span style="color:#e6db74">&#34;Round trip for $word&#34;</span>;
    }
    <span style="color:#66d9ef">my</span> $msg <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;One small step for man, one giant leap for mankind!&#34;</span>;
    <span style="color:#66d9ef">my</span> $ciphertext <span style="color:#f92672">=</span> encode $msg, @c;
    is decode($ciphertext, @c), $msg,
        <span style="color:#e6db74">&#34;Message with spaces and punctuation&#34;</span>;
}
</code></pre></div><p>In the script above, we have two MAIN multi subroutines. When the single argument is &ldquo;test&rdquo;, the script runs a series of basic tests (which would probably have to be expanded in a real life project); when the arguments are two strings (a message to be encoded and a password), the script runs with the input arguments.</p>
<p>This is an example run with the &ldquo;test&rdquo; argument:</p>
<pre><code>$ perl6  vigenere.p6 test
1..6
ok 1 - Testing create-code
ok 2 - Round trip for foo
ok 3 - Round trip for bar
ok 4 - Round trip for hello
ok 5 - Round trip for world
ok 6 - Message with spaces and punctuation
</code></pre>
<p>and with two arguments:</p>
<pre><code>$ perl6  vigenere.p6 AlphaBeta password
Encoded cyphertext: Qm┬â{xQwxq
Roundtrip to decoded message: AlphaBeta
</code></pre>
<p>In the <a href="https://en.wikipedia.org/wiki/Autokey_cipher">autokey cypher</a> improvement of the Vigenère cypher mentioned at the beginning of this post (which is the true invention made by Vigenère), the key is not repeated, but used only once, and the rest of the message is encoded using the message itself as the key. The fact that the key is no longer repeated in the coding process defeats most of the first known methods to break the traditional Vigenère cypher.</p>
<h2 id="alternate-solutions">Alternate Solutions</h2>
<p><a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-015/arne-sommer/perl6/ch-2.p6">Arne Sommer</a> made a very simple and very concise implementation of the cypher dealing only with uppercase letters (as in Vigenère&rsquo;s original cypher). His program loops on the input string&rsquo;s numerical codes and at the same time on the key&rsquo;s numerical codes. It adds the key&rsquo;s codes when encrypting and subtract them when decrypting.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-Perl6" data-lang="Perl6">subset UCASE of Str where <span style="color:#f92672">*</span> <span style="color:#f92672">~~</span> <span style="color:#e6db74">/^&lt;[A .. Z]&gt;+$/</span>;

unit <span style="color:#66d9ef">sub</span> <span style="color:#a6e22e">MAIN</span> (UCASE $uppercase-string, UCASE $key, :$decrypt = False);

my $base = &#34;A&#34;.ord;
my $key-length = $key.chars;

my @string = $uppercase-string.comb.map({ $_<span style="color:#f92672">.</span>ord <span style="color:#f92672">-</span> $base });
<span style="color:#66d9ef">my</span> @key    <span style="color:#f92672">=</span> $key<span style="color:#f92672">.</span>comb<span style="color:#f92672">.</span>map({ $_<span style="color:#f92672">.</span>ord <span style="color:#f92672">-</span> $base });

<span style="color:#66d9ef">for</span> <span style="color:#f92672">^</span>@string<span style="color:#f92672">.</span>elems <span style="color:#f92672">-&gt;</span> $p
{
  <span style="color:#66d9ef">my</span> $k <span style="color:#f92672">=</span> $p mod $key<span style="color:#f92672">-</span>length;

  $decrypt
    ?? <span style="color:#66d9ef">print</span> ($base <span style="color:#f92672">+</span> (@string[$p] <span style="color:#f92672">-</span> @key[$k] <span style="color:#f92672">+</span> <span style="color:#ae81ff">26</span>) mod <span style="color:#ae81ff">26</span>)<span style="color:#f92672">.</span>chr
    <span style="color:#f92672">!!</span> <span style="color:#66d9ef">print</span> ($base <span style="color:#f92672">+</span> (@string[$p] <span style="color:#f92672">+</span> @key[$k]) mod <span style="color:#ae81ff">26</span>)<span style="color:#f92672">.</span>chr;
}
</code></pre></div><p><a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-015/fjwhittle/perl6/ch-2.p6">Francis J. Whittle</a> first wrote an <code>ordinate</code> helper subroutine to transform the password or the message into a list of numeric codes. Once this is done, encoding a message boils down to:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-Perl6" data-lang="Perl6">put ordinate($message)<span style="color:#f92672">.</span>rotor(@key<span style="color:#f92672">.</span>elems, :partial)<span style="color:#f92672">.</span>map({ (($_ Z<span style="color:#f92672">+</span> @key) X% 26) X<span style="color:#f92672">+</span> <span style="color:#e6db74">&#39;A&#39;</span><span style="color:#f92672">.</span>ord})<span style="color:#960050;background-color:#1e0010">»</span><span style="color:#f92672">.</span>Slip<span style="color:#960050;background-color:#1e0010">»</span><span style="color:#f92672">.</span>chr<span style="color:#f92672">.</span>join
</code></pre></div><p>and decoding an encrypted message to:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-Perl6" data-lang="Perl6">put ordinate($message)<span style="color:#f92672">.</span>rotor(@key<span style="color:#f92672">.</span>elems, :partial)<span style="color:#f92672">.</span>map({ (($_ Z<span style="color:#f92672">-</span> @key) X% 26) X<span style="color:#f92672">+</span> <span style="color:#e6db74">&#39;A&#39;</span><span style="color:#f92672">.</span>ord})<span style="color:#960050;background-color:#1e0010">»</span><span style="color:#f92672">.</span>Slip<span style="color:#960050;background-color:#1e0010">»</span><span style="color:#f92672">.</span>chr<span style="color:#f92672">.</span>join
</code></pre></div><p>Wow, that&rsquo;s quite impressive! And also a little bit cryptic: it took me quite a few minutes to understand these code lines.</p>
<p><a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-015/kevin-colyer/perl6/ch-2.p6">Kevin Colyer</a> also limited the input text and the key to uppercase letters, and his program also loops on the input string&rsquo;s numeric codes and at the same time on the key&rsquo;s numerical codes. It multiplies the key numerical codes by -1 when decrypting. His central subroutine is also fairly simple and looks as follows:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-Perl6" data-lang="Perl6"><span style="color:#66d9ef">sub</span> <span style="color:#a6e22e">VigenereCipher</span>($text,$key,$encode) {
    <span style="color:#66d9ef">my</span> $offset<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;A&#34;</span><span style="color:#f92672">.</span>ord;
    <span style="color:#66d9ef">my</span> @t <span style="color:#f92672">=</span> $text<span style="color:#f92672">.</span>uc<span style="color:#f92672">.</span>comb<span style="color:#f92672">.</span>map(<span style="color:#f92672">*.</span>ord<span style="color:#f92672">-</span>$offset);
    <span style="color:#66d9ef">my</span> @k <span style="color:#f92672">=</span> $key <span style="color:#f92672">.</span>uc<span style="color:#f92672">.</span>comb<span style="color:#f92672">.</span>map(<span style="color:#f92672">*.</span>ord<span style="color:#f92672">-</span>$offset);
    <span style="color:#66d9ef">my</span> @result;
    <span style="color:#66d9ef">my</span> $EorD <span style="color:#f92672">=</span> $encode<span style="color:#f92672">==</span>True ?? <span style="color:#ae81ff">1</span> <span style="color:#f92672">!!</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>;

    <span style="color:#66d9ef">my</span> $i<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>;

    <span style="color:#66d9ef">for</span> <span style="color:#f92672">^</span>@t <span style="color:#f92672">-&gt;</span> $j {
        @result<span style="color:#f92672">.</span>push: chr($offset <span style="color:#f92672">+</span> ( (@t[$j]<span style="color:#f92672">+</span> $EorD<span style="color:#f92672">*</span>@k[$i]) mod <span style="color:#ae81ff">26</span>) );
        $i<span style="color:#f92672">=</span>($i<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>) mod @k<span style="color:#f92672">.</span>elems;

    }
    <span style="color:#66d9ef">return</span> @result<span style="color:#f92672">.</span>join ;
}
</code></pre></div><p>One little surprising thing is that Kevin decided to abort his program when the key passed to it is longer than the message. I do not see any reason to do so, quite to the contrary: the code is much more difficult to break when the key has a length equal to or larger than the message (the repeating of the key is the main weakness of the Vigenère cypher).</p>
<p><a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-015/athanasius/perl6/ch-2.p6">Athanasius</a> wrote two helper subroutines, <code>str2num</code> and <code>num2str</code>, to convert a string into an array of numerical items and back, which can be used both for the input string and the key. Before starting to encode or decode, the program copies the key numeric codes as many times as needed to obtain a final key equal to or longer than the text. At this point, encrypting a message from the array of its numeric codes becomes fairly easy:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-Perl6" data-lang="Perl6"><span style="color:#66d9ef">while</span> @plain
    {
        <span style="color:#66d9ef">my</span> $m <span style="color:#f92672">=</span> @plain<span style="color:#f92672">.</span>shift;
        <span style="color:#66d9ef">my</span> $k <span style="color:#f92672">=</span> @key<span style="color:#f92672">.</span>shift;<span style="color:#960050;background-color:#1e0010">`</span>
        @cipher<span style="color:#f92672">.</span>push: ($m <span style="color:#f92672">+</span> $k) % <span style="color:#960050;background-color:#1e0010">@</span>ALPHABET<span style="color:#f92672">.</span>elems;
    }
    <span style="color:#66d9ef">return</span> num2str(@cipher);
}
</code></pre></div><p>and decrypting is just about the same with a minus sign instead of a plus.</p>
<p><a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-015/jaldhar-h-vyas/perl6/ch-2.p6">Jaldhar H. Vyas</a> chose an unexpected and uncommon approach: he actually wrote a <em>tabula recta</em>:</p>
<p><img src="https://upload.wikimedia.org/wikipedia/commons/thumb/9/9a/Vigen%C3%A8re_square_shading.svg/330px-Vigen%C3%A8re_square_shading.svg.png" alt="Tabula recta"></p>
<p>i.e. Vigenère&rsquo;s original table of alphabets written out 26 times, each time shifted by one letter, in the form of hash of strings: <code>A =&gt; ABCDEFGHIJKLMNOPQRSTUVWXYZ, B =&gt; BCDEFGHIJKLMNOPQRSTUVWXYZA, ...</code>. Once this preparation work is done, this encrypt subroutine becomes quite concise:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-Perl6" data-lang="Perl6"><span style="color:#66d9ef">sub</span> <span style="color:#a6e22e">encrypt</span>(@key, $keylength, %tabulaRecta, $c) {
    state $i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;

    <span style="color:#66d9ef">return</span> substr(%tabulaRecta{@key[$i<span style="color:#f92672">++</span> % <span style="color:#960050;background-color:#1e0010">$</span>keylength]}, ord($c) <span style="color:#f92672">-</span> ord(<span style="color:#e6db74">&#39;A&#39;</span>), <span style="color:#ae81ff">1</span>);
}
</code></pre></div><p><a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-015/joelle-maslak/perl6/ch-2.p6">Joelle Maslak</a> decided to accept upper case and lower case alphabetical characters for the input message. She managed the array of letters representing the key as a circular buffer: at each step during encoding or decoding, her program moves the first letter of the key to the end of the array, so that, for coding or decoding a message, her program always picks up the letter of the array.</p>
<p><a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-015/ruben-westerberg/perl6/ch-2.p6">Ruben Westerberg</a> decided to use an alphabet containing upper case and lower case ASCII letters plus spaces and a few punctuation symbols. His program reads line by line from a file and writes to a file. It uses heavily the <code>&gt;&gt;</code> hyper-operator to encode in just one statement the input array of integer ASCII codes into an array of encoded numbers. I must say that it took me a while to understand that statement.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-Perl6" data-lang="Perl6"><span style="color:#66d9ef">sub</span> <span style="color:#a6e22e">MAIN</span> ( Str $key, Bool :$decode, Str :$file ) {
    <span style="color:#66d9ef">my</span> $f<span style="color:#f92672">=</span>$decode??<span style="color:#ae81ff">1</span><span style="color:#f92672">!!-</span><span style="color:#ae81ff">1</span>;
    $<span style="color:#960050;background-color:#1e0010">*</span>OUT<span style="color:#f92672">.</span>out<span style="color:#f92672">-</span>buffer<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>;
    <span style="color:#66d9ef">my</span> @alpha<span style="color:#f92672">=</span>(<span style="color:#e6db74">&#34;a&#34;</span><span style="color:#f92672">..</span><span style="color:#e6db74">&#34;z&#34;</span>,<span style="color:#e6db74">&#34;A&#34;</span><span style="color:#f92672">..</span><span style="color:#e6db74">&#34;Z&#34;</span>,<span style="color:#e6db74">&#34; &#34;</span>, <span style="color:#f92672">&lt;</span>? <span style="color:#f92672">!</span> <span style="color:#f92672">.</span> : <span style="color:#f92672">&gt;</span>)[<span style="color:#f92672">*</span>;<span style="color:#f92672">*</span>];
    <span style="color:#66d9ef">my</span> @a<span style="color:#f92672">=</span>@alpha<span style="color:#f92672">.</span>keys;
    <span style="color:#66d9ef">my</span> @k<span style="color:#f92672">=</span>$key<span style="color:#f92672">.</span>comb<span style="color:#f92672">.</span>map(<span style="color:#f92672">-&gt;</span> $c {<span style="color:#f92672">|</span>@alpha<span style="color:#f92672">.</span>grep($c,:k)});
    <span style="color:#66d9ef">for</span> $<span style="color:#960050;background-color:#1e0010">*</span>IN<span style="color:#f92672">.</span>lines <span style="color:#f92672">-&gt;</span> $line {
        <span style="color:#66d9ef">my</span> @in<span style="color:#f92672">=</span> $line<span style="color:#f92672">.</span>comb<span style="color:#f92672">.</span>map(<span style="color:#f92672">-&gt;</span>$c {<span style="color:#f92672">|</span>@alpha<span style="color:#f92672">.</span>grep($c,:k)});
        <span style="color:#66d9ef">my</span> @t<span style="color:#f92672">=</span> (@in <span style="color:#f92672">&gt;&gt;+&gt;&gt;</span> (@k <span style="color:#f92672">&gt;&gt;*&gt;&gt;</span> $f)) <span style="color:#f92672">&gt;&gt;</span>%<span style="color:#960050;background-color:#1e0010">&gt;&gt;</span> <span style="color:#960050;background-color:#1e0010">@</span>a<span style="color:#f92672">.</span>elems;
        put  join <span style="color:#e6db74">&#34;&#34;</span>, @alpha[@t];
    }
}
</code></pre></div><h2 id="task-2-strong-and-weak-prime-numbers">Task #2: Strong and Weak Prime Numbers</h2>
<p>This is derived in part from my <a href="http://blogs.perl.org/users/laurent_r/2019/07/perl-weekly-challenge-15-strong-and-weak-primes-and-vigenere-encryption.html">blog post1</a> and <a href="http://blogs.perl.org/users/laurent_r/2019/07/functional-programming-in-perl-strong-and-weak-primes-perl-weekly-challenge.html">blog post2</a> made in answer to the <a href="https://perlweeklychallenge.org/blog/perl-weekly-challenge-015/">Week 15 of the Perl Weekly Challenge</a> organized by  <a href="http://blogs.perl.org/users/mohammad_s_anwar/">Mohammad S. Anwar</a> as well as answers made by others to the same challenge.</p>
<p>The challenge reads as follows:</p>
<p><em>Write a script to generate first 10 strong and weak prime numbers.</em></p>
<pre><code>For example, the nth prime number is represented by p(n).

  p(1) = 2
  p(2) = 3
  p(3) = 5
  p(4) = 7
  p(5) = 11

  Strong Prime number p(n) when p(n) &gt; [ p(n-1) + p(n+1) ] / 2
  Weak   Prime number p(n) when p(n) &lt; [ p(n-1) + p(n+1) ] / 2
</code></pre>
<p>A <em>strong prime</em> is a prime number that is greater than the arithmetic mean of the nearest primes above and below (in other words, it&rsquo;s closer to the following than to the preceding prime). A <em>weak prime</em> is a prime number that is less than the arithmetic mean of the nearest prime above and below. Obviously, a prime number cannot both strong and weak, but some prime numbers, such as 5 or 53 (we&rsquo;ll see more of them later), are neither strong, nor weak (they&rsquo;re called <em>balanced</em> primes): for example, 5 is equal to the arithmetic mean of 3 and 7. Therefore, the fact that a prime is not strong doesn&rsquo;t mean that it is weak.</p>
<h2 id="my-solutions">My Solutions</h2>
<h3 id="first-steps">First Steps</h3>
<p>We don&rsquo;t know in advance how many prime numbers we&rsquo;ll need to check to find 10 strong and 10 weak primes. This is a typical situation where using Perl 6&rsquo;s infinite lazy lists is very convenient.</p>
<p>In the first code example below, we first build a lazy infinite list of prime numbers, and then use <code>grep</code> to filter the strong (and weak) primes, so as to construct lazy infinite lists of strong and weak primes, and we finally print out the first 10 numbers of each such list. This is fairly straight forward:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-Perl6" data-lang="Perl6"><span style="color:#66d9ef">use</span> v6;

<span style="color:#66d9ef">my</span> @p <span style="color:#f92672">=</span> grep { <span style="color:#f92672">.</span>is<span style="color:#f92672">-</span>prime }, <span style="color:#ae81ff">1</span><span style="color:#f92672">..*</span>;   <span style="color:#75715e">#Lazy infinite list of primes</span>
<span style="color:#66d9ef">my</span> @strong <span style="color:#f92672">=</span> map { @p[$_] },
    grep { @p[$_] <span style="color:#f92672">&gt;</span> (@p[$_ <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>] <span style="color:#f92672">+</span> @p[$_ <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>]) <span style="color:#f92672">/</span> <span style="color:#ae81ff">2</span> }, <span style="color:#ae81ff">1</span><span style="color:#f92672">..*</span>;
<span style="color:#66d9ef">my</span> @weak <span style="color:#f92672">=</span> map { @p[$_] },
    grep { @p[$_] <span style="color:#f92672">&lt;</span> (@p[$_ <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>] <span style="color:#f92672">+</span> @p[$_ <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>]) <span style="color:#f92672">/</span> <span style="color:#ae81ff">2</span> }, <span style="color:#ae81ff">1</span><span style="color:#f92672">..*</span>;
say <span style="color:#e6db74">&#34;Strong primes: @strong[0..9]&#34;</span>;
say <span style="color:#e6db74">&#34;Weak primes: @weak[0..9]&#34;</span>;
</code></pre></div><p>This script displays the following output:</p>
<pre><code>$ perl6 strong_primes.p6
Strong primes: 11 17 29 37 41 59 67 71 79 97
Weak primes: 3 7 13 19 23 31 43 47 61 73
</code></pre>
<p>We don&rsquo;t really need to build the intermediate <code>@strong</code> and <code>@weak</code> lazy infinite lists, but can print out the results directly:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-Perl6" data-lang="Perl6"><span style="color:#66d9ef">use</span> v6;

<span style="color:#66d9ef">my</span> @p <span style="color:#f92672">=</span> grep { <span style="color:#f92672">.</span>is<span style="color:#f92672">-</span>prime }, <span style="color:#ae81ff">1</span><span style="color:#f92672">..*</span>;   <span style="color:#75715e"># Lazy infinite list of primes</span>
say <span style="color:#e6db74">&#34;Strong primes: &#34;</span>, (map { @p[$_] },
    grep { @p[$_] <span style="color:#f92672">&gt;</span> (@p[$_ <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>] <span style="color:#f92672">+</span> @p[$_ <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>]) <span style="color:#f92672">/</span> <span style="color:#ae81ff">2</span> }, <span style="color:#ae81ff">1</span><span style="color:#f92672">..*</span>)[<span style="color:#ae81ff">0</span><span style="color:#f92672">..</span><span style="color:#ae81ff">9</span>];
say <span style="color:#e6db74">&#34;Weak primes: &#34;</span>, (map { @p[$_] },
    grep { @p[$_] <span style="color:#f92672">&lt;</span> (@p[$_ <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>] <span style="color:#f92672">+</span> @p[$_ <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>]) <span style="color:#f92672">/</span> <span style="color:#ae81ff">2</span> }, <span style="color:#ae81ff">1</span><span style="color:#f92672">..*</span>)[<span style="color:#ae81ff">0</span><span style="color:#f92672">..</span><span style="color:#ae81ff">9</span>];
</code></pre></div><p>This prints out the same lists as before:</p>
<pre><code>perl6 strong_primes.p6
Strong primes: (11 17 29 37 41 59 67 71 79 97)
Weak primes: (3 7 13 19 23 31 43 47 61 73)
</code></pre>
<p>We&rsquo;re now down to three code lines instead of five (except that I have to format each of the two last code lines over two typographical lines to fit cleanly on my editor screen or on this blog post).</p>
<h3 id="categorizing-or-classifying-primes">Categorizing or Classifying Primes</h3>
<p>One slight problem with the implementation above is that, once we have generated our list of primes, we need to go through it twice with the <code>map ... grep</code> chained statements, one for the strong primes and once for the weak primes; and we&rsquo;d need to visit the prime list a third time for finding balanced primes. Although the script runs very fast, it would be better if we could do the categorizing in one go. Perl 6 has two built-in routines to do that, <code>categorize</code> and <code>classify</code>. Let&rsquo;s try to use the first one:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-Perl6" data-lang="Perl6"><span style="color:#66d9ef">use</span> v6;

<span style="color:#66d9ef">my</span> @p <span style="color:#f92672">=</span> grep { <span style="color:#f92672">.</span>is<span style="color:#f92672">-</span>prime }, <span style="color:#ae81ff">1</span><span style="color:#f92672">..*</span>;   <span style="color:#75715e"># Lazy infinite list of primes</span>
<span style="color:#66d9ef">sub</span> <span style="color:#a6e22e">mapper</span>(UInt $i) {
    @p[$i] <span style="color:#f92672">&gt;</span> (@p[$i <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>] <span style="color:#f92672">+</span> @p[$i <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>])<span style="color:#f92672">/</span><span style="color:#ae81ff">2</span> ?? <span style="color:#e6db74">&#39;Strong&#39;</span> <span style="color:#f92672">!!</span>
    @p[$i] <span style="color:#f92672">&lt;</span> (@p[$i <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>] <span style="color:#f92672">+</span> @p[$i <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>])<span style="color:#f92672">/</span><span style="color:#ae81ff">2</span> ?? <span style="color:#e6db74">&#39;Weak&#39;</span>   <span style="color:#f92672">!!</span>
    <span style="color:#e6db74">&#39;Balanced&#39;</span>;
}
<span style="color:#66d9ef">my</span> %categories <span style="color:#f92672">=</span> categorize <span style="color:#f92672">&amp;</span>mapper, <span style="color:#ae81ff">1</span><span style="color:#f92672">..</span><span style="color:#ae81ff">120</span>;
<span style="color:#66d9ef">for</span> sort keys %categories <span style="color:#f92672">-&gt;</span> $key {
    say <span style="color:#e6db74">&#34;$key primes:  &#34;</span>, map {@p[$_]}, %categories{$key}[<span style="color:#ae81ff">0</span><span style="color:#f92672">..</span><span style="color:#ae81ff">9</span>];
}
</code></pre></div><p>Running this program produces the following output:</p>
<pre><code>$ perl6 strong_primes.p6
Balanced primes:  (5 53 157 173 211 257 263 373 563 593)
Strong primes:  (11 17 29 37 41 59 67 71 79 97)
Weak primes:  (3 7 13 19 23 31 43 47 61 73)
</code></pre>
<p>Here, we define a <code>mapper</code> subroutine to find out whether a given prime is strong, weak or balanced. Then, we pass to <code>categorize</code> two arguments: the <code>mapper</code>subroutine and a range of subsequent integers (the indexes of the <code>@p</code> prime number list) starting with 1 (the first prime cannot be weak or strong or balanced, since it has no predecessor) and store the result in the <code>%categories</code> hash, which is in fact a hash of arrays with three keys (one for each type of primes) and values being the index in the <code>@p</code> prime array of primes belonging to the corresponding type.</p>
<p>For example, with an input range of <code>1..30</code>, the <code>%categories</code> hash has the following contents:</p>
<pre><code>{
    Balanced =&gt; [2 15],
    Strong =&gt; [4 6 9 11 12 16 18 19 21 24 25 27 30],
    Weak =&gt; [1 3 5 7 8 10 13 14 17 20 22 23 26 28 29]
}
</code></pre>
<p>Remember that the numbers in the three lists above are obviously not the primes, but the indexes of the primes in the <code>@p</code> array.</p>
<p>Then, the <code>for</code> loop extracts 10 numbers from each key of hash (with a full input range of <code>1..120</code>).</p>
<p>This <code>categorize</code> built-in is very useful and practical for cases where you want to split some input data into different categories, but it isn&rsquo;t well adapted to our case in point, because it does not work with <em>lazy</em> lists. And since balanced primes are much less common than strong and weak primes, I was forced to use a relatively large range of <code>1..120</code> to make sure that I would get 10 balanced primes. For this specific problem, the <code>classify</code> built-in subroutine works essentially as <code>categorize</code> and also reports the <code>Cannot classify a lazy list</code> error message when trying to use it on a lazy infinite list. The difference between <code>categorize</code> and <code>classify</code> is that the latter returns a scalar whereas the former can return a list; so, in our example, it might have been slightly better to use <code>classify</code> rather than <code>categorize</code>, but the difference between the two built-ins is insignificant in our case.</p>
<p>We will come back to this later.</p>
<h3 id="using-functional-programming">Using Functional Programming</h3>
<p>I want to use the opportunity of this challenge to illustrate once more some possibilities of functional programming in Perl</p>
<p>In fact, the first solution suggested above is in fact already largely functional in spirit. We&rsquo;re using a data pipeline programming model. The code lines with <code>map</code> and <code>grep</code> statements should be read from bottom to top (when they are formatted over more than one line)  and from right to left. For example, to understand this code line:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-Perl6" data-lang="Perl6"><span style="color:#66d9ef">my</span> @strong <span style="color:#f92672">=</span> map $p[$_],
    grep { $p[$_] <span style="color:#f92672">-</span> $p[$_<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>] <span style="color:#f92672">&gt;</span> $p[$_<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>] <span style="color:#f92672">-</span> $p[$_] } <span style="color:#ae81ff">1</span><span style="color:#f92672">..</span><span style="color:#ae81ff">25</span>;
</code></pre></div><p>one needs to start from the <code>1..25</code> range, which is fed to the <code>grep</code> statement, whose role is to filter the range values and keep those which satisfy the condition within the <code>grep</code> block. This means, in this case, to keep the indexes of values in the <code>@p</code> array of prime numbers for which the current prime number is closer to the next prime than to the previous prime. These indexes are then fed to the <code>map</code> statement in order to populate the <code>@strong</code> array with such primes.</p>
<p>This implementation works fine, but we saw that there is a weakness: we&rsquo;re scanning the <code>@p</code> array of prime numbers twice (or even three times if we want to also identify the balanced primes). And the other solution using <code>categorize</code>  or <code>classify</code> removed that weakness, but was not entirely satisfactory because we could no longer use lazy infinite lists for our input values.</p>
<p>Note that these weaknesses don&rsquo;t matter very much, since we&rsquo;re dealing with small ranges anyway, but that&rsquo;s not really satisfactory to the mind, as we know that these programs wouldn&rsquo;t scale too well for larger ranges. Let&rsquo;s see whether we can improve these programs.</p>
<p>I hate to say that, but an easy solution is to write a non (or less) functional solution using an infinite loop.</p>
<p>For example, this could be something like this:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-Perl6" data-lang="Perl6"><span style="color:#66d9ef">use</span> v6;

<span style="color:#66d9ef">my</span> @p <span style="color:#f92672">=</span> grep { <span style="color:#f92672">.</span>is<span style="color:#f92672">-</span>prime }, <span style="color:#ae81ff">1</span><span style="color:#f92672">..*</span>;   <span style="color:#75715e"># Lazy infinite list of primes</span>
<span style="color:#66d9ef">my</span> (@strong, @weak, @balanced);
<span style="color:#66d9ef">for</span> <span style="color:#ae81ff">1</span><span style="color:#f92672">..*</span> <span style="color:#f92672">-&gt;</span> $i {
    <span style="color:#66d9ef">if</span> @p[$i] <span style="color:#f92672">&gt;</span> (@p[$i <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>] <span style="color:#f92672">+</span> @p[$i <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>])<span style="color:#f92672">/</span><span style="color:#ae81ff">2</span> {
        push @strong, @p[$i];
    }
    <span style="color:#66d9ef">elsif</span> @p[$i] <span style="color:#f92672">&lt;</span> (@p[$i <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>] <span style="color:#f92672">+</span> @p[$i <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>])<span style="color:#f92672">/</span><span style="color:#ae81ff">2</span> {
        push @weak, @p[$i];
    } <span style="color:#66d9ef">else</span> {
        push @balanced, @p[$i];
    }
    <span style="color:#66d9ef">last</span> <span style="color:#66d9ef">if</span> @balanced<span style="color:#f92672">.</span>elems <span style="color:#f92672">&gt;=</span> <span style="color:#ae81ff">10</span>;
}
say <span style="color:#e6db74">&#34;Strong primes: @strong[0..9]&#34;</span>;
say <span style="color:#e6db74">&#34;Weak primes: @weak[0..9]&#34;</span>;
say <span style="color:#e6db74">&#34;Balanced primes: @balanced[]&#34;</span>;
</code></pre></div><p>This script produces the following output:</p>
<pre><code>$ perl6 strong_primes.p6
Strong primes: 11 17 29 37 41 59 67 71 79 97
Weak primes: 3 7 13 19 23 31 43 47 61 73
Balanced primes: 5 53 157 173 211 257 263 373 563 593
</code></pre>
<p>Note that in the code above, we use the fact that we know from previous tests that balanced primes are much less frequent than either strong or weak primes, so that we can stop the <code>for</code> loop when we have 10 balanced primes (if we did not know that, we would have had to test the three arrays) . Also note that this works fine because, in Perl 6, a <code>for</code> loop is lazy. There may be some possible minor improvements, for example avoiding multiple dereferencing of the <code>@p</code> values, but I&rsquo;m not really interested here with micro-optimizations.</p>
<p>This new version works fine, but that&rsquo;s really not the way I would like to go: I would like to have a more functional version , not a less functional version.</p>
<p>Let&rsquo;s come back to the <code>categorize</code> and <code>classify</code> built-in functions. As already noted, they&rsquo;re perfect for what we want to do, but don&rsquo;t work with infinite lists.</p>
<p>Let&rsquo;s see if we can write our own version of  <code>categorize</code> or <code>classify</code> which would have the same calling syntax and be able to handle infinite lists. Our version of this function will be called <code>distribute</code>.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-Perl6" data-lang="Perl6">@p <span style="color:#f92672">=</span> grep { <span style="color:#f92672">.</span>is<span style="color:#f92672">-</span>prime }, <span style="color:#ae81ff">1</span><span style="color:#f92672">..*</span>;   <span style="color:#75715e"># Lazy infinite list of primes</span>
    <span style="color:#66d9ef">sub</span> <span style="color:#a6e22e">mapper</span>(UInt $i) {
        @p[$i] <span style="color:#f92672">&gt;</span> (@p[$i <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>] <span style="color:#f92672">+</span> @p[$i <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>])<span style="color:#f92672">/</span><span style="color:#ae81ff">2</span> ?? <span style="color:#e6db74">&#39;Strong&#39;</span> <span style="color:#f92672">!!</span>
        @p[$i] <span style="color:#f92672">&lt;</span> (@p[$i <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>] <span style="color:#f92672">+</span> @p[$i <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>])<span style="color:#f92672">/</span><span style="color:#ae81ff">2</span> ?? <span style="color:#e6db74">&#39;Weak&#39;</span>   <span style="color:#f92672">!!</span>
        <span style="color:#e6db74">&#39;Balanced&#39;</span>;
    }
    <span style="color:#66d9ef">sub</span> <span style="color:#a6e22e">distribute</span> (&amp;code, @primes) {
        <span style="color:#66d9ef">my</span> %distribution;
        <span style="color:#66d9ef">for</span> @primes<span style="color:#f92672">.</span>kv <span style="color:#f92672">-&gt;</span> $key, $val {
            <span style="color:#66d9ef">next</span> <span style="color:#66d9ef">if</span> $key <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>;
            push %distribution{<span style="color:#f92672">&amp;</span>code($key)}, $val;
            <span style="color:#66d9ef">last</span> <span style="color:#66d9ef">if</span> %distribution{<span style="color:#e6db74">&#39;Balanced&#39;</span>}<span style="color:#f92672">.</span>elems <span style="color:#f92672">&gt;=</span> <span style="color:#ae81ff">10</span>;
        }
        <span style="color:#66d9ef">return</span> %distribution;
    }
    <span style="color:#66d9ef">my</span> %categories <span style="color:#f92672">=</span> distribute <span style="color:#f92672">&amp;</span>mapper, @p;
    <span style="color:#66d9ef">for</span> sort keys %categories <span style="color:#f92672">-&gt;</span> $key {
        say <span style="color:#e6db74">&#34;$key primes:  &#34;</span>, %categories{$key}[<span style="color:#ae81ff">0</span><span style="color:#f92672">..</span><span style="color:#ae81ff">9</span>];
    }
</code></pre></div><p>Note that, contrary to the previous version, the <code>%distribution</code> and <code>%categories</code> hashes now contain the primes, not the prime indexes in the prime array.</p>
<p>And we no longer need to estimate the number of input values to get the desired output.</p>
<p>I am not fully satisfied, though, because our <code>distribute</code> subroutine is tailored to our problem at hand and is not generic enough:</p>
<ul>
<li>We need to skip (<code>next if ...</code>) the first prime of the list , because it is neither strong, nor weak, nor balanced, since it has no predecessor (and we would get an out-of-range index error or something similar if we kept it); we can solve that by tagging the first index (0) as <code>'Excluded'</code> in the <code>mapper</code> subroutine, and by excluding that new category from the final output.</li>
<li>The stopping condition (<code>last if ...</code>) is hard-coded in the <code>distribute</code> subroutine. Well, we can pass to <code>distribute</code> a third argument, another code block (<code>$stopper</code>), to stop the iteration.</li>
</ul>
<p>These two changes  will make our <code>distribute</code> subroutine more generic:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-Perl6" data-lang="Perl6"><span style="color:#66d9ef">use</span> v6;

<span style="color:#66d9ef">my</span> @p <span style="color:#f92672">=</span> grep { <span style="color:#f92672">.</span>is<span style="color:#f92672">-</span>prime }, <span style="color:#ae81ff">1</span><span style="color:#f92672">..*</span>;   <span style="color:#75715e"># Lazy infinite list of primes</span>
<span style="color:#66d9ef">sub</span> <span style="color:#a6e22e">mapper</span>(UInt $i) {
    $i <span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">1</span>                               ?? <span style="color:#e6db74">&#39;Excluded&#39;</span> <span style="color:#f92672">!!</span>
    @p[$i] <span style="color:#f92672">&gt;</span> (@p[$i <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>] <span style="color:#f92672">+</span> @p[$i <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>])<span style="color:#f92672">/</span><span style="color:#ae81ff">2</span> ?? <span style="color:#e6db74">&#39;Strong&#39;</span>   <span style="color:#f92672">!!</span>
    @p[$i] <span style="color:#f92672">&lt;</span> (@p[$i <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>] <span style="color:#f92672">+</span> @p[$i <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>])<span style="color:#f92672">/</span><span style="color:#ae81ff">2</span> ?? <span style="color:#e6db74">&#39;Weak&#39;</span>     <span style="color:#f92672">!!</span>
    <span style="color:#e6db74">&#39;Balanced&#39;</span>;
}
<span style="color:#66d9ef">sub</span> <span style="color:#a6e22e">distribute</span> (&amp;code, @primes, &amp;stopper) {
    <span style="color:#66d9ef">my</span> %distribution;
    <span style="color:#66d9ef">for</span> @primes<span style="color:#f92672">.</span>kv <span style="color:#f92672">-&gt;</span> $key, $val {
        push %distribution{<span style="color:#f92672">&amp;</span>code($key)}, $val;
        <span style="color:#f92672">&amp;</span>stopper(%distribution);
    }
    <span style="color:#66d9ef">return</span> %distribution;
}
<span style="color:#66d9ef">my</span> $stopper <span style="color:#f92672">=</span> { <span style="color:#66d9ef">last</span> <span style="color:#66d9ef">if</span> %<span style="color:#960050;background-color:#1e0010">^</span>a{<span style="color:#e6db74">&#39;Balanced&#39;</span>}<span style="color:#f92672">.</span>elems <span style="color:#f92672">&gt;=</span> <span style="color:#ae81ff">10</span> };
<span style="color:#66d9ef">my</span> %categories <span style="color:#f92672">=</span> distribute <span style="color:#f92672">&amp;</span>mapper, @p, $stopper;
<span style="color:#66d9ef">for</span> sort keys %categories <span style="color:#f92672">-&gt;</span> $key {
    <span style="color:#66d9ef">next</span> <span style="color:#66d9ef">if</span> $key <span style="color:#f92672">eq</span> <span style="color:#e6db74">&#39;Excluded&#39;</span>;
    say <span style="color:#e6db74">&#34;$key primes:  &#34;</span>, %categories{$key}[<span style="color:#ae81ff">0</span><span style="color:#f92672">..</span><span style="color:#ae81ff">9</span>];
}
</code></pre></div><p>The only trick here if that the <code>$stopper</code> code block uses a self-declared positional parameter (or placeholder), <code>%^a</code>. And we pass the <code>%distribution</code> hash as a parameter to <code>&amp;stopper</code> when we run it within the <code>distribute</code> subroutine. Thus, the calling code doesn&rsquo;t have to know the name of the hash within the <code>distribute</code> subroutine, which is now generic. To be frank, I wasn&rsquo;t fully convinced that this would work until I ran it.</p>
<p>The output is what we want:</p>
<pre><code>$ perl6 strong_primes.p6
Balanced primes:  (5 53 157 173 211 257 263 373 563 593)
Strong primes:  (11 17 29 37 41 59 67 71 79 97)
Weak primes:  (3 7 13 19 23 31 43 47 61 73)
</code></pre>
<p>A final comment on all this. I called <code>distribute</code> my new version of the <code>classify</code> or <code>categorize</code> subroutines because I did not want to mess around the semantics of those existing functions. But it works to define the <code>distribute</code> subroutine as a <code>multi sub classify</code> subroutine:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-Perl6" data-lang="Perl6"><span style="color:#66d9ef">use</span> v6;

<span style="color:#66d9ef">my</span> @p <span style="color:#f92672">=</span> grep { <span style="color:#f92672">.</span>is<span style="color:#f92672">-</span>prime }, <span style="color:#ae81ff">1</span><span style="color:#f92672">..*</span>;   <span style="color:#75715e"># Lazy infinite list of primes</span>
<span style="color:#66d9ef">sub</span> <span style="color:#a6e22e">mapper</span>(UInt $i) {
    <span style="color:#75715e"># same code as just above</span>
}
multi <span style="color:#66d9ef">sub</span> <span style="color:#a6e22e">classify</span> (&amp;code, @a, &amp;stopper) {
    <span style="color:#66d9ef">my</span> %distribution;
    <span style="color:#66d9ef">for</span> @a<span style="color:#f92672">.</span>kv <span style="color:#f92672">-&gt;</span> $key, $val {
        push %distribution{<span style="color:#f92672">&amp;</span>code($key)}, $val;
        <span style="color:#f92672">&amp;</span>stopper(%distribution);
    }
    <span style="color:#66d9ef">return</span> %distribution;
}
<span style="color:#66d9ef">my</span> $stopper <span style="color:#f92672">=</span> { <span style="color:#66d9ef">last</span> <span style="color:#66d9ef">if</span> %<span style="color:#960050;background-color:#1e0010">^</span>a{<span style="color:#e6db74">&#39;Balanced&#39;</span>}<span style="color:#f92672">.</span>elems <span style="color:#f92672">&gt;=</span> <span style="color:#ae81ff">10</span> };
<span style="color:#66d9ef">my</span> %categories <span style="color:#f92672">=</span> classify <span style="color:#f92672">&amp;</span>mapper, @p, $stopper;
<span style="color:#66d9ef">for</span> sort keys %categories <span style="color:#f92672">-&gt;</span> $key {
    <span style="color:#66d9ef">next</span> <span style="color:#66d9ef">if</span> $key <span style="color:#f92672">eq</span> <span style="color:#e6db74">&#39;Excluded&#39;</span>;
    say <span style="color:#e6db74">&#34;$key primes:  &#34;</span>, %categories{$key}[<span style="color:#ae81ff">0</span><span style="color:#f92672">..</span><span style="color:#ae81ff">9</span>];
}
</code></pre></div><p>I no longer get the <code>Cannot classify a lazy list</code> error message, this code works fine and it outputs the same result as before. This was just to test that this could be done syntactically and would work, but I wouldn&rsquo;t want to do that in actual production code without first very closely looking at the semantics of the built-in <code>classify</code> subroutine: I do not want to create a monster with a different meanings depending on the circumstances.</p>
<h2 id="alternative-solutions">Alternative Solutions</h2>
<p><a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-015/arne-sommer/perl6/ch-1.p6">Arne Sommer</a> first generated a lazy infinite list of prime numbers. Then, his program iterates over successive integers and, for each such integer, determines whether the prime having that index in the prime array is strong or weak (or neither), and pushes those in the right array. The loop stops when both the <code>@strong</code> and <code>@weak</code> arrays have at least 10 elements. It then prints 10 elements of each array.</p>
<p>It is worth noting that Arne used a sigil-less variable, <code>p</code>, for his array of primes, as well as for his <code>for</code> loop iteration variable (<code>n</code>), so that his code to compute whether a prime is strong or weak looks almost exactly the same as the math formulas of the challenge specification:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-Perl6" data-lang="Perl6"><span style="color:#66d9ef">if</span> p[n] <span style="color:#f92672">&gt;</span> ( p[n<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>] <span style="color:#f92672">+</span> p[n<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>] ) <span style="color:#f92672">/</span> <span style="color:#ae81ff">2</span> { <span style="color:#75715e"># ...</span>
</code></pre></div><p>That&rsquo;s quite a nice feature, because the code can be understood and possibly even checked (to a certain degree) by domain experts, not just software engineers or CS scientists (even though, or course, we&rsquo;re talking here about rather trivial examples).</p>
<p><a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-015/athanasius/perl6/ch-1.p6">Athanasius</a> used a <code>next-prime</code> subroutine that acts essentially as an iterator: each time it is called, it returns a new prime number (keeping track of the last one that was provided). Otherwise, his program maintains a hash of 2 arrays (strong and weak primes). Then, while we don&rsquo;t have enough primes of each category, the program calls <code>next-prime</code> to get another prime (<code>$next</code>) and stores into one of the categories, if it meets the criteria. The program also maintains a <code>$previous</code> prime and a <code>current</code> prime to be able to perform the proper comparisons.</p>
<p><a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-015/jaldhar-h-vyas/perl6/ch-1.p6">Jaldhar M. Vyas</a> created first a lazy infinite list of primes, and then use a <code>grep</code> to create a lazy infinite list of strong primes and a lazy infinite list of weak primes, and finally printed the first ten items of each of those two last lists. Essentially the same thing as my first solution, except that Jaldhar&rsquo;s program is using chained method invocations (where mine uses chained function calls). Here is the example for the strong primes:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-Perl6" data-lang="Perl6"><span style="color:#66d9ef">my</span> @strongPrimes <span style="color:#f92672">=</span> (<span style="color:#ae81ff">1</span> <span style="color:#f92672">..</span> <span style="color:#960050;background-color:#1e0010">∞</span>)
   <span style="color:#f92672">.</span>grep({ @primes[$_] <span style="color:#f92672">&gt;</span> (@primes[$_ <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>] <span style="color:#f92672">+</span> @primes[$_ <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>]) <span style="color:#f92672">/</span> <span style="color:#ae81ff">2</span> })
   <span style="color:#f92672">.</span>map({ @primes[$_] });
</code></pre></div><p><a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-015/joelle-maslak/perl6/ch-1.p6">Joelle Maslak</a> also created a lazy infinite list of primes. Then, she created the lists of strong and weak primes using a <code>lazy gather/take</code> block. For example for the strong primes:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-Perl6" data-lang="Perl6"><span style="color:#66d9ef">my</span> @strong <span style="color:#f92672">=</span> lazy gather {
    <span style="color:#66d9ef">for</span> <span style="color:#ae81ff">1</span><span style="color:#f92672">..</span><span style="color:#960050;background-color:#1e0010">∞</span> <span style="color:#f92672">-&gt;</span> $i {
        take @primes[$i] <span style="color:#66d9ef">if</span> @primes[$i] <span style="color:#f92672">&gt;</span> @primes[$i<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>,$i<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>]<span style="color:#f92672">.</span>sum <span style="color:#f92672">/</span> <span style="color:#ae81ff">2</span>
    };
}
</code></pre></div><p><a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-015/ruben-westerberg/perl6/ch-1.p6">Ruben Westerberg</a> also created a lazy infinite list of primes. Then, while iterating over successive integers, his program populates a kind of circular buffer (<code>@ps</code>) of three primes and does the required computations on this circular buffer. This works, but seems a bit contrived to me: why not making directly the computations on the previous, current and next elements of the <code>@primes</code> array, since we have an index that can be used on that array?</p>
<h2 id="see-also">SEE ALSO</h2>
<p>Only two blog posts on the strong and weak primes, as far as can say:</p>
<ul>
<li>Arne Sommer: <a href="https://perl6.eu/prime-vigenere.html">https://perl6.eu/prime-vigenere.html</a>.</li>
<li>Jaldhar M. Vyas: <a href="https://www.braincells.com/perl/2019/07/perl_weekly_challenge_week_15.html">https://www.braincells.com/perl/2019/07/perl_weekly_challenge_week_15.html</a>. As of this reading (Aug. 2019), Jaldhar&rsquo;s post has a small Unicode rendering problem in a sentence on ironically the Unicode subject:  &ldquo;(By the way, I love how you can use unicode symbols as syntax in Perl6. But if your editor can&rsquo;t cope, you can use * instead of âˆž.)&rdquo; Jaldhar is speaking about the <code>∞</code> infinity symbol. The same problem occurs in the relevant code sample of the blog post. This being said, note that the ∞ symbol  is rendered correctly in his code samples on Github, it is only in the blog post that there is a problem.</li>
</ul>
<p>Three blog posts on the Vigenère Cypher:</p>
<ul>
<li>
<p>Arne Sommer: <a href="https://perl6.eu/prime-vigenere.html">https://perl6.eu/prime-vigenere.html</a>.</p>
</li>
<li>
<p>Jaldhar M. Vyas: <a href="https://www.braincells.com/perl/2019/07/perl_weekly_challenge_week_15.html">https://www.braincells.com/perl/2019/07/perl_weekly_challenge_week_15.html</a>.</p>
</li>
<li>
<p>Damian Conway: <a href="http://blogs.perl.org/users/damian_conway/2019/07/vigenere-vs-vigenere.html">http://blogs.perl.org/users/damian_conway/2019/07/vigenere-vs-vigenere.html</a>. This blog post is truly awesome, as usual, you should really follow the link.</p>
</li>
</ul>
<h2 id="wrapping-up">Wrapping up</h2>
<p>Please let me know if I forgot any of the challengers or if you think my explanation of your code misses something important.</p>
<p>If you want to participate to the Perl Weekly Challenge, please connect to <a href="https://perlweeklychallenge.org/">this site</a>.</p>

                </div>
            </div>
        </div>
    </div>
</section>


<!-- Call To Action Section Start -->
<section id="call-to-action">
    <div class="container">
        <div class="row">
            <div class="col-md-12">
                <div class="block">
                    <h2 class="title wow fadeInDown" data-wow-delay=".3s" data-wow-duration="500ms">SO WHAT DO YOU THINK ?</h2>
                    <p class="wow fadeInDown" data-wow-delay=".5s" data-wow-duration="500ms">If you have any suggestions or ideas then please do share with us.</p>
                    <a href="/contact" class="btn btn-default btn-contact wow fadeInDown" data-wow-delay=".7s" data-wow-duration="500ms">Contact with me</a>
                </div>
            </div>

        </div>
    </div>
</section>
<!-- Call To Action Section End -->



<!-- Footer Section Start -->
<footer id="footer">
    <div class="container">
        <div class="row content-justify-between">
            <div class="col-md-8 col-12 text-center text-lg-left text-md-left">
                <p class="copyright">Copyright:
                    <span>
                        2020
                    </span> PerlWeeklyChallenge. Theme Design and Developed by
                    <a href="http://www.Themefisher.com" rel="noreferrer" rel="noreferrer" target="_blank">Themefisher</a>.
                </p>
            </div>
            <div class="col-md-4 col-12">
                <!-- Social Media -->
                <ul class="social text-center text-md-right text-lg-right">
                    <li>
                        <a href="https://twitter.com/PerlWChallenge" class="twitter" rel="noreferrer" target="_blank" title="Follow us">
                            <i class="ion-social-twitter"></i>
                        </a>
                    </li>
                    <li>
                        <a href="/rss.xml" class="rss" target="_blank" title="RSS Feed">
                            <i class="ion-social-rss"></i>
                        </a>
                    </li>
                    <li>
                        <a href="https://www.nomtimes.co.uk/site/shop.do?cref=PerlBooks" title="Free Perl Books" rel="noreferrer" target="_blank">
                            <img src="/images/NomTimes.jpg" style="width:22px; height: 18px;" alt=""/>
                        </a>
                    </li>
                </ul>
            </div>
        </div>
    </div>
</footer>
<!-- footer section end -->

<!-- jquery -->
<script src="https://perlweeklychallenge.org/plugins/jQurey/jquery.min.js"></script>
<!-- Form Validation -->
<script src="https://perlweeklychallenge.org/plugins/form-validation/jquery.form.min.js"></script>
<script src="https://perlweeklychallenge.org/plugins/form-validation/jquery.validate.min.js"></script>
<!-- slick slider -->
<script src="https://perlweeklychallenge.org/plugins/slick/slick.min.js"></script>
<!-- bootstrap js -->
<script src="https://perlweeklychallenge.org/plugins/bootstrap/bootstrap.min.js"></script>
<!-- chart js -->
<script src="https://perlweeklychallenge.org/plugins/chart/highstock.js"></script>
<script src="https://perlweeklychallenge.org/plugins/chart/drilldown.js"></script>
<script src="https://perlweeklychallenge.org/plugins/chart/data.js"></script>
<script src="https://perlweeklychallenge.org/plugins/chart/chart.js"></script>
<script src="https://perlweeklychallenge.org/plugins/chart/pwc-challenge.js"></script>
<script src="https://perlweeklychallenge.org/plugins/chart/gc-challenge.js"></script>
<!-- wow js -->
<script src="https://perlweeklychallenge.org/plugins/wow-js/wow.min.js"></script>
<!-- slider js -->
<script src="https://perlweeklychallenge.org/plugins/slider/slider.js"></script>
<!-- Fancybox -->
<script src="https://perlweeklychallenge.org/plugins/facncybox/jquery.fancybox.js"></script>
<!-- template main js -->

<script src="https://perlweeklychallenge.org/js/script.min.js"></script>
<!-- google analitycs -->
<script>
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
    (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
    m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
    ga('create', 'UA-136524905-1', 'auto');
    ga('send', 'pageview');
</script>
</body>

</html>

