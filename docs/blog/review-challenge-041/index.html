<!DOCTYPE html>
<html class="no-js" lang="en-us">
<head>
    <!-- Basic Page Needs -->

    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta property="og:title"       content="The Weekly Challenge - Perl & Raku"/>
    <meta property="og:type"        content="website"/>
    <meta property="og:url"         content="https://perlweeklychallenge.org/"/>
    <meta property="og:image"       content="https://perlweeklychallenge.org/images/about/about.jpg"/>
    <meta property="og:description" content="You do not have to be an expert."/>
    <meta name="twitter:card"       content="summary" />
    <meta name="twitter:image"      content="https://perlweeklychallenge.org/images/about/about.jpg"/>

    <meta http-equiv="Content-Type" content="text/html; charset=utf-8">

    <meta name="description" content="Perl Weekly Review: Challenge - 041.">
    <meta name="author" content="Perl Weekly Challenge Team">
    <meta name="generator" content="Hugo 0.55.0-DEV" />

    <!-- Mobile Specific Metas -->
    <meta name="format-detection" content="telephone=no">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>Perl Weekly Review: Challenge - 041</title>
    <link rel="icon" href="https://perlweeklychallenge.org/images/favicon.ico">

    
    <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.0/css/bootstrap.min.css"/>

    <!-- Twitter Bootstrs CSS -->
    <link rel="stylesheet" href="https://perlweeklychallenge.org/plugins/bootstrap/bootstrap.min.css">
    <!-- Ionicons Fonts Css -->
    <link rel="stylesheet" href="https://perlweeklychallenge.org/plugins/ionicons/ionicons.min.css">
    <!-- animate css -->
    <link rel="stylesheet" href="https://perlweeklychallenge.org/plugins/animate-css/animate.css">
    <!-- Hero area slider css-->
    <link rel="stylesheet" href="https://perlweeklychallenge.org/plugins/slider/slider.css">
    <!-- slick slider -->
    <link rel="stylesheet" href="https://perlweeklychallenge.org/plugins/slick/slick.css">
    <!-- Fancybox -->
    <link rel="stylesheet" href="https://perlweeklychallenge.org/plugins/facncybox/jquery.fancybox.css">
    <!-- hover -->
    <link rel="stylesheet" href="https://perlweeklychallenge.org/plugins/hover/hover-min.css">
    <!-- template main css file -->
    
    <link rel="stylesheet" href="https://perlweeklychallenge.org/css/style.min.css" integrity="" media="screen">
    <link rel="stylesheet" href="https://perlweeklychallenge.org/css/main.css">
</head>

<body>

<section class="top-bar animated-header">
    <div class="container">
        <div class="row">
            <div class="col-lg-12">
                <nav class="navbar navbar-expand-lg navbar-light bg-light">
                    <a class="navbar-brand" href="https://perlweeklychallenge.org/">
                        <img src="https://perlweeklychallenge.org/images/logo.svg" alt="logo">
                    </a>
                    <button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navgation" aria-controls="navigation"
                        aria-expanded="false" aria-label="Toggle navigation">
                        <span class="navbar-toggler-icon"></span>
                    </button>

                    <div class="collapse navbar-collapse" id="navigation">
                        <ul class="navbar-nav ml-auto">
                            <li class="nav-item">
                                <a class="nav-link" href="https://perlweeklychallenge.org/">Home</a>
                            </li>
                            
                            <li class="nav-item">
                                <a class="nav-link" href="https://perlweeklychallenge.org/about">About</a>
                            </li>
                            
                            <li class="nav-item">
                                <a class="nav-link" href="https://perlweeklychallenge.org/chart">Chart</a>
                            </li>
                            
                            <li class="nav-item">
                                <a class="nav-link" href="https://perlweeklychallenge.org/champions">Champions</a>
                            </li>
                            
                            <li class="nav-item">
                                <a class="nav-link" href="https://perlweeklychallenge.org/team">Team</a>
                            </li>
                            
                            <li class="nav-item">
                                <a class="nav-link" href="https://perlweeklychallenge.org/challenges">Challenges</a>
                            </li>
                            
                            <li class="nav-item">
                                <a class="nav-link" href="https://perlweeklychallenge.org/p5-reviews">Perl/Review</a>
                            </li>
                            
                            <li class="nav-item">
                                <a class="nav-link" href="https://perlweeklychallenge.org/p6-reviews">Raku/Review</a>
                            </li>
                            
                            <li class="nav-item">
                                <a class="nav-link" href="https://perlweeklychallenge.org/recaps">Recaps</a>
                            </li>
                            
                            <li class="nav-item">
                                <a class="nav-link" href="https://perlweeklychallenge.org/blogs">Blogs</a>
                            </li>
                            
                            <li class="nav-item">
                                <a class="nav-link" href="https://perlweeklychallenge.org/faq">FAQ</a>
                            </li>
                            
                            <li class="nav-item">
                                <a class="nav-link" href="https://perlweeklychallenge.org/contact">Contact</a>
                            </li>
                            
                        </ul>
                    </div>
                </nav>
            </div>
        </div>
    </div>
</section>


<section class="global-page-header">
    <div class="container">
        <div class="row">
            <div class="col-md-12">
                <div class="block">
                    <h2>Perl Weekly Review: Challenge - 041</h2>
                    <div class="portfolio-meta">
                        <span>Sunday, Jan 12, 2020</span>|
                        <span> Tags:
                            Perl
                        </span>
                    </div>
                </div>
            </div>
        </div>
    </div>
</section>

<section class="single-post">
    <div class="container">
        <div class="row">
            <div class="col-md-12">
                
                <div style="text-align: center" class="post-img">
                    <img class="img-fluid" alt="" src="https://perlweeklychallenge.org/images/blog/p5-review-challenge-041.jpg">
                </div>
                
                <div style="text-align: justify" class="post-content">
                    

<hr />

<hr />

<p>Continues from <a href="/blog/review-challenge-040/"><strong>previous week</strong></a>.</p>

<p>Feel free to <a href="https://github.com/manwar/perlweeklychallenge"><strong>submit a merge request or open a ticket</strong></a> if you found any issues with this post. We highly appreciate and welcome your feedback.</p>

<p>For a quick overview, go through the <a href="/blog/perl-weekly-challenge-041/"><strong>original tasks</strong></a> and <a href="/blog/recap-challenge-041/"><strong>recap</strong></a> of the weekly challenge.</p>

<p>Additional feedback to our Perl Weekly Challenge’s <a href="https://twitter.com/perlwchallenge?lang=en"><strong>Twitter account</strong></a> is much appreciated.</p>

<hr />

<hr />

<h2 id="task-1">Task #1</h2>

<hr />

<hr />

<h3 id="write-a-script-to-display-attractive-number-between-1-and-50">Write a script to display <strong>attractive number</strong> between 1 and 50.</h3>

<blockquote>
<p>A number is an <em>attractive number</em> if the number of its prime factors is also prime number.</p>
</blockquote>

<p>The number <strong>20</strong> is an <strong>attractive number</strong>, whose prime factors are <strong>2</strong>, <strong>2</strong> and <strong>5</strong>. The total prime factors is <strong>3</strong> which is also a <strong>prime number</strong>.</p>

<hr />

<h2 id="adam-russell">Adam Russell</h2>

<p>I noticed the use of <strong>redo</strong> in <strong>Adam</strong>&rsquo;s work of brilliance.</p>

<pre><code class="language-perl">use strict;
use warnings;

sub prime_factor{
    my $x = shift(@_);
    my @factors;
    for (my $y = 2; $y &lt;= $x; $y++){
        next if $x % $y;
        $x /= $y;
        push @factors, $y;
        redo;
    }
    return @factors;
}

MAIN:{
    for my $n (1 .. 50){
        my @factors = prime_factor($n);
        print &quot;$n (&quot; . join(&quot;, &quot; , @factors) . &quot;)\n&quot; if(prime_factor(scalar @factors) == 1);
    }
}
</code></pre>

<hr />

<h2 id="andrezgz">Andrezgz</h2>

<p><strong>Andrezgz</strong> definition of method <strong>is_prime()</strong> is the main attraction of the solution.</p>

<pre><code class="language-perl">#!/usr/bin/perl

use strict;
use warnings;

my $upto = shift || 50;

foreach (1 .. $upto){
    print $_ . ' ' if is_prime( scalar prime_decomp($_) );
}


sub prime_decomp {
    my $n = shift;

    my @prime_decomp;

    foreach my $prime ( prime_factors($n) ){
        do {
            $n /= $prime;
            push @prime_decomp, $prime;
        } while ($n % $prime == 0);
    }

    return @prime_decomp;
}


sub prime_factors {
    my $n = shift;
    return if $n &lt;= 1;
    my @r = grep {$n % $_ == 0 &amp;&amp; is_prime($_)} (2 .. $n/2); #get prime divisors
    return @r ? @r : ($n); # number is prime if no prime divisors were found
}

sub is_prime {
    my $n = shift;
    return if $n &lt;= 1;
    #every composite number has a prime factor less than or equal to its square root.
    return 1 == grep {$n % $_ == 0} (1 .. sqrt $n);
}
</code></pre>

<hr />

<h2 id="burkhard-nickels">Burkhard Nickels</h2>

<p><strong>Burkhard</strong> didn&rsquo;t hesitate to go full on with his solution.</p>

<pre><code class="language-perl">my $res = calculate_primes(50);
print &quot;Prime Numbers: &quot;, Dumper($res), &quot;\n&quot;;

my @numbers = (1 .. 50);
my @primes = (2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53);
print &quot;Prime Numbers: &quot;, Dumper(\@primes), &quot;\n&quot;;

print &quot;Attractive Numbers:\n&quot;;

foreach my $nbr (1 .. 50) {
    my @res;
    my %tree;
    my ($x,$y) = (-1,0);
    print &quot;TEST $nbr ---&gt; \n&quot;;
    nr_recursive($nbr,\@res,$x,\$y,\%tree);
    # print &quot;Ergebnis: &quot;, Dumper(\@res), &quot;\n&quot;;
    $Data::Dumper::Indent=1;
    # print &quot;Ergebnis: &quot;, Dumper(\%tree), &quot;\n&quot;;
    my $flat = flatten(\%tree);
    # print &quot;Flat: &quot;, Dumper($flat), &quot;\n&quot;;
    is_attractive_number($flat);
    print &quot;\n&quot;;
}

sub is_attractive_number {
    my ($flat) = @_;
    foreach my $k (keys %$flat) {
        my $attr_nbr = 1;
        my @tmp = split(/\./,$k);
        foreach my $i (@tmp) {
            if( ! is_prime($i) ) { $attr_nbr = 0; }
        }
        if($attr_nbr) {
            print &quot;   $k =&gt; $flat-&gt;{$k} Attractive Number&quot;;
            if( is_prime($flat-&gt;{$k}) ) {
                print &quot;(Number Factors $flat-&gt;{$k} is Prime)\n&quot;;
            } else { print &quot;\n&quot;; }
        }
        else {
            # print &quot;$k =&gt; $flat-&gt;{$k}\n&quot;;
        }
    }
}

sub nr_recursive {
    my ($number,$res,$x,$y,$tree) = @_;
    $x++;
    # my $space = &quot; &quot; x ($x * 2);
    # print &quot;$space X+($x/$$y)\n&quot;;
    # print &quot;$space IN: $number ($x/$y)\n&quot;;
    my $loop;
    if($x == 0) { $loop = $number-1; }
    else { $loop = $number; }
    my $found_count=0;
    foreach my $j ((2 .. $loop)) {
        # print &quot;$space LO: $number ($x/$y)\n&quot;;
        my $div = $number/$j;         # Division with every whole number.
        my $nr  = int($div);
        my $rst = $number%$j;
        # print &quot;$space - $j ($div,$nr,$rst)\n&quot;;
        if( ! $rst ) {           # Result is whole number
            $found_count++;
            # print &quot;$space =&gt; $j ($x/$$y - Next $nr)\n&quot;;
            $res-&gt;[$$y][$x] = $j;

            if($nr == 1) { $tree-&gt;{$j} = $x+1; }
            else { $tree-&gt;{$j} = {}; }

            if($$y &gt; 0) {
                foreach my $k (0 .. $x-1) {
                    $res-&gt;[$$y][$k] = $res-&gt;[$$y-1][$k];
                    # print &quot;$space =&gt; $res-&gt;[$$y-1][$k] ($k/$$y)\n&quot;;
                }
                # $$y++; print &quot;$space Y+($x/$$y)\n&quot;;
            }

            nr_recursive($nr,$res,$x,$y,$tree-&gt;{$j});
            # if($found_count &gt; 1) {
            #   $$y++; print &quot;$space Y+($x/$$y)\n&quot;;
            # }
            $$y = $#$res + 1; # print &quot;$space Y+($x/$$y)\n&quot;;
        }
    }
    $x--; # print &quot;$space X-($x/$$y)\n&quot;;
}

sub is_prime {
    my ($nr) = @_;
    my $prime=1;
    foreach my $j ((2 .. $nr-1)) { # Not dividing by 1 or the same number
        my $div = $nr/$j;           # Division with every whole number.
        my $nr  = int($div);
        my $rst = $nr%$j;
        if( ! $rst ) {             # If no Rest
            $prime=0;              # it is NO prime number
            last;
        }
    }
    return $prime;
}

sub calculate_primes {
    my ($max) = @_;

    my @result;
    my $prime=1;
    foreach my $i ((2 .. $max)) {
        foreach my $j ((2 .. $i)) {
            my $div = $i/$j;         # Division with every whole number.
            my $nr  = int($div);
            my $rst = $i%$j;
            if( ! $rst and $i!=$j) { # If no Rest and not devided by same.
                $prime=0;            # it is NO prime number
                last;
            }
        }
        if($prime) { push(@result,$i); } # Prime Number
        else { $prime=1; }
    }
    return \@result;
}
</code></pre>

<hr />

<h2 id="colin-crain">Colin Crain</h2>

<p><strong>Colin</strong>&rsquo;s own creation <strong>decompose()</strong> is really fun to read.</p>

<pre><code class="language-perl">use warnings;
use strict;
use feature &quot;:5.26&quot;;

my $max = shift @ARGV // 50;

my @primes = make_prime_list($max);
my %primehash = map { $_ =&gt; 1 } @primes;

for (2..$max) {
    my @decomp = decompose($_, \@primes);
    printf &quot;%-4d--&gt; %-20s  %s\n&quot;, $_, (join ', ', @decomp),
            (exists $primehash{(scalar @decomp)}) ? &quot;$_ is attractive&quot; : &quot;&quot; ;
}

sub make_prime_list {
## creates a list of all primes less than or equal to a given number
    my $max = shift;
    my @output = (2);
    CANDIDATE: for(  my $candidate = 3;  $candidate &lt;= $max;  $candidate += 2  ) {
        my $sqrt_candidate = sqrt( $candidate );
        for(  my $test = 3; $test &lt;= $sqrt_candidate; $test += 2  ) {
            next CANDIDATE if $candidate % $test == 0;
        }
        push @output, $candidate;
    }
    return @output;
}

sub decompose {
## given a number and a list of primes less than n/2,
## returns an array list of prime decomposition factors of the number
    my ($num, $primes) = @_;
    my @decomp;
    my @primelist = $primes-&gt;@*;
    my $prime = shift @primelist;

    while ( $prime &lt;= $num ) {
        while ($num % $prime == 0) {
            $num = $num / $prime;
            push @decomp, $prime;
        }
        last if scalar @primelist == 0;
        $prime = shift @primelist;
    }
    return @decomp;
}
</code></pre>

<hr />

<h2 id="duncan-c-white">Duncan C. White</h2>

<p><strong>Duncan</strong> invented his own library <a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-041/duncan-c-white/perl5/MakePrimes.pm"><strong>MakePrimes</strong></a> and <a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-041/duncan-c-white/perl5/PrimeFactors.pm"><strong>PrimeFactors</strong></a> to solve the task. Highly Recommended.</p>

<pre><code class="language-perl">use v5.10;  # to get &quot;say&quot;
use strict;
use warnings;
use Function::Parameters;

use lib qw(.);  # I hate this!
use MakePrimes;
use PrimeFactors;

die &quot;Usage: ch-1.pl [N//50]\n&quot; if @ARGV&gt;1;

my $n = shift // 50;

my @primes = primes_upto( $n );
my %isprime = map { $_ =&gt; 1 } @primes;

foreach my $x (2..$n)
{
    my @factors = prime_factors( $x, @primes );
    my $nf = @factors;
    next unless $isprime{$nf};
    say &quot;$x is an attractive number, factors are: &quot;, join(',',@factors),
        &quot;, number factors $nf is prime&quot;;
}
</code></pre>

<hr />

<h2 id="e-choroba">E. Choroba</h2>

<p><strong>Choroba</strong>, once again took the help from <strong>CPAN</strong> module <strong>Math::Prime::Util</strong>. The end result is nice and clean solution.</p>

<pre><code class="language-perl">#! /usr/bin/perl
use warnings;
use strict;
use feature qw{ say };

use Math::Prime::Util qw{ factor is_prime };

sub is_attractive {
    my ($n) = @_;
    is_prime(factor($n))
}

say for grep is_attractive($_), 1 .. 50;
</code></pre>

<hr />

<h2 id="javier-luque">Javier Luque</h2>

<p><strong>Javier</strong> also followed the same path as <strong>Choroba</strong>.</p>

<pre><code class="language-perl">#!/usr/bin/perl
# Test: ./ch-1.pl
use strict;
use warnings;
use Math::Prime::Util qw /factor is_prime/;
use feature qw /say/;

for my $i (1..50) {
    my @factors = factor($i);
    say $i if (is_prime(scalar(@factors)));
}
</code></pre>

<hr />

<h2 id="laurent-rosenfeld">Laurent Rosenfeld</h2>

<p><strong>Laurent</strong> came up with his own implementation of the method <strong>prime_factors()</strong>.</p>

<pre><code class="language-perl">#!/usr/bin/perl
use strict;
use warnings;
use feature qw/say/;
use constant PRIMES =&gt; (2, 3, 5, 7);

sub prime_factors {
    my $num = shift;
    my $origin_num = $num;
    my @factors;
    for my $div (PRIMES) {
        while ($num % $div == 0) {
            push @factors, $div;
            $num /= $div;
        }
        return @factors if $num == 1;
    }
    push @factors, $num unless $num == $origin_num;
    return @factors;
}

my %primes = map { $_ =&gt; 1 } PRIMES;
say &quot;$_: &quot;, join &quot; &quot;, prime_factors($_) for
grep exists $primes{scalar prime_factors($_)}, 1..50;
</code></pre>

<hr />

<h2 id="lubos-kolouch">Lubos Kolouch</h2>

<p><strong>Lubos</strong> introduced me to the method <strong>count_prime_factors()</strong> from the <strong>CPAN</strong> module <strong>Math::Factor::XS</strong>. The power of <strong>CPAN</strong> makes the solution looks nice and clean.</p>

<pre><code class="language-perl">use strict;
use warnings;
use Math::Factor::XS qw/count_prime_factors/;
use Math::Prime::XS qw/is_prime/;

sub is_attractive {
    my $what = shift;

    return is_prime(count_prime_factors($what));
}

# TESTS

use Test::More;

is(is_attractive(20),1);
is(is_attractive(23),'');
is(is_attractive(28),1);
is(is_attractive(256),'');

done_testing;
</code></pre>

<hr />

<h2 id="roger-bell-west">Roger Bell_West</h2>

<p>Like many members, <strong>Roger</strong> also took the help of <strong>CPAN</strong> module <strong>Math::Prime::Util</strong>.</p>

<pre><code class="language-perl">#! /usr/bin/perl

use strict;
use warnings;

use Math::Prime::Util qw(factor is_prime);

foreach my $c (1..50) {
  if (is_prime(scalar factor($c))) {
    print &quot;$c\n&quot;;
  }
}
</code></pre>

<hr />

<h2 id="ruben-westerberg">Ruben Westerberg</h2>

<p><strong>Ruben</strong> took the pain and defined his own method <strong>prime()</strong>, which reminded me of my early days.</p>

<pre><code class="language-perl">#!/usr/bin/env perl
use strict;
use warnings;
for (1..50) {
    my @a=primeFactors($_);
    print &quot;Attractive number $_: prime factors @a\n&quot; if (prime(scalar @a));
}
sub prime {
    my $n=shift;
    if ($n &lt;= 3 ) {
        return $n &gt; 1;
    }
    elsif ($n % 2 == 0 or $n % 3 ==0 ) {
        return 0;
    }
    my $i=5;
    while ($i**2 &lt;= $n) {
        if ( $n % $i ==0 or $n % ($i+2) == 0 ) {
                return 0;
        }
        $i+=6;
    }
    return 1;
}

sub primeFactors {
    my @factors;
    my $i=shift;
    for (1..$i/2) {
        if ($i%$_ == 0 and prime $_ ) {
            my $b=$i/$_;
            push @factors, $_;
            if (prime $b) {
                push @factors, $b;
            }
            else {
                push @factors, primeFactors($b);
            }
            last;
        }
    }
    @factors;
}
</code></pre>

<hr />

<h2 id="ryan-thompson">Ryan Thompson</h2>

<p>The main attractioon of <strong>Ryan</strong> solution was the introduction of <strong>Wilson Theorem</strong>.</p>

<pre><code class="language-perl">#!/usr/bin/env perl

use 5.010;
use warnings;
use strict;
no warnings 'uninitialized';

# Here is how I'd normally tackle this problem:
# use Math::Prime::Util ':all';
# say for grep { is_prime( factor($_) ) } 1..50;

my @primes50   = primes_to(50);
my %primes50   = map  { $_ =&gt; 1 } @primes50;
my @attractive = grep { $primes50{ prime_div_mult($_) } } 1..50;

say for @attractive;

# Check our results against https://oeis.org/A063989
if ($ARGV[0] eq '--test') {
    use Test::More;
    my @oeis = (4, 6, 8, 9, 10, 12, 14, 15, 18, 20, 21, 22, 25, 26, 27, 28,
                30, 32, 33, 34, 35, 38, 39, 42, 44, 45, 46, 48, 49, 50);
    is_deeply \@attractive, \@oeis, &quot;Matches published sequence&quot;;
    done_testing;
}

# Unmodified Wilson's theorem is terrible, unless you only need tiny primes!
# Please, I beg you, use Math::Prime::Util or similar in any real code. :-)
# N is prime iff (N - 1)! % N == 0
sub primes_to {
    use bigint;
    my $N = shift;
    my $fac = 1;
    my @r;
    for my $n (2..$N) {
        $fac *= $n - 1;

        push @r, $n unless ($fac + 1) % $n;
    }

    @r;
}

# Get prime divisors in multiplicity (e.g., 48 = 2, 2, 2, 2, 3)
sub prime_div_mult {
    my $n = shift;
    my @div;
    for my $div (@primes50) {
        last if $div &gt; $n;
        while ($n % $div == 0) {
            $n /= $div;
            push @div, $div;
        }
    }

    @div;
}
</code></pre>

<hr />

<h2 id="saif-ahmed">Saif Ahmed</h2>

<p><strong>Saif</strong> made good use of <strong>dispatch table</strong>. The best part of the solution is the centralisation of core functions.</p>

<pre><code class="language-perl">initialise();
getAttractive(20,&quot;method2&quot;);
benchmark();

sub getAttractive{                     # gets attractive numbers
    my $n=shift;                       # how many to get
    $method=shift //&quot;method1&quot;;         # which method to use or use method1
    print &quot;Using $method the first $n attractive numbers are:-\n&quot;;

    my $candidate=0;                   # number to test for attractiveness

    while ($n--) {
                                       # increment $candidate until attractive found
        while (!${$method}{isAttractive}-&gt;(++$Candidate)){};
                                       # display attarctive numbers and factors
        print &quot;$Candidate is attractive; Factors are &quot;,
               (join &quot;,&quot;,(defined ${$method}{factors})    ?   # if a cache of factors exists
                     @{${$method}{factors}  -&gt;[$Candidate]} : # retrieve from cache or
                     @{${$method}{factorise}-&gt;($Candidate)} ),# just factorise again
                      &quot;\n&quot;;
    }
}


sub initialise{

# Method1 caches nothing. The factorise function return the list of factors, or
# just the number itself if it is prime

    %method1=(                    # &quot;our&quot; used to make it available
                                      # outsibe the initialise subroutine
       factorise=&gt;sub {
           my $wn=$number=shift;      # the number to test is loaded
           my @factorsList=();        # the aray of factors found
           my $test=2;                # start search with 2 as a factor
           my $limit=sqrt($wn+1);        # continue to a reasonable limit
           while ($test &lt; $limit){    # until limit passed
             if  ($wn % $test){       # if not a factor (i.e. $wn % $test is not zero
                 $test++;             # test next number
                 $test++ unless $test==3;  # ensure that after 2 only odd numbers are tested
             }
             else{                    # factor found
              push @factorsList,$test;# store factor in our list
              $wn=$wn/$test;          # and factorise the rest...
              $limit=sqrt($wn+1)      # ...resetting limit accordingly
             }
           }
          return [@factorsList,$wn];  # return all factors found (including the last prime)
      },

      isPrime=&gt;sub{                   # all methods retun the number if no factors are found
        my $t=shift;
        return 0 if $t&lt;2;             # 0 and 1 are not prime numbers
        return $method1{ numberOfFactors}-&gt;($t)==1?1:0;
      },

      numberOfFactors=&gt;sub{           # list of factors obtained by factorise
        my $t=shift;
        return scalar @{$method1{factorise}-&gt;($t)};
        },

      isAttractive=&gt;sub {             # tests that numberOfFactors() isPrime()
            my $t=shift;
            return $method1{isPrime}-&gt;( $method1{numberOfFactors}-&gt;( $t ) );
        },

    );

# Method 2 caches the factors.  Because the factors of previously tested numbers are
# retained only the smallest factor is required, and it merely retrieves the rest
# from the cache

    %method2=(
       factorise=&gt;sub {
           my $number=shift;           # the number to test is loaded
                                       # if number already has ached factors, retieve from cache
           return  $method2{factors}-&gt;[$number] if (defined $method2{factors}-&gt;[$number]) ;
           my $test=2; $limit=sqrt($number+1);  # as before start with 2 and set limits
           while (($test &lt; $limit)&amp;&amp;($number % $test)){
                 $test++;
                 $test++ unless $test==3;
           }
           if ($test&lt;$limit){           # found the smallest prime factor.
                                        # Because of caching, all the other factors have
                                        # already been found, no need to search.
               $method2{factors}-&gt;[$number]=  [$test,@{$method2{factors}-&gt;[$number/$test]}]
           }
           else{                        #otherwise this is a prime number, store in cache
               $method2{factors}-&gt;[$number]=  [$number];
           }
           return  $method2{factors}-&gt;[$number];
        },

      isPrime=&gt;sub{
        my $t=shift;
        return 0 if $t&lt;2;
        return $method2{numberOfFactors}-&gt;($t)==1?1:0;
      },

      numberOfFactors=&gt;sub{              # retrieve from cache
        my $t=shift;
        return scalar @{$method2{factors}-&gt;[$t]};
        },

       isAttractive=&gt;sub{                # tests that numberOfFactors() isPrime()
            my $t=shift;
            return $method2{isPrime}-&gt;( $method2{numberOfFactors}-&gt;( $t ) );
        },

      factors=&gt;[],                       # cache of factors
    );


# Method 3 caches factors and primes.
# the primes cache is a hash, with each prime stored as key, with next key as its value
# e.g 2=&gt;3,3=&gt;5,5=&gt;7,7=&gt;11,11=&gt;-1,largest=&gt;11. this allows quick retrieval of the next
# found poetntial prime factor.

   %method3=(
       factorise=&gt;sub{
           my $number=shift;
           return  $method3{factors}-&gt;[$number] if (defined $method3{factors}-&gt;[$number]) ;
           my $test=2; my $limit=sqrt($number+1);
           while (($test &lt; $limit)&amp;&amp;($number % $test)){
                 $test=$method3{primes}-&gt;{$test};        # test larger and larger primes
           }
           if (($number % $test)||($number/$test ==1)){   # no old prime factor found
                   # number must be a new prime larger than one previously encountered
                   # this is stored in a hash, replacing previous largest prime
                   # this method of setting multiple values in a hash is not possible with &quot;strict&quot;
               @method3{primes}-&gt;{$number,$method3{primes}-&gt;{&quot;largest&quot;},{&quot;largest&quot;} }=(-1,$number,$number);
               $method3{factors}-&gt;[$number]= [$number];
           }
           else{
               $method3{factors}-&gt;[$number]=[$test,@{$method3{factors}-&gt;[$number/$test]}];
           }
           return $method3{factors}-&gt;[$number];
       },

      isPrime=&gt;sub{                                     # check primes from the hash cache
        my $t=shift;
        return 0 if $t&lt;2;
        return defined $method3{primes}-&gt;{$t}?1:0;
      },

      numberOfFactors=&gt;sub{
        my $t=shift;
        return scalar @{$method3{factors}-&gt;[$t]};        # check factors from the cache array
        },

       isAttractive=&gt;sub{                # tests that numberOfFactors() isPrime()
            my $t=shift;
            return $method3{isPrime}-&gt;( $method3{numberOfFactors}-&gt;( $t ) );
        },

      primes =&gt;{2=&gt;3,3=&gt;5,5=&gt;7,7=&gt;11,11=&gt;-1,largest=&gt;11},
      factors=&gt;[],
    );

    for my $method (&quot;method2&quot;,&quot;method3&quot;){
        for (1..100){
          ${$method}{factorise}-&gt;($_)
        }
    }
}

# This routine benchmarks the three methods twice, demonstrating the
# effectiveness of caching at first and subsequent passes.
sub benchmark{
    use Time::HiRes qw ( time);
    my $start;
    for (1,2){
        print &quot;Benchmark pass $_\n&quot;;
        for my $end (1000,10000,100000){

            for my $method (1..3){
                $start=time();
                for (1..$end){
                  ${&quot;method$method&quot;}{factorise}-&gt;($_)
                }
                ${&quot;duration$method&quot;}= int (1000*(time()-$start));
            }
            print &quot;With $end factorisations: Method1 $duration1 ms   Method2 $duration2 ms  Method3 $duration3 ms \n&quot;;
        }
    }
}
</code></pre>

<hr />

<h2 id="ulrich-rieke">Ulrich Rieke</h2>

<p><strong>Ulrich</strong> setup his own helper methods <strong>isPrime()</strong>, <strong>isAttractive()</strong> and <strong>primeFactors()</strong>. With the helper methods, the end result looks elegant.</p>

<pre><code class="language-perl">#!/usr/bin/perl ;
use strict ;
use warnings ;

sub isPrime {
  my $number = shift ;
  if ( $number == 1 ) {
      return 0 ;
  }
  if ( $number == 2 ) {
      return 1 ;
  }
  for ( my $i = 2 ; $i &lt; int ( $number / 2 + 1 ) ; $i++ ) {
      if ( $number % $i == 0 ) {
    return 0 ;
    last ;
      }
  }
  return 1 ;
}

sub isAttractive {
  my $number = shift ;
  my @primeFactors = primeFactors( $number ) ;
  return isPrime( scalar @primeFactors ) ;
}

sub primeFactors {
  my $num = shift ;
  if ( $num == 1 ) {
      return ( ) ;
  }
  my $current = 2 ;
  my @primeFactors ;
  while ( $num != 1 ) {
      if ( $num % $current == 0 ) {
    push @primeFactors , $current ;
    $num /= $current ;
      }
      else {
    do {
        $current++ ;
    } while ( not isPrime( $current ) ) ;
      }
  }
  return @primeFactors ;
}

my @attractives = grep { isAttractive( $_ ) } (1..50) ;
foreach my $num ( @attractives ) {
  print &quot;$num &quot; ;
}
print &quot;\n&quot; ;
</code></pre>

<hr />

<h2 id="walt-mankowski">Walt Mankowski</h2>

<p><strong>Walt</strong> used the <strong>Sieve of Eratosthenes</strong> to find the primes. He is the only member who used this hack, very interesting.</p>

<pre><code class="language-perl">#!/usr/bin/env perl
use strict;
use warnings;
use feature qw(:5.30);
use experimental qw(signatures);

my $N = 50;

# Find the primes up to $n using the Sieve of Eratosthenes
sub primes_up_to($n) {
    my %primes = map { $_ =&gt; 1 } 2..$n;
    for my $i (2..sqrt($n)) {
        if (defined $primes{$i}) {
            for (my $j = $i**2; $j &lt;= $n; $j += $i) {
                delete $primes{$j};
            }
        }
    }
    return %primes;
}

sub prime_factors($n, %primes) {
    my @factors;

    for my $i (sort { $a&lt;=&gt;$b } keys %primes) {
        last if $i &gt; $n;
        while ($n % $i == 0) {
            push @factors, $i;
            $n /= $i;
        }
    }
    return @factors;
}

my %primes = primes_up_to($N);
for my $i (1..$N) {
    say $i if defined $primes{scalar prime_factors($i, %primes)};
}
</code></pre>

<hr />

<h2 id="wanderdoc">Wanderdoc</h2>

<p><strong>Wanderdoc</strong> home grown <strong>is_prime()</strong> is really cool and on top of <strong>print_attactive()</strong> was like icing on the cake.</p>

<pre><code class="language-perl">use strict;
use warnings FATAL =&gt; qw(all);

my $N = shift || 50; # or die &quot;How much is the number?\n&quot;;

for ( 1 .. $N )
{
     print_attractive($_);
}

sub print_attractive
{
     my $n = $_[0];

     my $n_orig = $n;
     my $counter = 0;

     my @factors;

     # Old nice one-liner for prime factorization:
     # perl -le &quot;$x = shift; for $k (2 .. $x/2) {$x%$k or (print $k and $x /= $k and redo) }&quot;


     for my $k ( 2 .. $n/2 )
     {
          0 == $n % $k and
               $factors[$counter++] = $k and
               $n /= $k and redo;
     }
     print join(&quot; &quot;, $n_orig, '=', join(' * ',@factors)), $/ if is_prime($counter);
}

sub is_prime
{
     my $n = $_[0];
     if ($n &lt;= 3) {return $n &gt; 1 ? 1 : 0;}
     elsif (0 == $n % 2 or 0 == $n % 3) {return 0;}

     else
     {
          my $i = 5;
          while ( $i * $i &lt;= $n )
          {
               if ( 0 == $n % $i or 0 == $n % ($i + 2))
               {
                    return 0;
               }
               $i += 6;
          }
     }
    return 1;
}
</code></pre>

<hr />

<hr />

<h2 id="task-2">Task #2</h2>

<hr />

<hr />

<h3 id="write-a-script-to-display-first-20-leonardo-numbers-please-checkout-wiki-page-https-en-wikipedia-org-wiki-leonardo-number-for-more-information">Write a script to display first 20 <strong>Leonardo Numbers</strong>. Please checkout <a href="https://en.wikipedia.org/wiki/Leonardo_number">wiki page</a> for more information.</h3>

<p>For example:</p>

<h5 id="l-0-1">L(0) = 1</h5>

<h5 id="l-1-1">L(1) = 1</h5>

<h5 id="l-2-l-0-l-1-1-3">L(2) = L(0) + L(1) + 1 = 3</h5>

<h5 id="l-3-l-1-l-2-1-5">L(3) = L(1) + L(2) + 1 = 5</h5>

<p>and so on.</p>

<hr />

<h2 id="adam-russell-1">Adam Russell</h2>

<p><strong>Adam</strong> tried to keep it simple and very well presented end result.</p>

<pre><code class="language-perl">use strict;
use warnings;
use constant NUMBERS =&gt; 20;

my $numbers = NUMBERS;
my @leonardo = (1, 1);
while($numbers){
    if((NUMBERS - $numbers) &lt; 2){
        print &quot;L(&quot; . (NUMBERS - $numbers) . &quot;) = &quot; . $leonardo[-1] . &quot;\n&quot;;
    }
    else{
        my $leonardo = $leonardo[-1] + $leonardo[-2] + 1;
        print &quot;L(&quot; . (NUMBERS - $numbers) . &quot;) = $leonardo\n&quot;;
        push @leonardo, $leonardo;
    }
    $numbers--;
}
</code></pre>

<hr />

<h2 id="andrezgz-1">Andrezgz</h2>

<p><strong>Andrezgz</strong> kept it simple and easy to read.</p>

<pre><code class="language-perl">#!/usr/bin/perl

use strict;
use warnings;
use Memoize;

memoize('leo');

my $upto = shift || 20;
print leo($_).' ' for (0 .. --$upto);

sub leo {
    my $n = shift;
    return $n &lt;= 1 ? 1 : leo($n-1) + leo($n-2) + 1;
}
</code></pre>

<hr />

<h2 id="burkhard-nickels-1">Burkhard Nickels</h2>

<p><strong>Burkhard</strong> also took the <strong>recursive</strong> route.</p>

<pre><code class="language-perl">print &quot;Function leonardo1() with recursive function call ...\n&quot;;
foreach my $i (0 .. $max) {
    my $cnt = 0;
    my $nr = leonardo1($i,\$cnt);
    print &quot;L($i) = $nr ($cnt)\n&quot;;
}

sub leonardo1 {
    my ($nr,$cnt) = @_;
    $$cnt++;
    if( $nr == 0 or $nr == 1 ) { return 1; }
    else {
        return leonardo1($nr-1,$cnt) + leonardo1($nr-2,$cnt) + 1;
    }
}
</code></pre>

<hr />

<h2 id="colin-crain-1">Colin Crain</h2>

<p><strong>Colin</strong> presented the result nicely laid out.</p>

<pre><code class="language-perl">use warnings;
use strict;
use feature &quot;:5.26&quot;;

my $quan = shift @ARGV // 20;

say &quot;the first $quan Leonardo numbers:&quot;;
say &quot;&quot;;
say &quot;index  |  number&quot;;
say &quot;-------+--------&quot;;

my $i;
printf &quot;%-2d        %d\n&quot;, ++$i, $_ for make_leonardo($quan)-&gt;@*;

sub make_leonardo {
##  construct a list of the first n Leonardo numbers
##  requires no recursion if we have the growing list to refer to
    my $quan  = shift;
    my $list  = [1];
    push $list-&gt;@*, 1 if $quan &gt; 1;                         ## now [1,1]
    while ( scalar $list-&gt;@* &lt;= $quan-1 ) {
        push $list-&gt;@*, $list-&gt;[-1] + $list-&gt;[-2] + 1;      ## sum last two elements + 1
    }
    return $list;
}
</code></pre>

<hr />

<h2 id="duncan-c-white-1">Duncan C. White</h2>

<p><strong>Duncan</strong> kept it simple without any noise.</p>

<pre><code class="language-perl">use v5.10;  # to get &quot;say&quot;
use strict;
use warnings;
#use Data::Dumper;

die &quot;Usage: ch-2.pl [N//20]\n&quot; if @ARGV&gt;1;
my $n = shift // 20;

my %l;
$l{0} = 1;
$l{1} = 1;
say &quot;leonardo(0) = $l{0}&quot;;
say &quot;leonardo(1) = $l{1}&quot;;

foreach my $i (2..$n-1)
{
    $l{$i} = $l{$i-2} + $l{$i-1} + 1;
    say &quot;leonardo($i) = $l{$i}&quot;;
}
</code></pre>

<hr />

<h2 id="e-choroba-1">E. Choroba</h2>

<p><strong>Choroba</strong> blown me away with his hack of <strong>shift</strong> at the end.</p>

<pre><code class="language-perl">#! /usr/bin/perl
use warnings;
use strict;
use feature qw{ say };

my @last2 = (1, 1);
for my $n (0 .. 20) {
    say &quot;L($n) = &quot;, $last2[0];
    push @last2, $last2[0] + $last2[1] + 1;
    shift @last2;
}
</code></pre>

<hr />

<h2 id="javier-luque-1">Javier Luque</h2>

<p><strong>Javier</strong> made use of <strong>recursive</strong> function.</p>

<pre><code class="language-perl">#!/usr/bin/perl
# test: ./ch-2.pl
use strict;
use warnings;
use feature qw /say/;

for my $i (1..20) {
    say &quot;L($i) = &quot; . leonardo($i);
}

# Leonardo
sub leonardo {
    my $n = shift;
    return 1 if ($n == 0 or $n == 1);

    # Recursive
    return (
        leonardo($n-1) +  # l(n-1)
        leonardo($n-2) +  # l(n-2)
        1                 # 1
    );
}
</code></pre>

<hr />

<h2 id="laurent-rosenfeld-1">Laurent Rosenfeld</h2>

<p><strong>Laurent</strong> didn&rsquo;t blink once before getting the desired result.</p>

<pre><code class="language-perl">use strict;
use warnings;
use feature qw /say/;

my @leonardo = (1, 1);
for my $i (1..18) {
    push @leonardo, $leonardo[-1] + $leonardo[-2] + 1;
}
say &quot;@leonardo&quot;;
</code></pre>

<hr />

<h2 id="lubos-kolouch-1">Lubos Kolouch</h2>

<p>It can&rsquo;t be any simpler than this, thanks <strong>Lubos</strong>.</p>

<pre><code class="language-perl">use strict;
use warnings;
use Data::Dumper;

my @l = (1,1);

for (2..19) {
    $l[$_] = $l[$_-2] + $l[$_-1]+1;
}

warn Dumper @l;
</code></pre>

<hr />

<h2 id="roger-bell-west-1">Roger Bell_West</h2>

<p><strong>Roger</strong> followed the easy path. However while printing the result, he used the <strong>negative index</strong> hack, very smart.</p>

<pre><code class="language-perl">#! /usr/bin/perl

use strict;
use warnings;

my @stack;

foreach my $i (0..19) {
  if ($i&lt;2) {
    push @stack,1;
  } else {
    push @stack,1+$stack[-1]+$stack[-2];
    shift @stack;
  }
  print $stack[-1],&quot;\n&quot;;
}
</code></pre>

<hr />

<h2 id="ruben-westerberg-1">Ruben Westerberg</h2>

<p><strong>Ruben</strong> made use of <strong>state</strong> to cache the result. I wonder if it is any better than <strong>Memoize</strong>.</p>

<pre><code class="language-perl">#!/usr/bin/env perl
use strict;
use warnings;
use v5.26;

print map { &quot;n: $_ l: &quot;.l($_).&quot;\n&quot;} 0..19;

sub l {
    my $i=shift;
    state @cache=(1,1);
    push @cache, $cache[-1]+$cache[-2]+1 while(! defined($cache[$i]));
    $cache[$i];
}
</code></pre>

<hr />

<h2 id="ryan-thompson-1">Ryan Thompson</h2>

<p><strong>Ryan</strong> showed how the use of <strong>Memoize</strong> can be so powerful. Highly Recommended.</p>

<pre><code class="language-perl">use 5.010;
use warnings;
use strict;
use Memoize; # This is a core module

# Use core Perl module &quot;Memoize&quot; to store results of previous calls
# Note this is the exact same code as leo_no_memo, apart from the memoize call
sub leo_memoize {
    my $n = shift;
    return 1 if $n &lt; 2;
    1 + leo_memoize($n - 1) + leo_memoize($n - 2);
}
memoize 'leo_memoize';

# In this case doing memoization ourselves is really easy, and turns out
# to be a surprising 777% faster than Memoize, so it's my preference.
{
    my @leo = (1, 1);
    sub leo_my_memo {
        my $n = shift;
        $leo[$n] //= 1 + leo_my_memo($n - 1) + leo_my_memo($n - 2);
    }
}

# Building up the list iteratively is also a good solution
sub leo_to_n {
    my @r = (1, 1);
    push @r, $r[-1] + $r[-2] + 1 for 2..$_[0];
    @r;
}

say for leo_to_n(20);
</code></pre>

<hr />

<h2 id="saif-ahmed-1">Saif Ahmed</h2>

<p><strong>Saif</strong> never hesitates caching whereever to speed up the performance. I simply love his work.</p>

<pre><code class="language-perl">use strict;
use warnings;
use feature 'say';

# hash containing known Leornado numbers.  It is prepopulated with
# L(0) and L(1), but more added as discovered by L().
my %leonardos=(0=&gt;1,1=&gt;1,);

# Golden ratio numbers required for the closedForm() method
my $gr1=(1+sqrt(5))/2;
my $gr2=(1-sqrt(5))/2;

say  &quot;$_) &quot;, L($_)  for (0..20);  # find the first 21 leonardo numbers

# This subroutines uses no caching and rapidly slowss after about
# 25 retrievals.
sub l{
  my $ln=shift;
  return $ln &lt; 2?1:l($ln-2)+l($ln-1)+1;
}

#  This retrieves Leonardo numbers from cache where needed
sub L{
  my $ln=shift;

  # find and store L(N) in the hash, if it does not exist already
  unless (exists  $leonardos{$ln}) {
      $leonardos{$ln}=L($ln-2)+L($ln-1)+1
  };
   #return stored L(N)
  return $leonardos{$ln};
}

# This is a closed form function that requires no recursion
# see https://en.wikipedia.org/wiki/Leonardo_number
sub closedForm{
    my $ln=shift;
    return 2*($gr1**($ln+1)-$gr2**($ln+1))/($gr1-$gr2) -1;
}
</code></pre>

<hr />

<h2 id="steven-wilson">Steven Wilson</h2>

<p><strong>Steven</strong> kept it sweet and simple.</p>

<pre><code class="language-perl">e strict;
use warnings;

my @leonardo_numbers = ( 1, 1 );
my $counter = 2;

while ( $counter &lt; 20 ) {
    $leonardo_numbers[$counter] =
        $leonardo_numbers[ $counter - 1 ] +
        $leonardo_numbers[ $counter - 2 ] +
        1;
    $counter++;
}

print join &quot; &quot;, @leonardo_numbers, &quot;\n&quot;;``
***

## Ulrich Rieke

**Ulrich** made good use of **negative** index. Clean Hack.

```perl
#!/usr/bin/perl ;
use strict ;
use warnings ;

my @leonardos = ( 1 , 1 ) ;
while ( (scalar @leonardos ) &lt; 20 ) {
  push @leonardos , $leonardos[-1] + $leonardos[-2] + 1 ;
}
for my $num ( @leonardos ) {
  print &quot;$num &quot; ;
}
print &quot;\n&quot; ;
</code></pre>

<hr />

<h2 id="walt-mankowski-1">Walt Mankowski</h2>

<p><strong>Walt</strong> made good use <strong>swapping</strong>, very nice hack.</p>

<pre><code class="language-perl">#!/usr/bin/env perl
use strict;
use warnings;
use feature qw(:5.30);
use experimental qw(signatures);

my $N = 20;
my ($l1, $l2) = (1, 1);

for my $i (0..$N-1) {
    if ($i &lt; 2) {
        say &quot;L($i) = 1&quot;;
    } else {
        ($l1, $l2) = ($l2, $l1 + $l2 + 1);
        say &quot;L($i) = $l2&quot;;
    }
}
</code></pre>

<hr />

<h2 id="wanderdoc-1">Wanderdoc</h2>

<p><strong>Wanderdoc</strong> exploited the <strong>Fibonacci series</strong> to get the desired result.</p>

<pre><code class="language-perl">#!perl
use strict;
use warnings FATAL =&gt; qw(all);

my $fn = shift || 20; #  or die &quot;How much numbers?\n&quot;;
print join(&quot; &quot;, map 2 * fib($_ + 1) - 1, 0 .. 20), $/;

sub fib
{
     my $n = shift;
     my $x = 0;
     my $y = 1;

     my $m = 0;
     while ( $m &lt; $n )
     {
          ($x, $y) = ($y, $x + $y);
          $m++;

     }

     return $x;
}
</code></pre>

<hr />

<hr />

<h2 id="see-also">SEE ALSO</h2>

<hr />

<hr />

<p>(1) <a href="https://adamcrussell.livejournal.com/14043.html"><strong>Perl Weekly Challenge 041</strong></a> by <strong>Adam Russell</strong></p>

<p>(2) <a href="https://perlchallenges.wordpress.com/2019/12/30/perl-weekly-challenge-041/"><strong>PERL WEEKLY CHALLENGE – 041</strong></a> by <strong>Javier Luque</strong></p>

<p>(3) <a href="http://blogs.perl.org/users/laurent_r/2020/01/perl-weekly-challenge-41-attractive-numbers-and-leonardo-numbers.html"><strong>Perl Weekly Challenge 41: Attractive Numbers and Leonardo Numbers</strong></a> by <strong>Laurent Rosenfeld</strong></p>

<p>(4) <a href="http://www.ry.ca/2020/01/attractive-numbers/"><strong>Attractive Numbers</strong></a> by <strong>Ryan Thompson</strong></p>

<p>(5) <a href="http://www.ry.ca/2020/01/leonardo-numbers/"><strong>Leonardo Numbers</strong></a> by <strong>Ryan Thompson</strong></p>

                </div>
            </div>
        </div>
    </div>
</section>


<!-- Call To Action Section Start -->
<section id="call-to-action">
    <div class="container">
        <div class="row">
            <div class="col-md-12">
                <div class="block">
                    <h2 class="title wow fadeInDown" data-wow-delay=".3s" data-wow-duration="500ms">SO WHAT DO YOU THINK ?</h2>
                    <p class="wow fadeInDown" data-wow-delay=".5s" data-wow-duration="500ms">If you have any suggestions or ideas then please do share with us.</p>
                    <a href="/contact" class="btn btn-default btn-contact wow fadeInDown" data-wow-delay=".7s" data-wow-duration="500ms">Contact with me</a>
                </div>
            </div>

        </div>
    </div>
</section>
<!-- Call To Action Section End -->



<!-- Footer Section Start -->
<footer id="footer">
    <div class="container">
        <div class="row content-justify-between">
            <div class="col-md-8 col-12 text-center text-lg-left text-md-left">
                <p class="copyright">Copyright:
                    <span>
                        <script>document.write(new Date().getFullYear())</script>
                    </span> PerlWeeklyChallenge. Theme Design and Developed by
                    <a href="http://www.Themefisher.com" target="_blank">Themefisher</a>.
                </p>
            </div>
            <div class="col-md-4 col-12">
                <!-- Social Media -->
                <ul class="social text-center text-md-right text-lg-right">
                    <li>
                        <a href="https://twitter.com/PerlWChallenge" class="twitter" target="_blank" title="Follow us">
                            <i class="ion-social-twitter"></i>
                        </a>
                    </li>
                    <li>
                        <a href="/rss.xml" class="rss" target="_blank" title="RSS Feed">
                            <i class="ion-social-rss"></i>
                        </a>
                    </li>
                    <li>
                        <a href="https://www.nomtimes.co.uk/site/shop.do?cref=PerlBooks" title="Free Perl Books" target="_blank">
                            <img src="/images/NomTimes.jpg" style="width:22px; height: 18px;" alt=""/>
                        </a>
                    </li>
                </ul>
            </div>
        </div>
    </div>
</footer>
<!-- footer section end -->

<!-- jquery -->
<script src="https://perlweeklychallenge.org/plugins/jQurey/jquery.min.js"></script>
<!-- Form Validation -->
<script src="https://perlweeklychallenge.org/plugins/form-validation/jquery.form.js"></script>
<script src="https://perlweeklychallenge.org/plugins/form-validation/jquery.validate.min.js"></script>
<!-- slick slider -->
<script src="https://perlweeklychallenge.org/plugins/slick/slick.min.js"></script>
<!-- bootstrap js -->
<script src="https://perlweeklychallenge.org/plugins/bootstrap/bootstrap.min.js"></script>
<!-- chart js -->
<script src="https://perlweeklychallenge.org/plugins/chart/highstock.js"></script>
<script src="https://perlweeklychallenge.org/plugins/chart/drilldown.js"></script>
<script src="https://perlweeklychallenge.org/plugins/chart/data.js"></script>
<script src="https://perlweeklychallenge.org/plugins/chart/chart.js"></script>
<!-- wow js -->
<script src="https://perlweeklychallenge.org/plugins/wow-js/wow.min.js"></script>
<!-- slider js -->
<script src="https://perlweeklychallenge.org/plugins/slider/slider.js"></script>
<!-- Fancybox -->
<script src="https://perlweeklychallenge.org/plugins/facncybox/jquery.fancybox.js"></script>
<!-- template main js -->

<script src="https://perlweeklychallenge.org/js/script.min.js"></script>
<!-- google analitycs -->
<script>
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
    (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
    m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
    ga('create', 'UA-136524905-1', 'auto');
    ga('send', 'pageview');
</script>
</body>

</html>

