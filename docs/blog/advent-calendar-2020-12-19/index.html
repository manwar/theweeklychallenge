<!DOCTYPE html>
<html class="no-js" lang="en-us">
<head>
    <!-- Basic Page Needs -->

    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta property="og:title"       content="The Weekly Challenge - Perl & Raku"/>
    <meta property="og:type"        content="website"/>
    <meta property="og:url"         content="https://perlweeklychallenge.org/"/>
    <meta property="og:image"       content="https://perlweeklychallenge.org/images/about/about.jpg"/>
    <meta property="og:description" content="You do not have to be an expert."/>
    <meta name="twitter:card"       content="summary" />
    <meta name="twitter:image"      content="https://perlweeklychallenge.org/images/about/about.jpg"/>

    <meta http-equiv="Content-Type" content="text/html; charset=utf-8">

    <meta name="description" content="Advent Calendar - December 19, 2020.">
    <meta name="author" content="The Weekly Challenge Team">
    <meta name="generator" content="Hugo 0.67.0-DEV" />

    <!-- Mobile Specific Metas -->
    <meta name="format-detection" content="telephone=no">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>Advent Calendar - December 19, 2020</title>
    <link rel="icon" href="https://perlweeklychallenge.org/images/favicon.ico">

    
    <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.0/css/bootstrap.min.css"/>

    <!-- Twitter Bootstrs CSS -->
    <link rel="stylesheet" href="https://perlweeklychallenge.org/plugins/bootstrap/bootstrap.min.css">
    <!-- Ionicons Fonts Css -->
    <link rel="stylesheet" href="https://perlweeklychallenge.org/plugins/ionicons/ionicons.min.css">
    <!-- animate css -->
    <link rel="stylesheet" href="https://perlweeklychallenge.org/plugins/animate-css/animate.css">
    <!-- Hero area slider css-->
    <link rel="stylesheet" href="https://perlweeklychallenge.org/plugins/slider/slider.css">
    <!-- slick slider -->
    <link rel="stylesheet" href="https://perlweeklychallenge.org/plugins/slick/slick.css">
    <!-- Fancybox -->
    <link rel="stylesheet" href="https://perlweeklychallenge.org/plugins/facncybox/jquery.fancybox.css">
    <!-- hover -->
    <link rel="stylesheet" href="https://perlweeklychallenge.org/plugins/hover/hover-min.css">
    <!-- Google fonts -->
    <link href='https://fonts.googleapis.com/css?family=Source Code Pro' rel='stylesheet'>
    <!-- template main css file -->
    
    <link rel="stylesheet" href="https://perlweeklychallenge.org/css/style.min.css" integrity="" media="screen">
    <link rel="stylesheet" href="https://perlweeklychallenge.org/css/main.css">

    <style>
        #goTopButton {
            display: none;          
            position: fixed;        
            bottom: 20px;           
            right: 30px;            
            z-index: 99;            
            border: none;           
            outline: none;          
            background-color: red;  
            color: white;           
            cursor: pointer;        
            padding: 15px;          
            border-radius: 10px;    
            font-size: 18px;        
        }

        #goTopButton:hover {
              background-color: #555;
        }
    </style>


</head>

<body>

<button onclick="goTop()" id="goTopButton" title="Go to top">Top</button>

<script>

    topButton = document.getElementById("goTopButton");

    
    window.onscroll = function() { scrollFunction() };

    function scrollFunction() {
        if (document.body.scrollTop > 40 || document.documentElement.scrollTop > 40) {
            topButton.style.display = "block";
        } else {
            topButton.style.display = "none";
        }
    }

    
    function goTop() {
        document.body.scrollTop = 0; 
        document.documentElement.scrollTop = 0; 
    }

</script>

<section class="top-bar animated-header">
    <div class="container">
        <div class="row">
            <div class="col-lg-12">
                <nav class="navbar navbar-expand-lg navbar-light bg-light">
                    <a class="navbar-brand" href="https://perlweeklychallenge.org/">
                        <img src="https://perlweeklychallenge.org/images/logo.svg" alt="logo">
                    </a>
                    <button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navgation" aria-controls="navigation"
                        aria-expanded="false" aria-label="Toggle navigation">
                        <span class="navbar-toggler-icon"></span>
                    </button>

                    <div class="collapse navbar-collapse" id="navigation">
                        <ul class="navbar-nav ml-auto">
                            <li class="nav-item">
                                <a class="nav-link" href="https://perlweeklychallenge.org/">Home</a>
                            </li>
                            
                            <li class="nav-item">
                                <a class="nav-link" href="https://perlweeklychallenge.org/about">About</a>
                            </li>
                            
                            <li class="nav-item">
                                <a class="nav-link" href="https://perlweeklychallenge.org/chart">Chart</a>
                            </li>
                            
                            <li class="nav-item">
                                <a class="nav-link" href="https://perlweeklychallenge.org/champions">Champions</a>
                            </li>
                            
                            <li class="nav-item">
                                <a class="nav-link" href="https://perlweeklychallenge.org/team">Team</a>
                            </li>
                            
                            <li class="nav-item">
                                <a class="nav-link" href="https://perlweeklychallenge.org/challenges">Challenges</a>
                            </li>
                            
                            <li class="nav-item">
                                <a class="nav-link" href="https://perlweeklychallenge.org/p5-reviews">Perl/Review</a>
                            </li>
                            
                            <li class="nav-item">
                                <a class="nav-link" href="https://perlweeklychallenge.org/p6-reviews">Raku/Review</a>
                            </li>
                            
                            <li class="nav-item">
                                <a class="nav-link" href="https://perlweeklychallenge.org/recaps">Recaps</a>
                            </li>
                            
                            <li class="nav-item">
                                <a class="nav-link" href="https://perlweeklychallenge.org/blogs">Blogs</a>
                            </li>
                            
                            <li class="nav-item">
                                <a class="nav-link" href="https://perlweeklychallenge.org/faq">FAQ</a>
                            </li>
                            
                            <li class="nav-item">
                                <a class="nav-link" href="https://perlweeklychallenge.org/contact">Contact</a>
                            </li>
                            
                        </ul>
                    </div>
                </nav>
            </div>
        </div>
    </div>
</section>


<section class="global-page-header">
    <div class="container">
        <div class="row">
            <div class="col-md-12">
                <div class="block">
                    <h2>Advent Calendar - December 19, 2020</h2>
                    <div class="portfolio-meta">
                        <span>Wednesday, Dec 23, 2020</span>|
                        <span> Tags:
                            Perl
                        </span>
                    </div>
                </div>
            </div>
        </div>
    </div>
</section>

<section class="single-post">
    <div class="container">
        <div class="row">
            <div class="col-md-12">
                
                <div style="text-align: center" class="post-img">
                    <img class="img-fluid" alt="" src="https://perlweeklychallenge.org/images/blog/2020-12-19.jpg">
                </div>
                
                <div style="text-align: justify" class="post-content">
                    <p><a href="/blog/advent-calendar-2020"><strong>Advent Calendar 2020</strong></a></p>
<hr>
<p>The gift is presented by <a href="https://perlweeklychallenge.org/blog/meet-the-champion-020"><strong>Duncan C. White</strong></a>. Today he is talking about his solution to the task <code>Head to Tail Pok√©mon names</code> of <strong><a href="/blog/perl-weekly-challenge-025">&ldquo;The Weekly Challenge - 025&rdquo;</a></strong>. This is re-produced for <strong>Advent Calendar 2020</strong> from the original <a href="https://www.doc.ic.ac.uk/~dcw/PSD/article13/"><strong>post</strong></a> by <strong>Duncan C. White</strong>.</p>
<hr>
<p>I&rsquo;m <strong>Duncan White</strong>, an experienced and professional programmer, and have been programming for well over <strong>30 years</strong>, mainly in <strong>C</strong> and <strong>Perl</strong>, although I know many other languages. In that time, despite my best intentions:-), I just can&rsquo;t help learning a thing or two about the practical matters of designing, programming, testing, debugging, running projects etc. Back in 2007, I thought I&rsquo;d start writing an occasional series of articles, book reviews, more general thoughts etc, all focussing on software development without all the guff.</p>
<h1 id="a-study-in-optimization-find-a-longest-pokemon-chain">A STUDY IN OPTIMIZATION: FIND A LONGEST POKEMON CHAIN</h1>
<p>There is a famous programming saying that premature optimization is the root of all evil. Of course getting your program correct is far more important than making it run fast.</p>
<p>I&rsquo;d also suggest that writing your program in accordance with Kernighan and Pike (K&amp;P)&lsquo;s core principles simplicity, clarity and generality is also far more important than making it run fast (see my review of <a href="https://www.doc.ic.ac.uk/~dcw/PSD/article13/article6/">The Practice of Programming (Kernighan &amp; Pike)</a> for more details).</p>
<p>But occasionally, when your program is working properly, and when it&rsquo;s written simply, clearly and elegantly, it can be worth selectively optimizing your program. Perhaps you have a critical need to make it run faster, perhaps you just want to keep your hand in.</p>
<p>I typically find that, when I do bother to try to optimize my code I can make it run about 10 times faster, usually without changing the basic algorithm in use. Often, the most effective tactic is to precompute as much as possible. To that end, I often ask myself - what is the ideal data structure that would enable me to look up the answers to all questions of a particular type, and can I build that data structure more quickly? We&rsquo;ll see lots of examples of this in this article.</p>
<p>Recently, I started doing the <a href="https://perlweeklychallenge.org/">Perl Weekly Challenge</a>, for fun and amusement. Each week, two or three tasks are set for challengers, to solve in Perl 5 or Perl 6 (recently renamed as Raku), and people can submit their solutions before the end of the week via a github pull request. In recent weeks, they have started selecting a weekly Champion, and got them to answer some questions for a &ldquo;Meet the Champion&rdquo; page. To my surprise and great pleasure, I was selected Champion a few weeks ago: please see <a href="https://perlweeklychallenge.org/blog/meet-the-champion-020/">Meet The Champion - Duncan C. White</a>.</p>
<p>One recent Perl challenge was as follows:</p>
<p>Generate a longest sequence of the following &ldquo;English Pokemon&rdquo; names where each name starts with the last letter of the previous name:</p>
<p>The names are: audino bagon baltoy banette bidoof braviary bronzor carracosta charmeleon cresselia croagunk darmanitan deino emboar emolga exeggcute gabite girafarig gulpin haxorus heatmor heatran ivysaur jellicent jumpluff kangaskhan kricketune landorus ledyba loudred lumineon lunatone machamp magnezone mamoswine nosepass petilil pidgeotto pikachu pinsir poliwrath poochyena porygon2 porygonz registeel relicanth remoraid rufflet sableye scolipede scrafty seaking sealeo silcoon simisear snivy snorlax spoink starly tirtouga trapinch treecko tyrogue vigoroth vulpix wailord wartortle whismur wingull yamask</p>
<p>This seemed like an interesting challenge, explore all paths through the &ldquo;maze&rdquo; and keep track of one longest path found.</p>
<p>Of course the unusual aspect was the maze chain rule, i.e. how you get from one position in the maze to the next: rather than specifying a separate set of links from node N to M, here the rule was that each name starts with the last letter of the previous name.</p>
<h1 id="solving-the-pokemon-maze-challenge">Solving the Pokemon Maze Challenge</h1>
<p>Before we can optimize anything, of course we have to solve the separate challenge - to generate something to optimize later.</p>
<p>I started by writing some boilerplate, and specifying the Pokemon names to use:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-perl" data-lang="perl"><span style="color:#75715e">#!/usr/bin/perl</span>
  <span style="color:#75715e">#</span>
  <span style="color:#75715e"># Challenge 1: &#34;Generate a longest sequence of the following &#34;English Pokemon&#34;</span>
  <span style="color:#75715e">#     names where each name starts with the last letter of the previous name.</span>
  <span style="color:#75715e">#</span>

  <span style="color:#66d9ef">use</span> v5<span style="color:#ae81ff">.10</span>;    <span style="color:#75715e"># to get &#34;say&#34;</span>
  <span style="color:#66d9ef">use</span> strict;
  <span style="color:#66d9ef">use</span> warnings;
  <span style="color:#66d9ef">use</span> Function::Parameters;
  <span style="color:#66d9ef">use</span> Data::Dumper;

  <span style="color:#66d9ef">my</span> $debug <span style="color:#f92672">=</span> @ARGV<span style="color:#f92672">&gt;</span><span style="color:#ae81ff">0</span>;

  <span style="color:#66d9ef">my</span> @words <span style="color:#f92672">=</span> <span style="color:#e6db74">qw(audino bagon baltoy banette bidoof braviary bronzor carracosta
</span><span style="color:#e6db74">    charmeleon cresselia croagunk darmanitan deino emboar emolga
</span><span style="color:#e6db74">    exeggcute gabite girafarig gulpin haxorus heatmor heatran ivysaur
</span><span style="color:#e6db74">    jellicent jumpluff kangaskhan kricketune landorus ledyba loudred
</span><span style="color:#e6db74">    lumineon lunatone machamp magnezone mamoswine nosepass petilil
</span><span style="color:#e6db74">    pidgeotto pikachu pinsir poliwrath poochyena porygon2 porygonz
</span><span style="color:#e6db74">    registeel relicanth remoraid rufflet sableye scolipede scrafty
</span><span style="color:#e6db74">    seaking sealeo silcoon simisear snivy snorlax spoink starly
</span><span style="color:#e6db74">    tirtouga trapinch treecko tyrogue vigoroth vulpix wailord
</span><span style="color:#e6db74">    wartortle whismur wingull yamask)</span>;
</code></pre></div><p>Thinking about the maze chain rule, it seemed to me that it would be useful to be able to look up the list of Pokemon names that start with a particular letter. I often start off in this fashion, working <code>bottom-up</code> - building a few useful functions or code snippets that will help us to solve the main problem soon.</p>
<p>In <strong>Perl</strong>, we can trivially find all words starting with a specific letter, using <code>grep</code> and a regex match:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-perl" data-lang="perl"><span style="color:#66d9ef">my</span> @startwords <span style="color:#f92672">=</span> grep { <span style="color:#e6db74">/^$letter/</span> } @words;
</code></pre></div><p>So our first program match use this technique to look up all Pokemon names beginning with the letter &ldquo;c&rdquo; and display them:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-perl" data-lang="perl">  say <span style="color:#e6db74">&#34;Pokemon names starting with c:&#34;</span>;
  <span style="color:#66d9ef">my</span> @startwords <span style="color:#f92672">=</span> grep { <span style="color:#e6db74">/^c/</span> } @words;
  say <span style="color:#66d9ef">for</span> @startwords;
</code></pre></div><p>Running this, I got the reassuring:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-perl" data-lang="perl">  Pokemon names starting with c:
  carracosta
  charmeleon
  cresselia
  croagunk
</code></pre></div><p>Next, I realised that we were going to be calculating startwords an awful lot while exploring all paths through our maze (from every starting word), and of course the list of startwords for a particular starting letter is the same, no matter how many times we calculate it.</p>
<p>So it occurred to me that an ideal data structure to look up the answer would be:</p>
<ul>
<li>A hash of arrays (a HoA in Perl terminology):</li>
<li>A mapping from a letter to the list of words that start with that letter.</li>
</ul>
<p>We could build this data structure, for all starting letters in the Pokemon names themselves, in very little work:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-perl" data-lang="perl">  <span style="color:#66d9ef">my</span> %sw;       <span style="color:#75715e"># letter -&gt; list of words starting with that letter.</span>
  <span style="color:#66d9ef">foreach</span> <span style="color:#66d9ef">my</span> $word (@words)
  {
    <span style="color:#75715e"># find the first letter in the word</span>
        <span style="color:#66d9ef">my</span> $letter <span style="color:#f92672">=</span> substr($word,<span style="color:#ae81ff">0</span>,<span style="color:#ae81ff">1</span>);

    <span style="color:#75715e"># initialize sw{letter} to an empty array</span>
        $sw{$letter} <span style="color:#e6db74">//</span><span style="color:#f92672">=</span> <span style="color:#f92672">[]</span>;

    <span style="color:#75715e"># append word to sw{letter}</span>
        push @{$sw{$letter}}, $word;
  }
</code></pre></div><p>(Note that Perl&rsquo;s <code>auto-vivification</code> facility allows you to omit initializations such as <code>$sw{$letter} //= []</code>, because <code>push @{undefined array ref}</code>, X automatically creates (or <code>vivifies</code>) the empty array for you, before adding the new element. However, I find it clearer and more robust to explicitly include the initialization step.)</p>
<p>Having done that, I decided that was enough newly developed code for a single <a href="https://www.doc.ic.ac.uk/~dcw/PSD/aside-tussock-hopping/">tussock hop</a>, so checked that it builds the correct data structure, using Perl&rsquo;s core module <code>Data::Dumper</code> which displays any Perl data structure for you:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-perl" data-lang="perl">die Dumper <span style="color:#f92672">\</span>%sw;
</code></pre></div><p>When I ran this, it generated the following (note that the keys are in random order, changing each time you run it):</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-perl" data-lang="perl">  $VAR1 <span style="color:#f92672">=</span> {
          <span style="color:#e6db74">&#39;k&#39;</span> <span style="color:#f92672">=&gt;</span> [
                   <span style="color:#e6db74">&#39;kangaskhan&#39;</span>,
                   <span style="color:#e6db74">&#39;kricketune&#39;</span>
                 ],
          <span style="color:#e6db74">&#39;g&#39;</span> <span style="color:#f92672">=&gt;</span> [
                   <span style="color:#e6db74">&#39;gabite&#39;</span>,
                   <span style="color:#e6db74">&#39;girafarig&#39;</span>,
                   <span style="color:#e6db74">&#39;gulpin&#39;</span>
                 ],
          <span style="color:#e6db74">&#39;w&#39;</span> <span style="color:#f92672">=&gt;</span> [
                   <span style="color:#e6db74">&#39;wailord&#39;</span>,
                   <span style="color:#e6db74">&#39;wartortle&#39;</span>,
                   <span style="color:#e6db74">&#39;whismur&#39;</span>,
                   <span style="color:#e6db74">&#39;wingull&#39;</span>
                 ],
      <span style="color:#f92672">....</span>
  };
</code></pre></div><p>Next, I commented out the die command, and wrote the next section of code: having built %sw, we want to try finding all sequences from each starting Pokemon name, tracking the longest sequence found. I simply assumed that I had a function called:</p>
<p><code>findseq( $currw, @seq );</code></p>
<p>which would find all sequences of Pokemon names (from @words), from the current word $currw, assuming that we had already visited the words in @seq, and update @longest whenever it finds a longer sequence than that.</p>
<p>Why do we need to track the sequence @seq of words already visited? Because we must only use each Pokemon name once! If we&rsquo;re allowed to use a Pokemon name more than once, we could generate an infinite length sequence of names - by finding a loop of words and going round the loop forever. The shortest form of word loop involves finding a Pokemon name starting and ending with the same letter, such as girafarig and reusing that name indefinitely.</p>
<p>To summarise this, I wrote a function comment to explain what findseq() does and why anyone should want to call it:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-perl" data-lang="perl">  <span style="color:#75715e">#</span>
  <span style="color:#75715e"># findseq( $currw, @seq );</span>
  <span style="color:#75715e">#    Find all sequences of words from $currw onwards,</span>
  <span style="color:#75715e">#    given that we&#39;ve already visited words in @seq,</span>
  <span style="color:#75715e">#    and update the global @longseq if any sequences</span>
  <span style="color:#75715e">#    we find are longer than that.</span>
  <span style="color:#75715e">#</span>
  fun findseq( $currw, @seq )
  {
  }
</code></pre></div><p>(Note that I&rsquo;m using, as I often do, Perl&rsquo;s CPAN module <code>Function::Parameters</code> to provide a nicer Perl function syntax. Perl 5 has recently implemented such a syntax, but only since Perl 5.24, and I don&rsquo;t routinely assume that I am using such a new version when I write general purpose Perl code. I really wish the Perl community had implemented something similar 15-20 years ago, rather than distract themselves with Perl 6. Whatever).</p>
<p>Having assumed that I had the function <code>findseq( $currw, @seq )</code> available (even though I haven&rsquo;t written it yet), I wrote the main code to call it:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-perl" data-lang="perl">  <span style="color:#66d9ef">my</span> @longseq <span style="color:#f92672">=</span> ();    <span style="color:#75715e"># longest sequence found so far..</span>

  <span style="color:#75715e"># search for sequences starting with each word in turn..</span>
  <span style="color:#66d9ef">foreach</span> <span style="color:#66d9ef">my</span> $sw (@words)
  {
     findseq( $sw, () );
  }

  <span style="color:#66d9ef">my</span> $longest <span style="color:#f92672">=</span> @longseq;

  say <span style="color:#e6db74">&#34;\nlongest sequence is length $longest: @longseq&#34;</span>;
  exit <span style="color:#ae81ff">0</span>;
</code></pre></div><p>Next I wrote the function body, according to the specification in the comment, as a recursive function (which seemed natural):</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-perl" data-lang="perl">  fun findseq( $currw, @seq )
  {
    <span style="color:#75715e"># extend @seq sequence</span>
        push @seq, $currw;

    <span style="color:#75715e"># convert @seq to set for quick lookups</span>
        <span style="color:#66d9ef">my</span> %used <span style="color:#f92672">=</span> map { $_ <span style="color:#f92672">=&gt;</span> <span style="color:#ae81ff">1</span> } @seq;

    <span style="color:#75715e"># find the last letter of currw</span>
        $currw <span style="color:#f92672">=~</span><span style="color:#e6db74"> /(.)$/</span>; <span style="color:#66d9ef">my</span> $lastletter <span style="color:#f92672">=</span> $1;

    <span style="color:#75715e"># look up all words starting with lastletter</span>
        <span style="color:#66d9ef">my</span> $nextw <span style="color:#f92672">=</span> $sw{$lastletter};

    <span style="color:#75715e"># if there are any, try each word</span>
        <span style="color:#66d9ef">if</span>( defined $nextw )
        {
                <span style="color:#66d9ef">foreach</span> <span style="color:#66d9ef">my</span> $nextword (@$nextw)
                {
                        findseq( $nextword, @seq ) <span style="color:#66d9ef">unless</span> $used{$nextword};
                }
        } <span style="color:#66d9ef">else</span>
    <span style="color:#75715e"># @seq is finished</span>
        {
                <span style="color:#75715e">#say &#34;found sequence @seq&#34;;</span>
                <span style="color:#66d9ef">my</span> $len <span style="color:#f92672">=</span> @seq;
                <span style="color:#66d9ef">if</span>( $len <span style="color:#f92672">&gt;</span> @longseq )
                {
                        say <span style="color:#e6db74">&#34;longest seq so far (len $len): @seq&#34;</span> <span style="color:#66d9ef">if</span> $debug;
                        @longseq <span style="color:#f92672">=</span> @seq;
                }
        }
  }
</code></pre></div><p>This completes the first version of my Perl program, v1.pl, it only took about 10 minutes to write, was just over 100 lines of Perl code (a lot of them comments!), and I&rsquo;m pleased to report that it worked first time. When I ran it, it took over 30 seconds searching, and then reported:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-perl" data-lang="perl">  longest sequence is length <span style="color:#ae81ff">23</span>: machamp petilil landorus scrafty yamask
  kricketune emboar registeel loudred darmanitan nosepass simisear
  relicanth heatmor rufflet trapinch haxorus seaking girafarig gabite
  exeggcute emolga audino
</code></pre></div><p>You may wish to spend a moment convincing yourself that this is a valid Pokemon chain in the sense of the Perl Challenge, i.e. that each successive word starts with the same letter the previous word ended with.</p>
<p>I should note that there are in fact many different equally long sequences of length 23. It would be very easy to track all of them in our Perl code, but I&rsquo;ll ignore that.</p>
<p>At this point of course, we&rsquo;ve solved the first Challenge: We were asked to find any longest sequence of the given Pokemon names under the chain rule, and we have produced a suitable long sequence. It&rsquo;s an interesting question how we convince ourselves that no longest sequence of these particular Pokemon names exists, in practice we might ask someone else solving the same challenge whether they&rsquo;ve found any sequence longer than 23 words: Let&rsquo;s assume that 23 is the correct upper length, so we&rsquo;ve found a correct answer.</p>
<h1 id="optimizing-our-solution-profile-the-baseline">Optimizing our Solution: Profile the Baseline</h1>
<p>Ok, so now we have some working, elegant, well commented Perl code which solves our longest-path problem. How might we optimize it? The first rule of optimization is that <strong>we don&rsquo;t understand the run-time performance of any code, even if we&rsquo;ve just written it!</strong>.</p>
<p>So we need a tool that can measure where our program actually spends it&rsquo;s time. Such a tool is called a <code>profiler</code>. Perl comes with a basic built-in profiler, but a team working for the New York Times wrote a much more sophisticated Perl profiler a few years ago: it comes as a CPAN module called <code>Devel::NYTProf</code>, which you could install via <strong>cpanm install Devel::NYTProf</strong>, or installing an OS-level package (<strong>sudo apt install libdevel-nytprof-perl</strong> on Debian and Ubuntu systems).</p>
<p>Once you have <code>Devel::NYTProf</code> installed, you can gather profiling information from a run of your program by:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-perl" data-lang="perl">perl <span style="color:#f92672">-</span>d:NYTProf YOUR_PERL_PROGRAM
</code></pre></div><p>Note that running your code in profiling mode often causes it to take significantly longer to run. Our solution took just over 30 seconds (32.6s on my system, actually) when running it normally (without profiling), but running it under NYTProf as follows took just under a minute to run (55.6s):</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-perl" data-lang="perl">time perl <span style="color:#f92672">-</span>d:NYTProf <span style="color:#f92672">./</span>v1<span style="color:#f92672">.</span>pl
</code></pre></div><p>That produced a large binary file called nytprof.out. A human-readable profiling report can be generated from that, in another 20 seconds or so, by:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-perl" data-lang="perl">nytprofhtml nytprof<span style="color:#f92672">.</span>out
</code></pre></div><p>This produces a directory called nytprof containing an html-format profiling report: <a href="https://www.doc.ic.ac.uk/~dcw/PSD/article13/v1/">A copy of it is available here, renamed as v1</a>, opening in a new tab.</p>
<p>In this case the <strong>flame graph</strong> right at the top is not especially helpful, because all the run-time is spent in recursive calls to <code>findseq()</code>. Below the flame graph is a top-15-functions table, which is more useful, showing that all ~5 million calls to <code>findseq()</code> took 31 seconds out of 32 seconds total runtime.</p>
<p>Better still, if you click on the link to findseq it displays a line by line listing of <code>findseq()</code> and how long the program spent in each line (across all the millions of calls to <code>findseq()</code>). Have a look at those numbers, and see what the slowest part of findseq() is?</p>
<p>Let&rsquo;s ignore the slight mystery of why <code>findseq()</code> appeared to be entered twice as many times (~10 million) as it claims, and taking nearly 3 seconds to do it - this may be a consequence of how <code>Function::Parameters</code> works.</p>
<p>The slowest part of the function is converting the sequence to a set via the standard Perl idiom of:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-perl" data-lang="perl"><span style="color:#66d9ef">my</span> %used <span style="color:#f92672">=</span> map { $_ <span style="color:#f92672">=&gt;</span> <span style="color:#ae81ff">1</span> } @seq;
</code></pre></div><p>this takes nearly 10 seconds to execute the ~5 million executions of this line. That&rsquo;s 1/3 of the whole run-time of the program. Let&rsquo;s try to speed this part up.</p>
<h1 id="first-profiling-led-optimization-v2pl">First profiling-led optimization: v2.pl</h1>
<p>Well, if we want to avoid building the set of all words every time we enter <code>findseq()</code> (all 5 million times), the obvious choice is to <strong>pass the set into findseq()</strong> (as a sethashref which Perl requires) <strong>as well as the current word and the sequence</strong>. This suggests <strong>v2.pl</strong> which has the following changes:</p>
<ol>
<li>The call to findseq() becomes:</li>
</ol>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-perl" data-lang="perl">findseq( $sw, {}, () );
</code></pre></div><ol start="2">
<li>The function now starts:</li>
</ol>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-perl" data-lang="perl">  <span style="color:#75715e">#</span>
  <span style="color:#75715e"># findseq( $currw, $used, @seq );</span>
  <span style="color:#75715e">#       Find all sequences of words from $currw onwards,</span>
  <span style="color:#75715e">#       given that we&#39;ve already visited words in @seq,</span>
  <span style="color:#75715e">#       (the same info, as a set, is in %$used)</span>
  <span style="color:#75715e">#       and update the global @longseq if any sequences</span>
  <span style="color:#75715e">#       we find are longer than that.</span>
  <span style="color:#75715e">#</span>
  fun findseq( $currw, $used, @seq )
  {
        push @seq, $currw;                      <span style="color:#75715e"># extend @seq sequence</span>

        <span style="color:#66d9ef">my</span> %used <span style="color:#f92672">=</span> %$used;                      <span style="color:#75715e"># copy and update used set</span>
        $used{$currw}<span style="color:#f92672">++</span>;
        <span style="color:#f92672">...</span>
</code></pre></div><p>The program is otherwise unchanged. Let&rsquo;s profile <strong>v2.pl</strong>, giving a directory <strong>v2/</strong>. Let&rsquo;s implement a tiny Perl helper program to profile a given basename (v1, v2 etc), <strong>pp</strong> as follows:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-perl" data-lang="perl"><span style="color:#75715e">#!/usr/bin/perl</span>
  die <span style="color:#e6db74">&#34;Usage: pp VERSION\n&#34;</span> <span style="color:#66d9ef">unless</span> @ARGV<span style="color:#f92672">==</span><span style="color:#ae81ff">1</span>;
  <span style="color:#66d9ef">my</span> $v<span style="color:#f92672">=</span>shift;
  $v <span style="color:#f92672">=~</span> <span style="color:#e6db74">s/\.pl$//</span>;
  system( <span style="color:#e6db74">&#34;perl -d:NYTProf $v.pl&#34;</span> );
  system( <span style="color:#e6db74">&#34;nytprofhtml nytprof.out&#34;</span> );
  system( <span style="color:#e6db74">&#34;rm -rf $v&#34;</span> );
  system( <span style="color:#e6db74">&#34;mv nytprof $v&#34;</span> );
</code></pre></div><p>Now let&rsquo;s use this to profile v2:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-perl" data-lang="perl"><span style="color:#f92672">./</span>pp v2
</code></pre></div><p>Just over a minute later, point your web browser: <a href="https://www.doc.ic.ac.uk/~dcw/PSD/article13/v2/">here at v2/, opening in a new tab</a>.</p>
<p>You&rsquo;ll see that the 5 million calls to <code>findseq()</code> now take only 28.8 seconds (down from 32.6 seconds). So our first optimization has shaved 4.2 seconds off the total runtime. But let&rsquo;s not stop there! Look carefully of the line by line profiling of our second version, looking for something else to optimize:</p>
<h1 id="second-profiling-led-optimization-v3pl">Second profiling-led optimization: v3.pl</h1>
<p>The first thing that I noticed was that it takes 6 seconds to copy the used set from the hashref into a fresh local hash %used = %$used 5 million times. Is there any way we could avoid that?</p>
<p>The only change we are making to the used set between calls to findseq() is that, on entry to findseq() we&rsquo;re adding $currw to the used set, so that the used set we pass into each recursive call to findseq() has the current word marked as used.</p>
<p>But couldn&rsquo;t we avoid all the copying by <strong>using a single used sethashref</strong>, modifying it <strong>on entry to findseq, when we add the current word $currw</strong>, and <strong>changing it back again on exit, removing $currw from it once more?</strong> This suggests <strong>v3.pl</strong> which has the following changes:</p>
<h3 id="1-to-alter-the-used-sethashref-not-copying-it-now-on-entry">1) To alter the $used sethashref (not copying it now) on entry:</h3>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-perl" data-lang="perl">$used<span style="color:#f92672">-&gt;</span>{$currw}<span style="color:#f92672">++</span>;                <span style="color:#75715e"># update $used set</span>
</code></pre></div><h3 id="2-next-our-recursive-call-passes-the-hashref-used-directly-rather-than-a-reference-to-the-modified-used-sethash-via-used-and-the-test-for-set-membership-has-to-dereference-the-sethashref-explicitly-used-nextword">2) Next, our recursive call passes the hashref $used directly (rather than a reference to the modified %used sethash via %used), and the test for set membership has to dereference the sethashref explicitly <code>$used-&gt;{nextword}</code>:</h3>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-perl" data-lang="perl"> findseq( $nextword, $used, @seq ) <span style="color:#66d9ef">unless</span> $used<span style="color:#f92672">-&gt;</span>{$nextword};
</code></pre></div><h3 id="3-finally-on-exit-just-before-the-end-of-the-function-we-must-delete-the-current-word-currw-from-the-used-set">3) Finally, on exit, just before the end of the function, we must delete the current word $currw from the used set:</h3>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-perl" data-lang="perl"> delete $used<span style="color:#f92672">-&gt;</span>{$currw};
</code></pre></div><p>Now let&rsquo;s profile v3:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-perl" data-lang="perl"> <span style="color:#f92672">./</span>pp v3
</code></pre></div><p>Just over a minute later, point your web browser: <a href="https://www.doc.ic.ac.uk/~dcw/PSD/article13/v3/">here at v3/, opening in a new tab</a>.</p>
<p>You&rsquo;ll see that the 5 million calls to <code>findseq()</code> now take only 21.1 seconds (down from 28.8 seconds). So our second optimization has shaved a remarkable 7.7 seconds off the total runtime - more than we expected! It appears that accessing a sethashref element may be fractionally faster in Perl than accessig the corresponding sethash element!</p>
<p>But let&rsquo;s not stop there! Look carefully of the line by line profiling of our third version, looking for something else to optimize:</p>
<h1 id="third-profiling-led-optimization-v4pl">Third profiling-led optimization: v4.pl</h1>
<p>The first thing that I noticed was that it takes nearly 7 seconds to determine the last letter of each word (5 million times!). Given that there are only 70 Pokemon names in the data set, couldn&rsquo;t we precompute the last letter for each word at the start, storing the last letter in a word-&gt;letter hash?</p>
<p>This suggests <strong>v4.pl</strong> which has the following changes:</p>
<h3 id="1-below-the-declaration-of-sw-add-our-new-hash">1) Below the declaration of %sw, add our new hash:</h3>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-perl" data-lang="perl"> <span style="color:#66d9ef">my</span> %lw; <span style="color:#75715e"># mapping from word to last letter of word (precompute it:-))</span>
</code></pre></div><h3 id="2-while-looping-over-every-word-and-building-sw-add">2) While looping over every word and building %sw, add:</h3>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-perl" data-lang="perl">  $word <span style="color:#f92672">=~</span><span style="color:#e6db74"> /(.)$/</span>;
  $lw{$word} <span style="color:#f92672">=</span> $1;
</code></pre></div><h3 id="3-inside-findseq-find-the-last-letter-of-currw-via">3) Inside findseq(), find the last letter of currw via:</h3>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-perl" data-lang="perl"> <span style="color:#66d9ef">my</span> $lastletter <span style="color:#f92672">=</span> $lw{$currw};
</code></pre></div><p>Now let&rsquo;s profile v4:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-perl" data-lang="perl"><span style="color:#f92672">./</span>pp v4
</code></pre></div><p>Just under a minute later, point your web browser: <a href="https://www.doc.ic.ac.uk/~dcw/PSD/article13/v4/">here at v4/, opening in a new tab</a>.</p>
<p>You&rsquo;ll see that the 5 million calls to <code>findseq()</code> now take only 14.8 seconds (down from 21.1 seconds). So our third optimization has shaved a decent 6.3 seconds off the total runtime - the vast majority of the time taken to compute last letters.</p>
<p>What&rsquo;s next? Look again of the line by line profiling of our fourth version, looking for something else to optimize:</p>
<h1 id="fourth-profiling-led-optimization-v5pl">Fourth profiling-led optimization: v5.pl</h1>
<p>I couldn&rsquo;t see any obvious optimizations to make while looking at v4.pl&rsquo;s profile. I tried replacing:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-perl" data-lang="perl">  <span style="color:#66d9ef">foreach</span> <span style="color:#66d9ef">my</span> $nextword (@$nextw)
  {
    findseq( $nextword, $used, @seq ) <span style="color:#66d9ef">unless</span> $used<span style="color:#f92672">-&gt;</span>{$nextword};
  }
</code></pre></div><p>with</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-perl" data-lang="perl">  <span style="color:#66d9ef">foreach</span> <span style="color:#66d9ef">my</span> $nextword (grep { <span style="color:#f92672">!</span> $used<span style="color:#f92672">-&gt;</span>{$_} } @$nextw)
  {
    findseq( $nextword, $used, @seq );
  }
</code></pre></div><p>But this made no statistically significant improvement to the runtime. At this point, I wondered whether changing the data structures more significantly could help. In particular, I realised that several data structure map from a word to some property, or store lists of words, and I wondered whether replacing words with word numbers would be any faster.</p>
<p>So I changed the main data structures from hashes to arrays, or from hash-of-hashes to hash-of-arrays:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-perl" data-lang="perl">  <span style="color:#66d9ef">my</span> %sw;    <span style="color:#75715e"># hash from letter to list of word nos starting with that letter.</span>

  <span style="color:#66d9ef">my</span> @lw; <span style="color:#75715e"># mapping from word no to last letter of word.</span>
</code></pre></div><p>I also added a redundant, but useful companion to %sw - that tells you whether <code>@{$sw{letter}}</code> will be empty or not:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-perl" data-lang="perl">  <span style="color:#66d9ef">my</span> %snew;<span style="color:#75715e"># hash from letter to whether or not there ARE any words starting</span>
           <span style="color:#75715e"># with that latter; 0 for no, 1 for yes.</span>
</code></pre></div><p>Then I populated those data structures by:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-perl" data-lang="perl">  <span style="color:#66d9ef">foreach</span> <span style="color:#66d9ef">my</span> $letter (<span style="color:#e6db74">&#39;a&#39;</span><span style="color:#f92672">..</span><span style="color:#e6db74">&#39;z&#39;</span>)
  {
    $snew{$letter} <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
  }

  <span style="color:#66d9ef">foreach</span> <span style="color:#66d9ef">my</span> $wordno (<span style="color:#ae81ff">0</span><span style="color:#f92672">..</span>$#words)
  {
    <span style="color:#66d9ef">my</span> $word <span style="color:#f92672">=</span> $words[$wordno];
    $word <span style="color:#f92672">=~</span><span style="color:#e6db74"> /^(.)/</span>;
    <span style="color:#66d9ef">my</span> $letter <span style="color:#f92672">=</span> $1;
    $sw{$letter} <span style="color:#e6db74">//</span><span style="color:#f92672">=</span> <span style="color:#f92672">[]</span>;
    push @{$sw{$letter}}, $wordno;
    $snew{$letter} <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>;
    $word <span style="color:#f92672">=~</span><span style="color:#e6db74"> /(.)$/</span>;
    $lw[$wordno] <span style="color:#f92672">=</span> $1;
  }
</code></pre></div><p>Then I changed findseq() to deal with a current word no, and a used set represented as a reference to an array of booleans, and a word number sequence:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-perl" data-lang="perl">  <span style="color:#75715e">#</span>
  <span style="color:#75715e"># findseq( $currwno, $used, @seq );</span>
  <span style="color:#75715e">#    Find all sequences of words from $currwno onwards,</span>
  <span style="color:#75715e">#    given that we&#39;ve already visited wordnos in @seq,</span>
  <span style="color:#75715e">#    (the same info, as a set of word nos, is in @$used)</span>
  <span style="color:#75715e">#    and update the global @longseq if any sequences</span>
  <span style="color:#75715e">#    we find are longer than that.</span>
  <span style="color:#75715e">#</span>
  fun findseq( $currwno, $used, @seq )
  {
    push @seq, $currwno;          <span style="color:#75715e"># extend @seq sequence</span>
    $used<span style="color:#f92672">-&gt;</span>[$currwno]<span style="color:#f92672">=</span><span style="color:#ae81ff">1</span>;          <span style="color:#75715e"># update $used set</span>
    <span style="color:#66d9ef">my</span> $lastletter <span style="color:#f92672">=</span> $lw[$currwno];      <span style="color:#75715e"># last letter of currw</span>

    <span style="color:#66d9ef">if</span>( $snew{$lastletter} )      <span style="color:#75715e"># any words starting with letter?</span>
    {
        <span style="color:#66d9ef">foreach</span> <span style="color:#66d9ef">my</span> $nextwordno (grep { <span style="color:#f92672">!</span> $used<span style="color:#f92672">-&gt;</span>[$_] } @{$sw{$lastletter}})
        {
            findseq( $nextwordno, $used, @seq );
        }
    } <span style="color:#66d9ef">else</span>                    <span style="color:#75715e"># @seq is finished</span>
    {
        <span style="color:#75715e">#say &#34;found sequence @seq&#34;;</span>
        <span style="color:#66d9ef">my</span> $len <span style="color:#f92672">=</span> @seq;
        <span style="color:#66d9ef">if</span>( $len <span style="color:#f92672">&gt;</span> @longseq )
        {
            say <span style="color:#e6db74">&#34;longest seq so far (len $len): @seq&#34;</span> <span style="color:#66d9ef">if</span> $debug;
            @longseq <span style="color:#f92672">=</span> @seq;
        }
    }
    $used<span style="color:#f92672">-&gt;</span>[$currwno]<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>;
  }
</code></pre></div><p>Finally, the loop calling findseq() now reads:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-perl" data-lang="perl">  <span style="color:#66d9ef">foreach</span> <span style="color:#66d9ef">my</span> $sw (<span style="color:#ae81ff">0</span><span style="color:#f92672">..</span>$#words)
  {
    findseq( $sw, [ (<span style="color:#ae81ff">0</span>) x scalar(@words)], () );
  }
</code></pre></div><p>After making all these changes in v5.pl, I profiled v5:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-perl" data-lang="perl"> <span style="color:#f92672">./</span>pp v5
</code></pre></div><p>Just under a minute later, point your web browser: <a href="https://www.doc.ic.ac.uk/~dcw/PSD/article13/v5/">here at v5/, opening in a new tab</a>.</p>
<p>You&rsquo;ll see that the whole program now takes about 12.2 seconds (down from 14.7 seconds). That&rsquo;s quite a bit better!</p>
<p>At this point, run times are getting so small that random factors (load on the test machine) may change the profiling time, so I started doing several profiling runs and averaging the results. Some runs of v5 took only 12.0 seconds!</p>
<h1 id="any-more-profiling-led-optimizations">Any more profiling-led optimizations?</h1>
<p>I couldn&rsquo;t see any obvious optimizations to make while looking at v5.pl&rsquo;s profile. I tried several techniques that made no significant difference:</p>
<h3 id="1-i-tried-replacing-nice-shiny-functionparameters-function-syntax-with-a-plain-perl-5-sub">1) I tried replacing nice shiny Function::Parameters function syntax with a plain Perl 5 sub:</h3>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-perl" data-lang="perl">  fun findseq( $currwno, $used, @seq )
  {
</code></pre></div><p>with</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-perl" data-lang="perl">  <span style="color:#66d9ef">sub</span> <span style="color:#a6e22e">findseq</span>
  {
    <span style="color:#66d9ef">my</span>( $currwno, $used, @seq ) <span style="color:#f92672">=</span> @_;
</code></pre></div><p>This shaved 0.4 seconds off.</p>
<h3 id="2-i-tried-replacing-the-used-set-with-an-available-set-simply-in-order-to-remove-the--operator-this-made-no-measurable-difference">2) I tried replacing the used set with an available set, simply in order to remove the ! operator. This made no measurable difference.</h3>
<ol start="3">
<li>I tried combining the %sw (letter to list of word numbers starting with that letter) and %snew (letter to whether or not the corresponding sw list is empty) into</li>
</ol>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-perl" data-lang="perl">  <span style="color:#66d9ef">my</span> @outword;       <span style="color:#75715e"># word number N to list of word numbers starting with</span>
                     <span style="color:#75715e"># word N&#39;s starting number</span>
</code></pre></div><p>But this made no measurable difference at all.</p>
<p>Here&rsquo;s a summary of the run-times of each successive version so far:</p>
<pre><code>Version    Run-time (in seconds)
1    32.6s
2    28.8s
3    21.1s
4    14.8s
5    12.2s
</code></pre>
<p>So, have we reached the end of the profiling line?</p>
<hr>
<p>If you have any suggestion then please do share with us <a href="mailto:perlweeklychallenge@yahoo.com">perlweeklychallenge@yahoo.com</a>.</p>
<p><a href="/blog/advent-calendar-2020"><strong>Advent Calendar 2020</strong></a></p>

                </div>
            </div>
        </div>
    </div>
</section>


<!-- Call To Action Section Start -->
<section id="call-to-action">
    <div class="container">
        <div class="row">
            <div class="col-md-12">
                <div class="block">
                    <h2 class="title wow fadeInDown" data-wow-delay=".3s" data-wow-duration="500ms">SO WHAT DO YOU THINK ?</h2>
                    <p class="wow fadeInDown" data-wow-delay=".5s" data-wow-duration="500ms">If you have any suggestions or ideas then please do share with us.</p>
                    <a href="/contact" class="btn btn-default btn-contact wow fadeInDown" data-wow-delay=".7s" data-wow-duration="500ms">Contact with me</a>
                </div>
            </div>

        </div>
    </div>
</section>
<!-- Call To Action Section End -->



<!-- Footer Section Start -->
<footer id="footer">
    <div class="container">
        <div class="row content-justify-between">
            <div class="col-md-8 col-12 text-center text-lg-left text-md-left">
                <p class="copyright">Copyright:
                    <span>
                        2020
                    </span> PerlWeeklyChallenge. Theme Design and Developed by
                    <a href="http://www.Themefisher.com" rel="noreferrer" rel="noreferrer" target="_blank">Themefisher</a>.
                </p>
            </div>
            <div class="col-md-4 col-12">
                <!-- Social Media -->
                <ul class="social text-center text-md-right text-lg-right">
                    <li>
                        <a href="https://twitter.com/PerlWChallenge" class="twitter" rel="noreferrer" target="_blank" title="Follow us">
                            <i class="ion-social-twitter"></i>
                        </a>
                    </li>
                    <li>
                        <a href="/rss.xml" class="rss" target="_blank" title="RSS Feed">
                            <i class="ion-social-rss"></i>
                        </a>
                    </li>
                    <li>
                        <a href="https://www.nomtimes.co.uk/site/shop.do?cref=PerlBooks" title="Free Perl Books" rel="noreferrer" target="_blank">
                            <img src="/images/NomTimes.jpg" style="width:22px; height: 18px;" alt=""/>
                        </a>
                    </li>
                </ul>
            </div>
        </div>
    </div>
</footer>
<!-- footer section end -->

<!-- jquery -->
<script src="https://perlweeklychallenge.org/plugins/jQurey/jquery.min.js"></script>
<!-- Form Validation -->
<script src="https://perlweeklychallenge.org/plugins/form-validation/jquery.form.min.js"></script>
<script src="https://perlweeklychallenge.org/plugins/form-validation/jquery.validate.min.js"></script>
<!-- slick slider -->
<script src="https://perlweeklychallenge.org/plugins/slick/slick.min.js"></script>
<!-- bootstrap js -->
<script src="https://perlweeklychallenge.org/plugins/bootstrap/bootstrap.min.js"></script>
<!-- chart js -->
<script src="https://perlweeklychallenge.org/plugins/chart/highstock.js"></script>
<script src="https://perlweeklychallenge.org/plugins/chart/drilldown.js"></script>
<script src="https://perlweeklychallenge.org/plugins/chart/data.js"></script>
<script src="https://perlweeklychallenge.org/plugins/chart/chart.js"></script>
<script src="https://perlweeklychallenge.org/plugins/chart/pwc-challenge.js"></script>
<script src="https://perlweeklychallenge.org/plugins/chart/gc-challenge.js"></script>
<!-- wow js -->
<script src="https://perlweeklychallenge.org/plugins/wow-js/wow.min.js"></script>
<!-- slider js -->
<script src="https://perlweeklychallenge.org/plugins/slider/slider.js"></script>
<!-- Fancybox -->
<script src="https://perlweeklychallenge.org/plugins/facncybox/jquery.fancybox.js"></script>
<!-- template main js -->

<script src="https://perlweeklychallenge.org/js/script.min.js"></script>
<!-- google analitycs -->
<script>
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
    (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
    m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
    ga('create', 'UA-136524905-1', 'auto');
    ga('send', 'pageview');
</script>
</body>

</html>

