<!DOCTYPE html>
<html class="no-js" lang="en-us">
<head>
    <!-- Basic Page Needs -->

    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta property="og:title"       content="The Weekly Challenge - Perl & Raku"/>
    <meta property="og:type"        content="website"/>
    <meta property="og:url"         content="https://perlweeklychallenge.org/"/>
    <meta property="og:image"       content="https://perlweeklychallenge.org/images/about/about.jpg"/>
    <meta property="og:description" content="You do not have to be an expert."/>
    <meta name="twitter:card"       content="summary" />
    <meta name="twitter:image"      content="https://perlweeklychallenge.org/images/about/about.jpg"/>

    <meta http-equiv="Content-Type" content="text/html; charset=utf-8">

    <meta name="description" content="Laurent Rosenfeld Weekly Review: Challenge - #033.">
    <meta name="author" content="Perl Weekly Challenge Team">
    <meta name="generator" content="Hugo 0.66.0-DEV" />

    <!-- Mobile Specific Metas -->
    <meta name="format-detection" content="telephone=no">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>Laurent Rosenfeld Weekly Review: Challenge - 033</title>
    <link rel="icon" href="https://perlweeklychallenge.org/images/favicon.ico">

    
    <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.0/css/bootstrap.min.css"/>

    <!-- Twitter Bootstrs CSS -->
    <link rel="stylesheet" href="https://perlweeklychallenge.org/plugins/bootstrap/bootstrap.min.css">
    <!-- Ionicons Fonts Css -->
    <link rel="stylesheet" href="https://perlweeklychallenge.org/plugins/ionicons/ionicons.min.css">
    <!-- animate css -->
    <link rel="stylesheet" href="https://perlweeklychallenge.org/plugins/animate-css/animate.css">
    <!-- Hero area slider css-->
    <link rel="stylesheet" href="https://perlweeklychallenge.org/plugins/slider/slider.css">
    <!-- slick slider -->
    <link rel="stylesheet" href="https://perlweeklychallenge.org/plugins/slick/slick.css">
    <!-- Fancybox -->
    <link rel="stylesheet" href="https://perlweeklychallenge.org/plugins/facncybox/jquery.fancybox.css">
    <!-- hover -->
    <link rel="stylesheet" href="https://perlweeklychallenge.org/plugins/hover/hover-min.css">
    <!-- template main css file -->
    
    <link rel="stylesheet" href="https://perlweeklychallenge.org/css/style.min.css" integrity="" media="screen">
    <link rel="stylesheet" href="https://perlweeklychallenge.org/css/main.css">
</head>

<body>

<section class="top-bar animated-header">
    <div class="container">
        <div class="row">
            <div class="col-lg-12">
                <nav class="navbar navbar-expand-lg navbar-light bg-light">
                    <a class="navbar-brand" href="https://perlweeklychallenge.org/">
                        <img src="https://perlweeklychallenge.org/images/logo.svg" alt="logo">
                    </a>
                    <button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navgation" aria-controls="navigation"
                        aria-expanded="false" aria-label="Toggle navigation">
                        <span class="navbar-toggler-icon"></span>
                    </button>

                    <div class="collapse navbar-collapse" id="navigation">
                        <ul class="navbar-nav ml-auto">
                            <li class="nav-item">
                                <a class="nav-link" href="https://perlweeklychallenge.org/">Home</a>
                            </li>
                            
                            <li class="nav-item">
                                <a class="nav-link" href="https://perlweeklychallenge.org/about">About</a>
                            </li>
                            
                            <li class="nav-item">
                                <a class="nav-link" href="https://perlweeklychallenge.org/chart">Chart</a>
                            </li>
                            
                            <li class="nav-item">
                                <a class="nav-link" href="https://perlweeklychallenge.org/champions">Champions</a>
                            </li>
                            
                            <li class="nav-item">
                                <a class="nav-link" href="https://perlweeklychallenge.org/team">Team</a>
                            </li>
                            
                            <li class="nav-item">
                                <a class="nav-link" href="https://perlweeklychallenge.org/challenges">Challenges</a>
                            </li>
                            
                            <li class="nav-item">
                                <a class="nav-link" href="https://perlweeklychallenge.org/p5-reviews">Perl/Review</a>
                            </li>
                            
                            <li class="nav-item">
                                <a class="nav-link" href="https://perlweeklychallenge.org/p6-reviews">Raku/Review</a>
                            </li>
                            
                            <li class="nav-item">
                                <a class="nav-link" href="https://perlweeklychallenge.org/recaps">Recaps</a>
                            </li>
                            
                            <li class="nav-item">
                                <a class="nav-link" href="https://perlweeklychallenge.org/blogs">Blogs</a>
                            </li>
                            
                            <li class="nav-item">
                                <a class="nav-link" href="https://perlweeklychallenge.org/faq">FAQ</a>
                            </li>
                            
                            <li class="nav-item">
                                <a class="nav-link" href="https://perlweeklychallenge.org/contact">Contact</a>
                            </li>
                            
                        </ul>
                    </div>
                </nav>
            </div>
        </div>
    </div>
</section>


<section class="global-page-header">
    <div class="container">
        <div class="row">
            <div class="col-md-12">
                <div class="block">
                    <h2>Laurent Rosenfeld Weekly Review: Challenge - 033</h2>
                    <div class="portfolio-meta">
                        <span>Sunday, Nov 17, 2019</span>|
                        <span> Tags:
                            Raku
                        </span>
                    </div>
                </div>
            </div>
        </div>
    </div>
</section>

<section class="single-post">
    <div class="container">
        <div class="row">
            <div class="col-md-12">
                
                <div style="text-align: center" class="post-img">
                    <img class="img-fluid" alt="" src="https://perlweeklychallenge.org/images/blog/p6-review-challenge-033.jpg">
                </div>
                
                <div style="text-align: justify" class="post-content">
                    <hr>
<h1 id="raku-solutions-weekly-review">Raku Solutions Weekly Review</h1>
<hr>
<h2 id="task-1-letter-count">Task #1: Letter Count</h2>
<p>This is derived in part from my <a href="http://blogs.perl.org/users/laurent_r/2019/11/perl-weekly-challenge-33-count-letters-and-multiplication-tables.html">blog post</a> made in answer to the <a href="https://perlweeklychallenge.org/blog/perl-weekly-challenge-033/">Week 33 of the Perl Weekly Challenge</a> organized by  <a href="http://blogs.perl.org/users/mohammad_s_anwar/">Mohammad S. Anwar</a> as well as answers made by others to the same challenge.</p>
<p>The challenge reads as follows:</p>
<p><em>Create a script that accepts one or more files specified on the command-line and count the number of times letters appeared in the files.</em></p>
<p><em>So with the following input file sample.txt:</em></p>
<pre><code>The quick brown fox jumps over the lazy dog.
</code></pre>
<p><em>the script would display something like:</em></p>
<pre><code>a: 1
b: 1
c: 1
d: 1
e: 3
f: 1
g: 1
h: 2
i: 1
j: 1
k: 1
l: 1
m: 1
n: 1
o: 4
p: 1
q: 1
r: 2
s: 1
t: 2
u: 2
v: 1
w: 1
x: 1
y: 1
z: 1
</code></pre>
<p>This is not specified explicitly, but from the example, we gather that what is desired here is a case-insensitive letter count (in the example, both &ldquo;T&rdquo; and &ldquo;t&rdquo; count as &ldquo;t&rdquo;). So we will apply the <code>lc</code> (lower case) built-in function to the input.</p>
<h2 id="my-solution">My Solution</h2>
<p>When solving the same task in Perl 5 for the weekly challenge, we used a hash as an histogram, i.e. as a collection of counters. We could do the same in Raku (formerly known as Perl 6). In Raku, however, we can also use a <code>Bag</code>, named <code>$histo</code>, rather than a hash, to easily implement an histogram. With just a little bit of work, we&rsquo;re able to populate the bag in just one statement, without any explicit loop (otherwise, we would have had to use a <code>BagHash</code> instead, since a <code>bag</code> is not mutable and therefore needs to be populated in one single step). Also, if a letter does not exist in the <code>$histo</code> bag, the bag will report 0, so that, contrary to the hash solution, we don&rsquo;t need any special code to avoid an <code>undefined</code> warning for such an edge case. All this makes the code much more concise than its Perl 5 counterpart.</p>
<pre><code class="language-Perl6" data-lang="Perl6">use v6;

sub MAIN (*@files) {
    my $histo = (map {.IO.comb».lc}, @files).Bag;
    say &quot;$_ : &quot;, $histo{$_} for 'a'..'z';
}
</code></pre><p>Used with one input file, the program displays the following:</p>
<pre><code>$ perl6 histo_let.p6 intersection.pl
a : 96
b : 46
c : 25
d : 22
e : 72
f : 19
g : 20
h : 4
i : 77
j : 0
k : 0
[... Lines omitted for brevity ...]
y : 31
z : 0
</code></pre>
<p>And it works similarly with several input files:</p>
<pre><code>$ ./perl6 histo_let.p6 intersection.pl histo*
a : 199
b : 154
c : 123
d : 111
e : 271
f : 99
g : 37
h : 49
i : 170
j : 4
k : 11
[... Lines omitted for brevity ...]
y : 68
z : 9
</code></pre>
<p>Note that we&rsquo;re not trying to filter alphabetical characters when populating the <code>$histo</code> bag: we&rsquo;re simply printing out only the bag entries for the <code>'a'..'z'</code> range.</p>
<h2 id="alternative-approaches">Alternative Approaches</h2>
<p>Not less than 17 solutions were submitted for this task, which is probably the largest count so far.</p>
<p><a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-033/arne-sommer/perl6/ch-1.p6">Arne Sommer</a> provided a very compact solution, at least in terms of the way of populating a <code>Bag</code> of counters:</p>
<pre><code class="language-Perl6" data-lang="Perl6">my %result = $*ARGFILES.comb&gt;&gt;.lc.grep(* ~~ /&lt;:L&gt;/).Bag;

for %result.keys.sort -&gt; $key
{
  say &quot;$key: %result{$key}&quot;;
}
</code></pre><p><a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-033/mark-senn/perl6/ch-1.p6">Mark Senn</a> also suggested a fairly concise solution, using a hash:</p>
<pre><code class="language-Perl6" data-lang="Perl6">my %count;
$*ARGFILES.lines.lc.comb(/&lt;[a..z]&gt;/).map({%count{$_}++});
%count.keys.sort.map({&quot;$_: %count{$_}&quot;.say});
</code></pre><p><a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-033/markus-holzer/perl6/ch-1.p6">Markus Holzer</a> also contributed a rather compact solution (even though it does not look so at first glance because of its formatting), holding in just one statement:</p>
<pre><code class="language-Perl6" data-lang="Perl6">sub MAIN( *@files )
{
    .say for @files
        .map({ |.IO.lines.lc.comb( /\w/ ) })
        .Bag
        .sort
        .map({  &quot;{.key}: {.value}&quot; })
    ;
}
</code></pre><p><a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-033/daniel-mita/perl6/ch-1.sh">Daniel Mita</a> made an even more compact solution in the form of a Raku one-liner also using a <code>Bag</code>:</p>
<pre><code>perl6 -e '.say for @*ARGS ?? slurp.lc.comb(/&lt;[a..z]&gt;/).Bag.sort !! &quot;give at least 1 filename&quot;'
</code></pre>
<p><a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-033/ryan-thompson/perl6/ch-1.p6">Ryan Thompson</a> also used a <code>Bag</code> and provided perhaps the most concise solution of all:</p>
<pre><code class="language-Perl6" data-lang="Perl6">.fmt('%s: %d').say for $*ARGFILES.comb».lc.Bag{'a'..'z'}:p;
</code></pre><p><a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-033/kevin-colyer/perl6/ch-1.p6">Kevin Colyer</a> went the other way around and provided a comprehensive  solution using a <code>count</code> subroutine to populate a temporary and anonymous <code>BagHash</code> for each input file, and then merging the result into a final <code>BagHash</code>:</p>
<pre><code class="language-Perl6" data-lang="Perl6">sub count($text) {
    return BagHash.new( $text.lc.comb.grep: * ~~ / &lt;alpha&gt; / );
}

multi MAIN(*@files) {
    my BagHash $bag;
    for @files -&gt; $f {
        next unless $f.IO:f;
        $bag{.key}+=.value for count($f.IO.slurp); # Add returned bag to bag hash
    }
    $bag{&quot;_&quot;}:delete;
    say &quot;$_: {$bag{$_}}&quot; for $bag.keys.collate;
}
</code></pre><p>Kevin&rsquo;s program iterates over the values of the <code>HashBag</code> returned by the <code>count</code> subroutine to add the values associated with each letter. I suppose it would have been slightly simpler to use the infix <code>(+)</code> (or <code>⊎</code>) <a href="https://docs.perl6.org/language/operators#infix_(+),_infix_%E2%8A%8E">baggy addition operator</a> (see Richard Nutall&rsquo;s solution below for an example of this).</p>
<p>Note that Kevin also provided a <code>pod</code> outlining the challenge task and an alternate multi <code>MAIN</code> subroutine to run a test suite.</p>
<p><a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-033/rnuttall/perl6/ch-1.p6">Richard Nutall</a>, a new member of the Perl Weekly Challenge, used the infix <code>⊎</code> baggy addition operator together with the assignment operator to populate his <code>Bag</code> of counters in just one statement:</p>
<pre><code class="language-Perl6" data-lang="Perl6">sub MAIN(*@files) {
    #Task 1 - a Test of Bag and Bag addition
    my Bag $counts = bag { 'a' .. 'z' =&gt; 0 };

    # Create a bag for each file and add counts using Bag addition ⊎ or (+)
    $counts ⊎= $_.IO.slurp.lc.comb.Bag for @files;

    say &quot;$_: $counts{$_}&quot;              for 'a' .. 'z';
}
</code></pre><p>Note that I don&rsquo;t think that the loop to initialize the &lsquo;a&rsquo; to &lsquo;z&rsquo; counters of the bag to 0 is necessary: if a letter isn&rsquo;t available in a bag, its count will be reported to be 0 without any error or warning.</p>
<p><a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-033/noud/perl6/ch-1.p6">Noud</a> also supplied a comprehensive detailed solution using a hash:</p>
<pre><code class="language-Perl6" data-lang="Perl6">sub MAIN(*@files) {
    my %letter_count;
    %letter_count&lt;a b c d e f g h i j k l m
                  n o p q r s t u v w x y z&gt; = 0 xx *;

    for @files -&gt; $file {
        for $file.IO.comb -&gt; $letter {
            if (%letter_count{$letter.lc}:exists) {
                %letter_count{$letter.lc}++;
            }
        }
    }

    for %letter_count.sort(*.key)&gt;&gt;.kv -&gt; ($letter, $count) {
        say &quot;$letter: $count&quot;;
    }
}
</code></pre><p><a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-033/simon-proctor/perl6/ch-1.p6">Simon Proctor</a> also went for a quite comprehensive program. He created a <code>read-files</code> subroutine to do almost all the work with a <code>Bag</code>, as well as three multi <code>MAIN</code> subroutines to handle various possible arguments passed to the program:</p>
<pre><code class="language-Perl6" data-lang="Perl6">multi sub MAIN( Bool :h($help) where so * ) {
    say $*USAGE;
}

#| Read data from standard in.
multi sub MAIN() {
    read-files( IO::CatHandle.new( $*IN ) );
}

#| Given a list of filenames reads each in turn
multi sub MAIN(
    *@files where all(@files) ~~ ValidFile, #= Files to read
) {
    read-files( IO::CatHandle.new( @files ) );
}

sub read-files( IO::CatHandle $files ) {
    my %results := $files.words.map(*.lc.comb()).flat.grep( { $_ ~~ m!&lt;[a..z]&gt;! } ).Bag;
    .say for (&quot;a&quot;..&quot;z&quot;).map( { &quot;{$_} : {%results{$_}}&quot; } );
}
</code></pre><p><a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-033/adam-russell/perl6/ch-1.p6">Adam Russell</a> used a hash for storing the counters and a <code>for</code> loop to iterate over the lines of the input:</p>
<pre><code class="language-Perl6" data-lang="Perl6">sub MAIN {
    my %letter_count;
    for $*IN.lines() -&gt; $line {
        my @characters = $line.split(&quot;&quot;);
        for @characters -&gt; $c {
            %letter_count{$c}++ if $c~~m/&lt;alpha&gt;/;
        }
    }
    for sort keys %letter_count -&gt; $key {
        print &quot;$key: %letter_count{$key}\n&quot;;
    }
}
</code></pre><p><a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-033/athanasius/perl6/ch-1.p6">Athanasius</a> is not a challenger from whom I have come to expect very terse programs. As usual, his program, which uses a hash to host the counters, is quite comprehensive:</p>
<pre><code class="language-Perl6" data-lang="Perl6">sub MAIN
(
    Bool:D :$count = False,         #= Order by letter counts (highest first)
    Bool:D :$help  = False,         #= Print usage details and exit
           *@filenames,             #= Name(s) of file(s) containing text data
)
{
    if $help || @filenames.elems == 0
    {
        $*USAGE.say;
    }
    else
    {
        my UInt %counts;

        for @filenames -&gt; Str $filename
        {
            for $filename.IO.lines -&gt; Str $line
            {
                ++%counts{ .lc } for $line.split('').grep({ rx:i/ &lt;[a..z]&gt; / });
            }
        }

        my &amp;sort-by = $count ?? sub { %counts{ $^b } &lt;=&gt; %counts{ $^a } ||
                                       $^a cmp $^b }
                             !! sub {  $^a cmp $^b };

        &quot;%s: %d\n&quot;.printf: $_, %counts{ $_ } for %counts.keys.sort: &amp;sort-by;
    }
}
</code></pre><p><a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-033/jaldhar-h-vyas/perl6/ch-1.p6">Jaldhar H. Vyas</a>  also used a hash to store the counters:</p>
<pre><code class="language-Perl6" data-lang="Perl6">sub MAIN(
    *@files
) {
    my %totals;

    if @files.elems {
        for @files -&gt; $file {
            $file.IO.comb.map({ %totals{$_.lc}++; });
        }
    } else {
        $*IN.comb.map({ %totals{$_.lc}++; });
    }

    %totals.keys.grep({ / &lt;lower&gt; / }).sort.map({
        say &quot;$_: %totals{$_}&quot;;
    });
}
</code></pre><p><a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-033/javier-luque/perl6/ch-1.p6">Javier Luque</a> also used a hash for his letter histogram:</p>
<pre><code class="language-Perl6" data-lang="Perl6">sub MAIN (*@filenames) {
    my %counts;

    # Loop through each file
    for @filenames -&gt; $filename {
        my $fh = $filename.IO.open orelse .die;

        # Increment count for each word char
        while (my $char = $fh.getc) {
            %counts{$char.lc}++ if ($char.lc ~~ /\w/);
        }
    }

    # Print each char and count
    for %counts.keys.sort -&gt; $item {
        &quot;%2s %5i\n&quot;.printf($item, %counts{$item});
    }
}
</code></pre><p><a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-033/joelle-maslak/perl6/ch-1.p6">Joelle Maslak</a> also used a hash for storing the counters, but the innovative side of her solution is that it is Unicode compliant and that it uses graphemes matching the <code>&lt;alpha&gt;</code> character class to define its letters:</p>
<pre><code class="language-Perl6" data-lang="Perl6">sub MAIN(+@filenames) {
    my %letters;
    for @filenames -&gt; $fn {
        my @chars = $fn.IO.lines.comb: /&lt;alpha&gt;/;
        for @chars -&gt; $char {
            %letters{$char.fc}++;
        }
    }

    for %letters.keys.sort -&gt; $key {
        say &quot;$key: {%letters{$key}}&quot;;
    }
}
</code></pre><p><a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-033/ruben-westerberg/perl6/ch-1.p6">Ruben Westerberg</a> also used a hash for hosting the counters, and he took special care on the formatting of his output (right-aligning the counters having more than one digit):</p>
<pre><code class="language-Perl6" data-lang="Perl6">my %letters;
for lines() {
    for $_.split(&quot;&quot;,:skip-empty) {
        %letters{$_}++ if /&lt;[a..zA..Z]&gt;/;
    }
}

my $m=max map {chars %letters{$_}}, keys %letters;
for sort keys %letters {
    printf &quot;%s: %&quot;~$m~&quot;s\n&quot;, $_, %letters{$_};
}
</code></pre><p>This is a sample of this program output with a relatively large input file:</p>
<pre><code>B:     1
E:     1
S:     1
T:     1
a: 27904
b:  2496
c:  6656
d:  5376
e: 22848
... (rest omitted for brevity)
</code></pre>
<p><a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-033/roger-bell-west/perl6/ch-1.p6">Roger Bell West</a> also used a hash for the counters:</p>
<pre><code class="language-Perl6" data-lang="Perl6">my %o;

for lines() {
  my $a=lc($_);
  $a ~~ s:g /&lt;-[a .. z]&gt;//;
  map {%o{$_}++}, split '',$a;
}

for sort keys %o -&gt; $k {
  print &quot;$k: %o{$k}\n&quot;;
}
</code></pre><p><a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-033/ulrich-rieke/perl6/ch-1.p6">Ulrich Rieke</a> also used a hash for storing the counters:</p>
<pre><code class="language-Perl6" data-lang="Perl6">sub MAIN( *@ARGS )  {
  for @ARGS -&gt; $file {
      if $file.IO.e {
    my %lettercount ;
    my @words ;
    for $file.IO.lines -&gt; $line {
        @words = $line.split( /\s+/ ) ;
        for @words -&gt; $word {
          my $lowletter = $word.lc ;
          $lowletter ~~ s:g/&lt;-[a..z]&gt;// ;
          my @letters = $lowletter.comb ;
          for @letters -&gt; $letter {
          %lettercount{ $letter }++ ;
          }
        }
    }
    my @sorted = %lettercount.keys.sort( { $^a leg $^b } ) ;
    say &quot;letter frequency in file $file :&quot; ;
    for @sorted -&gt; $letter {
        say &quot;$letter: %lettercount{ $letter }&quot; ;
    }
      }
      else {
    say &quot;Couldn't open file $file!&quot; ;
      }
  }
}
</code></pre><p>I must say that I dislike Ulrich&rsquo;s program inconsistent indentation (this may be due to a problem of tabulations and spaces between his editor and the Github format, but it looks quite bad IMHO) and that his code isn&rsquo;t very perlish (or shall we say &ldquo;rakuish&rdquo;?) and sort of looks like C written in Raku. As a minimal attempt to rewrite this fixing the formatting, I would suggest this:</p>
<pre><code class="language-Perl6" data-lang="Perl6">use v6;

sub MAIN( *@ARGS )  {
    for @ARGS -&gt; $file {
        die &quot;Couldn't open file $file!&quot; unless $file.IO.e;
        my %lettercount;
        for $file.IO.lines -&gt; $line {
            my @words = $line.split( /\s+/ ) ;
            for @words -&gt; $word {
                my $lowletter = $word.lc ;
                $lowletter ~~ s:g/&lt;-[a..z]&gt;// ;
                my @letters = $lowletter.comb ;
                for @letters -&gt; $letter {
                    %lettercount{ $letter }++ ;
                }
            }
        }
        my @sorted = %lettercount.keys.sort( { $^a leg $^b } );
        say &quot;letter frequency in file $file :&quot;;
        for @sorted -&gt; $letter {
            say &quot;$letter: %lettercount{ $letter }&quot;;
        }
    }
}
</code></pre><p>And, trying to make it look more idiomatic while still keeping the original logic:</p>
<pre><code class="language-Perl6" data-lang="Perl6">use v6;

sub MAIN( *@ARGS )  {
    my %lettercount;
    for @ARGS -&gt; $file {
        die &quot;Couldn't open file $file!&quot; unless $file.IO.e;
        for $file.IO.lines.lc.comb -&gt; $char {
            %lettercount{ $char }++ if $char ~~ /&lt;[a..z]&gt;/;
        }
    }
    say &quot;$_: &quot;, %lettercount{$_}//0 for 'a'..'z';
}
</code></pre><h2 id="task-2-formatted-multiplication-table">Task #2: Formatted Multiplication Table</h2>
<p>This is derived in part from my <a href="http://blogs.perl.org/users/laurent_r/2019/11/perl-weekly-challenge-33-count-letters-and-multiplication-tables.html">blog post</a> made in answer to the <a href="https://perlweeklychallenge.org/blog/perl-weekly-challenge-033/">Week 33 of the Perl Weekly Challenge</a> organized by  <a href="http://blogs.perl.org/users/mohammad_s_anwar/">Mohammad S. Anwar</a> as well as answers made by others to the same challenge.</p>
<p>The challenge reads as follows:</p>
<p><em>Write a script to print 11x11 multiplication table, only the top half triangle.</em></p>
<pre><code>x|   1   2   3   4   5   6   7   8   9  10  11
---+--------------------------------------------
1|   1   2   3   4   5   6   7   8   9  10  11
2|       4   6   8  10  12  14  16  18  20  22
3|           9  12  15  18  21  24  27  30  33
4|              16  20  24  28  32  36  40  44
5|                  25  30  35  40  45  50  55
6|                      36  42  48  54  60  66
7|                          49  56  63  70  77
8|                              64  72  80  88
9|                                  81  90  99
10|                                     100 110
11|                                         121
</code></pre>
<h2 id="my-solution-1">My Solution</h2>
<h2 id="formatted-multiplication-table-in-raku-perl-6">Formatted Multiplication Table in Raku (Perl 6)</h2>
<p>To obtain the desired format and easily right-align the numbers, the simplest is to use the <code>printf</code> built-in function when needed:</p>
<pre><code>use v6;
sub MAIN (UInt $max = 11) {
    print-table($max);
}
sub print-table ($max) {
    # Print header
    printf &quot;%2s |&quot;, &quot;x&quot;;
    printf &quot;%4d&quot;, $_ for 1..$max;
    say &quot;\n---|&quot;, &quot;-&quot; x 4 * ($max);
    # Print table lines
    for 1..$max -&gt; $i {
        printf &quot;%2d |%s&quot;, $i, ' ' x 4 * ($i - 1);
        for $i..$max -&gt; $j {
            printf &quot;%4d&quot;, $i * $j;
        }
        say &quot;&quot;;
    }
}
</code></pre>
<p>This script prints out the following:</p>
<pre><code>$ perl6 mult-table.p6
 x |   1   2   3   4   5   6   7   8   9  10  11
---|--------------------------------------------
 1 |   1   2   3   4   5   6   7   8   9  10  11
 2 |       4   6   8  10  12  14  16  18  20  22
 3 |           9  12  15  18  21  24  27  30  33
 4 |              16  20  24  28  32  36  40  44
 5 |                  25  30  35  40  45  50  55
 6 |                      36  42  48  54  60  66
 7 |                          49  56  63  70  77
 8 |                              64  72  80  88
 9 |                                  81  90  99
10 |                                     100 110
11 |                                         121
</code></pre>
<p>This is not exactly the output shown in the task description, but this is deliberate, as I think this looks slightly better.</p>
<p>Just in case you want to know, this works equally well when passing a parameter other than 11:</p>
<pre><code>$ perl6 mult-table.p6 20
 x |   1   2   3   4   5   6   7   8   9  10  11  12  13  14  15  16  17  18  19  20
---|--------------------------------------------------------------------------------
 1 |   1   2   3   4   5   6   7   8   9  10  11  12  13  14  15  16  17  18  19  20
 2 |       4   6   8  10  12  14  16  18  20  22  24  26  28  30  32  34  36  38  40
 3 |           9  12  15  18  21  24  27  30  33  36  39  42  45  48  51  54  57  60
 4 |              16  20  24  28  32  36  40  44  48  52  56  60  64  68  72  76  80
 5 |                  25  30  35  40  45  50  55  60  65  70  75  80  85  90  95 100
 6 |                      36  42  48  54  60  66  72  78  84  90  96 102 108 114 120
 7 |                          49  56  63  70  77  84  91  98 105 112 119 126 133 140
 8 |                              64  72  80  88  96 104 112 120 128 136 144 152 160
 9 |                                  81  90  99 108 117 126 135 144 153 162 171 180
10 |                                     100 110 120 130 140 150 160 170 180 190 200
11 |                                         121 132 143 154 165 176 187 198 209 220
12 |                                             144 156 168 180 192 204 216 228 240
13 |                                                 169 182 195 208 221 234 247 260
14 |                                                     196 210 224 238 252 266 280
15 |                                                         225 240 255 270 285 300
16 |                                                             256 272 288 304 320
17 |                                                                 289 306 323 340
18 |                                                                     324 342 360
19 |                                                                         361 380
20 |                                                                             400
</code></pre>
<p>Of course, the nice formatting starts to break when passing a parameter higher than 31 (because some results start to exceed 1,000 and to have more than 3 digits), but the initial requirement was just an <code>11*11</code> multiplication table. It would not be difficult to change the script to make it work with larger values (we could even dynamically adapt the formatting strings to the maximal output number), but nobody needs commonly a larger multiplication table.</p>
<h2 id="alternative-solutions">Alternative Solutions</h2>
<p>Again quite a high number of solutions (17) this time.</p>
<p><a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-033/arne-sommer/perl6/ch-2.p6">Arne Sommer</a> chose the simple strategy of hard coding the header, and then used two nested <code>for</code>loops for computing the products. He used the built-in <a href="https://docs.perl6.org/routine/fmt#class_Cool">fmt</a> formatting function, which, for numbers, essentially works in the same way as the <code>sprintf</code> function (or <code>printf</code>, except that <code>fmt</code> does not print the result but only returns the formatted string, so you have to add the print statement):</p>
<pre><code class="language-Perl6" data-lang="Perl6">say &quot;  x|   1   2   3   4   5   6   7   8   9  10  11&quot;;
say &quot;---+--------------------------------------------&quot;;

for 1 .. 11 -&gt; $row
{
  print $row.fmt('%3d') ~ &quot;|&quot;;
  print &quot;    &quot; x $row - 1;

  for $row .. 11 -&gt; $col
  {
    print ($row * $col).fmt('%4d');
  }
  print &quot;\n&quot;;
}
</code></pre><p><a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-033/mark-senn/perl6/ch-2.p6">Mark Senn</a> also hard-coded the printing of the header. He used two <code>for</code> loops for computing the results and the <code>printf</code> function for formatting the products:</p>
<pre><code class="language-Perl6" data-lang="Perl6">print q:to/END/;
  x|   1   2   3   4   5   6   7   8   9  10  11
---+--------------------------------------------
END

# Print rest of table.
my $n = 11;
for (1..$n) -&gt; $row
{
    &quot;%3d|&quot;.printf($row);
    for (1..$n) -&gt; $col
    {
        ($col &lt; $row)
        ??  &quot;    &quot;.print
        !!  &quot;%4d&quot;.printf($row*$col);
    }
    ''.say;
}
</code></pre><p><a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-033/daniel-mita/perl6/ch-2.p6">Daniel Mita</a> also used two <code>for</code> loops for computing the results and used the built-in <a href="https://docs.perl6.org/routine/sprintf">sprintf</a> function to format the output:</p>
<pre><code class="language-Perl6" data-lang="Perl6">sub MAIN (
  Int $max where * &gt; 0 = 11, #= The max number of the multiplication table (defaults to 11)
  --&gt; Nil
) {
  my @range   = 1 .. $max;
  my $spacing = @range[*-1]².chars + 1;

  print ' x|';
  print sprintf('%' ~ $spacing ~ 's', $_) for @range;
  print &quot;\n&quot;;
  print '--+';
  say [x] «
    -
    $spacing
    @range.elems()
  »;

  for @range -&gt; $a {
    print sprintf('%2s|', $a);
    for @range -&gt; $b {
      print sprintf('%' ~ $spacing ~ 's', $a ≤ $b ?? $a * $b !! '');
    }
    print &quot;\n&quot;;
  }
}
</code></pre><p><a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-033/kevin-colyer/perl6/ch-2.p6">Kevin Colyer</a> also used two <code>for</code> loops for computing the results and the <code>sprintf</code> function to format the results:</p>
<pre><code>sub MAIN($table=11) {

    # header
    print &quot;  x|&quot;;
    print frmt($_) for 1..$table;
    print &quot;\n&quot;;
    print &quot;---+&quot;;
    say   &quot;----&quot; x $table;

    # body
    for 1..$table -&gt; $i {
        print frmt($i,3) ~ &quot;|&quot;;
        print &quot;    &quot;      for 1..$i-1;
        print frmt($i*$_) for $i..$table;
        print &quot;\n&quot;;
    }
}

sub frmt($i, $pad=4, --&gt; Str) {
    return sprintf(&quot;%{$pad}s&quot;,$i);
}
</code></pre><p><a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-033/markus-holzer/perl6/ch-2.p6">Markus Holzer</a> created two subroutines, <code>header</code> and <code>line</code>, to manage the various types of output. His program uses a single <code>for</code> loop to run the <code>line</code> subroutine <em>n</em> times, each time with a different multiplier, and the <code>line</code> subroutine uses the range operator to create <em>n</em> multiplicands and store the products in an array. Quite a nice and imaginative solution in my view:</p>
<pre><code class="language-Perl6" data-lang="Perl6">sub MAIN( Int $n = 11 )
{
    my $ln = ( $n * $n ).chars + 1;
    my $li = $n.chars + 1;

    header;
    line $_ for ( 1 .. $n );

    sub line( $i )
    {
        my @n = ( ( $i .. $n ) X* $i ).map({ sprintf( &quot;%{$ln}s&quot;, $_ ) });
        my @e = ( ' ' xx ( $ln * ( $i - 1 ) ) );
        say sprintf( &quot;%{$li}s&quot;, $i ), '|', @e.join,  @n.join;
    }

    sub header
    {
        my @h = ( 1 .. $n ).map({ sprintf( &quot;%{$ln}s&quot;, $_ ) });
        say sprintf( &quot;%{$li}s&quot;, &quot;x&quot; ), '|', @h.join;
        say ( '-' xx $li ).join, &quot;+&quot;, ( '-' xx ( $n * $ln ) ).join;
    }
}
</code></pre><p><a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-033/noud/perl6/ch-2.p6">Noud</a> contributed a program that, contrary to my solution, can print out the multiplication tables for any upper value, since it first dynamically calculates the needed gap between numbers.</p>
<pre><code class="language-perl6" data-lang="perl6">sub print_mult_table($size) {
    # Determine the gap between the numbers.
    my $gap = ceiling(log10($size * $size)) + 1;

    print &quot; &quot; x $gap - 1;
    print &quot;x|&quot;;
    for 1..$size -&gt; $i {
        print($i.fmt('%' ~ $gap ~ 'd'));
    }
    print &quot;\n&quot;;

    print &quot;-&quot; x $gap ~ &quot;+&quot; ~ &quot;-&quot; x $size * $gap ~ &quot;\n&quot;;

    for 1..$size -&gt; $i {
        print $i.fmt('%' ~ $gap ~ 'd') ~ &quot;|&quot; ~ &quot; &quot; x ($i - 1) * $gap;
        for $i..$size -&gt; $j {
            print ($i * $j).fmt('%' ~ $gap ~ 'd');
        }
        print &quot;\n&quot;;
    }
}
</code></pre><p>As an example, this is the output for multiplication tables up to 33 (which wouldn&rsquo;t work proprely with my solution):</p>
<pre><code>    x|    1    2    3    4    5    6    7    8    9   10   11   12   13   14   15   16   17   18   19   20   21   22   23   24   25   26   27   28   29   30   31   32   33
-----+---------------------------------------------------------------------------------------------------------------------------------------------------------------------
    1|    1    2    3    4    5    6    7    8    9   10   11   12   13   14   15   16   17   18   19   20   21   22   23   24   25   26   27   28   29   30   31   32   33
    2|         4    6    8   10   12   14   16   18   20   22   24   26   28   30   32   34   36   38   40   42   44   46   48   50   52   54   56   58   60   62   64   66
    3|              9   12   15   18   21   24   27   30   33   36   39   42   45   48   51   54   57   60   63   66   69   72   75   78   81   84   87   90   93   96   99
    4|                  16   20   24   28   32   36   40   44   48   52   56   60   64   68   72   76   80   84   88   92   96  100  104  108  112  116  120  124  128  132
    5|                       25   30   35   40   45   50   55   60   65   70   75   80   85   90   95  100  105  110  115  120  125  130  135  140  145  150  155  160  165
    6|                            36   42   48   54   60   66   72   78   84   90   96  102  108  114  120  126  132  138  144  150  156  162  168  174  180  186  192  198
    7|                                 49   56   63   70   77   84   91   98  105  112  119  126  133  140  147  154  161  168  175  182  189  196  203  210  217  224  231
    8|                                      64   72   80   88   96  104  112  120  128  136  144  152  160  168  176  184  192  200  208  216  224  232  240  248  256  264
    9|                                           81   90   99  108  117  126  135  144  153  162  171  180  189  198  207  216  225  234  243  252  261  270  279  288  297
   10|                                               100  110  120  130  140  150  160  170  180  190  200  210  220  230  240  250  260  270  280  290  300  310  320  330
   11|                                                    121  132  143  154  165  176  187  198  209  220  231  242  253  264  275  286  297  308  319  330  341  352  363
   12|                                                         144  156  168  180  192  204  216  228  240  252  264  276  288  300  312  324  336  348  360  372  384  396
   13|                                                              169  182  195  208  221  234  247  260  273  286  299  312  325  338  351  364  377  390  403  416  429
   14|                                                                   196  210  224  238  252  266  280  294  308  322  336  350  364  378  392  406  420  434  448  462
   15|                                                                        225  240  255  270  285  300  315  330  345  360  375  390  405  420  435  450  465  480  495
   16|                                                                             256  272  288  304  320  336  352  368  384  400  416  432  448  464  480  496  512  528
   17|                                                                                  289  306  323  340  357  374  391  408  425  442  459  476  493  510  527  544  561
   18|                                                                                       324  342  360  378  396  414  432  450  468  486  504  522  540  558  576  594
   19|                                                                                            361  380  399  418  437  456  475  494  513  532  551  570  589  608  627
   20|                                                                                                 400  420  440  460  480  500  520  540  560  580  600  620  640  660
   21|                                                                                                      441  462  483  504  525  546  567  588  609  630  651  672  693
   22|                                                                                                           484  506  528  550  572  594  616  638  660  682  704  726
   23|                                                                                                                529  552  575  598  621  644  667  690  713  736  759
   24|                                                                                                                     576  600  624  648  672  696  720  744  768  792
   25|                                                                                                                          625  650  675  700  725  750  775  800  825
   26|                                                                                                                               676  702  728  754  780  806  832  858
   27|                                                                                                                                    729  756  783  810  837  864  891
   28|                                                                                                                                         784  812  840  868  896  924
   29|                                                                                                                                              841  870  899  928  957
   30|                                                                                                                                                   900  930  960  990
   31|                                                                                                                                                        961  992 1023
   32|                                                                                                                                                            1024 1056
   33|                                                                                                                                                                 1089
</code></pre>
<p>In theory, you could use any larger upper range values, but you&rsquo;ll be quickly limited by your screen width.</p>
<p><a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-033/ryan-thompson/perl6/ch-2.p6">Ryan Thompson</a> contributed a quite creative solution that can also handle large multipliers, since its <code>$fmt</code> formating string is dynamically adapted to the size of the largest product. His program uses the <code>fmt</code>function for format the output.</p>
<pre><code class="language-Perl6" data-lang="Perl6">use v6;

sub MAIN(Int $max = 11) {
    my $w     = ($max*$max).chars;  # Maximum width in table
    my $fmt   = &quot;%{$w}s&quot;;           # Evenly sized columns
    my @n     = 1..$max;            # Trivial to change this to, say, primes

    ('',       ' | ', @n                                    ).fmt($fmt).say;
    ('-' x $w, '-+-', '-' x $w xx $max                      ).fmt($fmt).say;

    for @n -&gt; $n {
        ($n,   ' | ', @n.map: { $n &gt; $^m ?? '' !! $n * $^m }).fmt($fmt).say;
    }
}
</code></pre><p>With an input value of 33, Ryan&rsquo;s program displays almost the same as the output of Noud&rsquo;s program just above.</p>
<p><a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-033/rnuttall/perl6/ch-2.p6">Richard Nuttall</a> made a fairly concise solution using a <code>for</code> loop and a range, and a single format string for everything:</p>
<pre><code class="language-Perl6" data-lang="Perl6">sub MAIN($lim = 11) {
    my         $fmt = &quot;%3s%1s&quot; ~ &quot;%4s&quot; x $lim ~ &quot;\n&quot;;
    printf     $fmt,  'x', '|',        1..$lim;
    printf     $fmt, '---','+', '----' xx $lim;
    for 1..$lim -&gt; $x {
        printf $fmt,  $x,  '|', ' ' xx $x-1, ($x..$lim) «*» $x;
    }
}
</code></pre><p><a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-033/simon-proctor/perl6/ch-2.p6">Simon Proctor</a> made, as often, a quite verbose solution with several multi <code>MAIN</code> subroutines, as well as a <code>format-row</code>, a <code>get-header</code>, and a <code>get-row</code> subroutines. This is part of his solution:</p>
<pre><code class="language-Perl6" data-lang="Perl6">multi sub MAIN(
    UInt $max = 11 #= Max number to print the table to
) {
    my &amp;formater = format-row( $max );
    .say for get-header( $max, &amp;formater );
    .say for (1..$max).map( { get-row( $max, &amp;formater, $_) } );
}

sub format-row( UInt $max ) {
    my $max-width = ($max*$max).codes;
    my $row = &quot; %{$max.codes}s |{&quot; %{$max-width}s&quot; x $max}&quot;;
    return sub ( *@data ) {
        sprintf $row, @data;
    }
}

sub get-header( UInt $max, &amp;formater ) {
    my $max-width = ($max*$max).codes;
    ( &amp;formater( &quot;x&quot;, |(1..$max) ), &quot;-&quot; x ( 3 + $max.codes + ( $max * ($max-width+1) ) ) );
}
</code></pre><p><a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-033/adam-russell/perl6/ch-2.p6">Adam Russel</a> also hard-coded the header and otherwise used the <a href="https://github.com/perl6/form">form</a> module to emulate the Perl 5 <code>format</code> fix-width output templating features for the header. For the result lines, his program uses a quite creative solution: it iterates over the <code>1..11</code> range and, for each value, creates an array <code>@a</code> of zeros followed by integers from the values to 11. For example, for <code>$x</code> value equal to 5, it would generate this array: <code>[0 0 0 0 5 6 7 8 9 10 11]</code>. The program then uses two chained <code>map</code> statements that multiply the non-zero integers by the value being used and the zeros by an empty string, so that the result <code>@b</code> array for value 5 is this: <code>[&quot;&quot;, &quot;&quot;, &quot;&quot;, &quot;&quot;, 25, 30, 35, 40, 45, 50, 55]</code>. Finally, the program uses <code>sprintf</code> to properly format this array.</p>
<pre><code class="language-Perl6" data-lang="Perl6">sub print_table11 {
    my ($x,$x1,$x2,$x3,$x4,$x5,$x6,$x7,$x8,$x9,$x10,$x11);
    my $header = form
        '    x|   1   2   3   4   5   6   7   8   9   10   11',
        '  ---+----------------------------------------------';
    print $header;
    for 1 .. 11 -&gt; $x {
        my @a;
        @a = (0) xx ($x -1) if $x &gt; 1;
        @a.append($x .. 11);
        my @b = map({$_ ==  0 ?? &quot;&quot; !! $_}, map({ $x * $_ }, @a));
        print sprintf '%5s|', $x;
        my $s = sprintf '%4s%4s%4s%4s%4s%4s%4s%4s%4s%5s%5s', @b;
        say $s;
    }
}
</code></pre><p><a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-033/jaldhar-h-vyas/perl6/ch-2.p6">Jaldhar H. Vyas</a> also contributed a quite creative solution. His program uses the <code>X</code> cross operator, chained with a <code>grep</code> and a <code>map</code>, to generate an array <code>@table</code> of all the products to be displayed in the multiplication table. It finally iterates over the multiplier range, picks up the desired array slice with the <code>splice</code> built-in function, format the results with <code>fmt</code> function and finally outputs them with the <code>printf</code> function:</p>
<pre><code class="language-Perl6" data-lang="Perl6">constant $N = 11;

say '  x|', (1 .. $N).fmt('% 4s', q{}), &quot;\n&quot;, '---+', ('----' x $N);
my @table = (1 .. $N X 1 .. $N).grep({ $_[1] &gt;= $_[0]}).map({ $_[0] * $_[1] });
for (1 .. $N) {
    printf &quot;% 3s|%s%s\n&quot;,
        $_,
        q{ } x 4 * ($_ - 1),
        @table.splice(0, $N - $_ + 1).fmt('% 4s', q{});
};
</code></pre><p><a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-033/athanasius/perl6/ch-2.p6">Athanasius</a> used two straight forward <code>for</code> loops for computing the values and <code>printf</code> for formatting the output:</p>
<pre><code class="language-Perl6" data-lang="Perl6"># Print the multipliers
'  x|'.print;
' %3d'.printf: $_ for 1 .. $MAX;
    ''.say;

# Print the horizontal divider
&quot;---+%s\n&quot;.printf: '-' x (4 * $MAX);

# Print the body of the multiplication table
for 1 .. $MAX -&gt; UInt $row
{
    # Print one row: the multiplicand, followed by those products for which
    #                the multiplier does not exceed the multiplicand

    '%3d|'.printf: $row;
   ' %3s' .printf: $row &gt; $_ ?? '' !! $row * $_ for 1 .. $MAX;
        ''.say;
}
</code></pre><p><a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-033/javier-luque/perl6/ch-2.p6">Javier Luque</a> created a <code>generate-x-table</code> subroutine looping over the multipliers range and two multi <code>table-content</code> subroutines, one to produce the header and the other to generate and format the results, using the <code>sprintf</code> function:</p>
<pre><code class="language-Perl6" data-lang="Perl6"># Generates the multiplication table
sub generate-x-table (Int $num) {
    table-content($_, $num).say for (0..$num);
}

# Returns the table head string
multi table-content(Int $current where { $current == 0}, Int $num) {
    my $line = &quot;%4s|&quot;.sprintf(&quot;x&quot;);
    $line ~= &quot;%4i&quot;.sprintf($_) for (1..$num);
    return $line ~ &quot;\n&quot; ~ '----+' ~ '----' x $num;
}

# Returns the table row string for $i
multi table-content(Int $current, Int $num) {
    my $line = &quot;%4i|&quot;.sprintf($current);

    for (1..$num) -&gt; $i {
        $line ~= ($current &lt;= $i) ??
            &quot;%4i&quot;.sprintf($i * $current) !! ' ' x 4;
    }

    return $line;
}
</code></pre><p><a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-033/joelle-maslak/perl6/ch-2.p6">Joelle Maslak</a> used two nested <code>for</code> loops to generate the results and the <code>fmt</code> built-in function to format them:</p>
<pre><code class="language-Perl6" data-lang="Perl6">sub MAIN(UInt:D $max = 11) {
    die &quot;Max must be ≥ 1&quot; if $max &lt; 1;

    my $maxlen  = (~ $max).chars;
    my $prodlen = (~ $max²).chars;

    # Header line
    print &quot;x&quot;.fmt(&quot;%{$maxlen+1}s&quot;) ~ &quot;|&quot;;
    say (1..$max)».fmt(&quot;%{$prodlen+1}d&quot;).join;

    # Seperator line
    say '-' x ($maxlen+1) ~ '+' ~ '-' x $max*($prodlen+1);

    for 1..$max -&gt; $i {
        # New row
        print $i.fmt(&quot;%{$maxlen+1}d&quot;) ~ '|';

        for 1..$max -&gt; $j {
            if ($i ≤ $j) {
                print ($i*$j).fmt(&quot;%{$prodlen+1}d&quot;);
            } else {
                print &quot; &quot; x ($prodlen+1);
            }
        }

        print &quot;\n&quot;;
    }
}
</code></pre><p><a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-033/ruben-westerberg/perl6/ch-2.p6">Ruben Westerberg</a> also used two nested <code>for</code> loops to compute the values, and he used <code>sprintf</code> to format the output:</p>
<pre><code class="language-Perl6" data-lang="Perl6">my $limit=@*ARGS[0]//11;
my $maxWidth=1+(chars $limit**2);
printRow &quot;&quot;, (1..$limit), $maxWidth;
put &quot;-&quot; x (($limit+2)*$maxWidth);
for 1..$limit {
    my $i=$_;
    my @row;
    my $header=$_;
    for 1..$limit {
        if $_ &gt;= $i {
            push @row, $i*$_;
        }
        else {
            push @row, &quot;&quot;;
        }
    }
    printRow($header,@row,$maxWidth);
}

sub printRow($header, $data, $minWidth) {
    my $output=&quot;&quot;;
    for @$data {
        $output ~= sprintf &quot;%&quot;~$minWidth~&quot;s&quot;,$_;
    }
    printf &quot;%&quot;~$minWidth~&quot;s|%s\n&quot;,$header,$output;
}
</code></pre><p><a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-033/roger-bell-west/perl6/ch-2.p6">Roger Bell West</a> also used two nested <code>for</code> loops and used the <code>printf</code> function to format and output the results:</p>
<pre><code class="language-Perl6" data-lang="Perl6">my $n=11;
my $m1=$n.chars+1;
my $m2=($n*$n).chars+1;
my $fmt='%' ~ $m1 ~ 's%1s' ~ (('%' ~ $m2 ~ 's') xx $n) ~ &quot;\n&quot;;
printf($fmt,'x','|',(1..$n));
printf($fmt,'-' x $m1,'+',('-' x $m2) xx $n);
for 1 .. $n -&gt; $row {
  my @a=($row,'|');
  for 1 .. $n -&gt; $column {
    if ($column &lt; $row) {
      push @a,'';
    } else {
      push @a,$row*$column;
    }
  }
  printf($fmt,@a);
}
</code></pre><p><a href="https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-033/ulrich-rieke/perl6/ch-2.p6">Ulrich Rieke</a> also used two nested <code>for</code> loops and used the <code>sprintf</code> function to format the output:</p>
<pre><code class="language-Perl6" data-lang="Perl6">sprintf(&quot;%4s&quot; , &quot;x|&quot; ).print ;
for (1..11) -&gt; $num {
  sprintf(&quot;%4d&quot; , $num ).print ;
}
print &quot;\n&quot; ;
say &quot;-&quot; x 48 ;
for (1..11) -&gt; $num {
  sprintf(&quot;%4s&quot; , &quot;$num|&quot; ).print ;
  if ( $num &gt; 1 ) {
      print &quot; &quot; x ( ($num - 1 ) * 4 ) ;
  }
  for ( $num..11 ) -&gt; $mult {
      sprintf(&quot;%4d&quot;, $num * $mult ).print ;
  }
  print &quot;\n&quot; ;
}
</code></pre><h2 id="see-also">SEE ALSO</h2>
<p>Five blog posts this time:</p>
<ul>
<li>
<p>Arne Sommer: <a href="https://raku-musings.com/add-mul.html;">https://raku-musings.com/add-mul.html;</a></p>
</li>
<li>
<p>Adam Russell: <a href="https://adamcrussell.livejournal.com/11383.html;">https://adamcrussell.livejournal.com/11383.html;</a></p>
</li>
<li>
<p>Jaldhar H. Vyas: <a href="https://www.braincells.com/perl/2019/11/perl_weekly_challenge_week_33.html;">https://www.braincells.com/perl/2019/11/perl_weekly_challenge_week_33.html;</a></p>
</li>
<li>
<p>Javier Luque: <a href="https://perlchallenges.wordpress.com/2019/11/05/perl-weekly-challenge-033/;">https://perlchallenges.wordpress.com/2019/11/05/perl-weekly-challenge-033/;</a></p>
</li>
<li>
<p>Roger Ball West: <a href="https://blog.firedrake.org/archive/2019/11/Perl_Weekly_Challenge_33.html">https://blog.firedrake.org/archive/2019/11/Perl_Weekly_Challenge_33.html</a>.</p>
</li>
</ul>
<h2 id="wrapping-up">Wrapping up</h2>
<p>Please let me know if I forgot any of the challengers or if you think my explanation of your code misses something important (send me an e-mail or just raise an issue against this GitHub page).</p>

                </div>
            </div>
        </div>
    </div>
</section>


<!-- Call To Action Section Start -->
<section id="call-to-action">
    <div class="container">
        <div class="row">
            <div class="col-md-12">
                <div class="block">
                    <h2 class="title wow fadeInDown" data-wow-delay=".3s" data-wow-duration="500ms">SO WHAT DO YOU THINK ?</h2>
                    <p class="wow fadeInDown" data-wow-delay=".5s" data-wow-duration="500ms">If you have any suggestions or ideas then please do share with us.</p>
                    <a href="/contact" class="btn btn-default btn-contact wow fadeInDown" data-wow-delay=".7s" data-wow-duration="500ms">Contact with me</a>
                </div>
            </div>

        </div>
    </div>
</section>
<!-- Call To Action Section End -->



<!-- Footer Section Start -->
<footer id="footer">
    <div class="container">
        <div class="row content-justify-between">
            <div class="col-md-8 col-12 text-center text-lg-left text-md-left">
                <p class="copyright">Copyright:
                    <span>
                        <script>document.write(new Date().getFullYear())</script>
                    </span> PerlWeeklyChallenge. Theme Design and Developed by
                    <a href="http://www.Themefisher.com" target="_blank">Themefisher</a>.
                </p>
            </div>
            <div class="col-md-4 col-12">
                <!-- Social Media -->
                <ul class="social text-center text-md-right text-lg-right">
                    <li>
                        <a href="https://twitter.com/PerlWChallenge" class="twitter" target="_blank" title="Follow us">
                            <i class="ion-social-twitter"></i>
                        </a>
                    </li>
                    <li>
                        <a href="/rss.xml" class="rss" target="_blank" title="RSS Feed">
                            <i class="ion-social-rss"></i>
                        </a>
                    </li>
                    <li>
                        <a href="https://www.nomtimes.co.uk/site/shop.do?cref=PerlBooks" title="Free Perl Books" target="_blank">
                            <img src="/images/NomTimes.jpg" style="width:22px; height: 18px;" alt=""/>
                        </a>
                    </li>
                </ul>
            </div>
        </div>
    </div>
</footer>
<!-- footer section end -->

<!-- jquery -->
<script src="https://perlweeklychallenge.org/plugins/jQurey/jquery.min.js"></script>
<!-- Form Validation -->
<script src="https://perlweeklychallenge.org/plugins/form-validation/jquery.form.js"></script>
<script src="https://perlweeklychallenge.org/plugins/form-validation/jquery.validate.min.js"></script>
<!-- slick slider -->
<script src="https://perlweeklychallenge.org/plugins/slick/slick.min.js"></script>
<!-- bootstrap js -->
<script src="https://perlweeklychallenge.org/plugins/bootstrap/bootstrap.min.js"></script>
<!-- chart js -->
<script src="https://perlweeklychallenge.org/plugins/chart/highstock.js"></script>
<script src="https://perlweeklychallenge.org/plugins/chart/drilldown.js"></script>
<script src="https://perlweeklychallenge.org/plugins/chart/data.js"></script>
<script src="https://perlweeklychallenge.org/plugins/chart/chart.js"></script>
<!-- wow js -->
<script src="https://perlweeklychallenge.org/plugins/wow-js/wow.min.js"></script>
<!-- slider js -->
<script src="https://perlweeklychallenge.org/plugins/slider/slider.js"></script>
<!-- Fancybox -->
<script src="https://perlweeklychallenge.org/plugins/facncybox/jquery.fancybox.js"></script>
<!-- template main js -->

<script src="https://perlweeklychallenge.org/js/script.min.js"></script>
<!-- google analitycs -->
<script>
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
    (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
    m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
    ga('create', 'UA-136524905-1', 'auto');
    ga('send', 'pageview');
</script>
</body>

</html>

